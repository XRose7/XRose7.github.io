<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C# Note——basic</title>
    <url>/2024/01/11/C#-basic/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/">C# 文档| Microsoft Docs</a></p>
</blockquote>
<h1 id="类型和成员">类型和成员</h1>
<p>作为面向对象的语言，C# 支持封装、继承和多态性这些概念。 类可能会直接继承一个父类，并且可以实现任意数量的接口。 若要用方法重写父类中的虚方法，必须使用 <code>override</code> 关键字，以免发生意外重定义。 在 C# 中，结构就像是轻量级类，是可以实现接口但不支持继承的堆栈分配类型。 C# 还可提供记录，这些记录是主要用于存储数据值的类类型。</p>
<h2 id="类和对象">类和对象</h2>
<p><em>类</em> 是最基本的 C# 类型。 类是一种数据结构，可在一个单元中就将状态（字段）和操作（方法和其他函数成员）结合起来。 类为类实例（亦称为“对象”）提供了定义 。 类支持 <em>继承</em> 和 <em>多形性</em>，即 <em>派生类</em> 可以扩展和专门针对 <em>基类</em> 的机制。</p>
<p>新类使用类声明进行创建。 类声明以标头开头。 标头指定以下内容：</p>
<ul>
<li>类的特性和修饰符</li>
<li>类的名称</li>
<li>基类（从<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/types#base-classes">基类</a>继承时）</li>
<li>接口由该类实现。</li>
</ul>
<p>标头后面是类主体，由在分隔符 <code>&#123;</code> 和 <code>&#125;</code> 内编写的成员声明列表组成。</p>
<p>以下代码展示的是简单类 <code>Point</code> 的声明：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span> =&gt; (X, Y) = (x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类实例是使用 <code>new</code> 运算符进行创建，此运算符为新实例分配内存，调用构造函数来初始化实例，并返回对实例的引用。 以下语句创建两个 <code>Point</code> 对象，并将对这些对象的引用存储在两个变量中：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>当无法再访问对象时，对象占用的内存会被自动回收。 没有必要也无法在 C# 中显式解除分配对象。</p>
<h3 id="类型参数">类型参数</h3>
<p>泛型类定义类型参数。 类型参数是用尖括号括起来的类型参数名称列表。 类型参数跟在类名后面。 然后，可以在类声明的主体中使用类型参数来定义类成员。 在以下示例中，<code>Pair</code> 的类型参数是 <code>TFirst</code> 和 <code>TSecond</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">TFirst</span>, <span class="title">TSecond</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TFirst First &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> TSecond Second &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span>(<span class="params">TFirst first, TSecond second</span>)</span> =&gt; </span><br><span class="line">        (First, Second) = (first, second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明为需要使用类型参数的类类型被称为 <em>泛型类类型</em>。 结构、接口和委托类型也可以是泛型。 使用泛型类时，必须为每个类型参数提供类型自变量：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pair = <span class="keyword">new</span> Pair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> i = pair.First;     <span class="comment">// TFirst int</span></span><br><span class="line"><span class="built_in">string</span> s = pair.Second; <span class="comment">// TSecond string</span></span><br></pre></td></tr></table></figure>
<p>包含类型自变量的泛型类型（如上面的 <code>Pair&lt;int,string&gt;</code>）被称为 <em>构造泛型类型</em>。</p>
<h3 id="基类">基类</h3>
<p>类声明可以指定基类。 在类名和类型参数后面加上冒号和基类的名称。 省略基类规范与从 <code>object</code> 类型派生相同。 在以下示例中，<code>Point3D</code> 的基类是 <code>Point</code> 在第一个示例中，<code>Point</code> 的基类是 <code>object</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point3D</span> : <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Z &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point3D</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> z</span>) : <span class="title">base</span>(<span class="params">x, y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Z = z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类继承其基类的成员。 继承意味着一个类隐式包含其基类的几乎所有成员。 类不继承实例、静态构造函数以及终结器。 派生类可以在其继承的成员中添加新成员，但无法删除继承成员的定义。 在上面的示例中，<code>Point3D</code> 从 <code>Point</code> 继承了 <code>X</code> 和 <code>Y</code> 成员，每个 <code>Point3D</code> 实例均包含三种属性（<code>X</code>、<code>Y</code> 和 <code>Z</code>）。</p>
<p>可以将类类型隐式转换成其任意基类类型。 类类型的变量可以引用相应类的实例或任意派生类的实例。 例如，类声明如上，<code>Point</code> 类型的变量可以引用 <code>Point</code> 或 <code>Point3D</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Point a = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">Point b = <span class="keyword">new</span> Point3D(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>请注意：</p>
<ul>
<li><strong>访问标识符</strong> <code>&lt;access specifier&gt;</code> 指定了对类及其成员的<strong>访问规则</strong>。如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 <strong><code>internal</code></strong>，成员的默认访问标识符是 <strong><code>private</code></strong>。</li>
<li><strong>数据类型</strong> <code>&lt;data type&gt;</code> 指定了<strong>变量（variables）</strong>的类型，<strong>返回类型</strong> <code>&lt;return type&gt;</code> 指定了返回的<strong>方法（methods）</strong>返回的数据类型。</li>
<li>如果要访问类的成员，你要使用<strong>点（<code>.</code>）运算符</strong>。</li>
<li>点运算符链接了对象的名称和成员的名称。</li>
</ul>
<h3 id="成员函数和封装">成员函数和封装</h3>
<p>类的成员函数是一个在类定义中有它的定义或原型的函数，就像其他变量一样。作为类的一个成员，它能在类的任何对象上操作，且能访问该对象的类的所有成员。</p>
<p>成员变量是对象的属性（从设计角度），且它们保持私有来实现封装。这些变量只能使用公共成员函数来访问。</p>
<h3 id="构造函数">构造函数</h3>
<p>类的 <strong>构造函数</strong> 是类的一个特殊的成员函数，当创建类的新对象时执行。</p>
<p>构造函数的名称与类的名称完全相同，它没有任何返回类型。</p>
<p><strong>默认的构造函数</strong>没有任何参数。但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做<strong>参数化构造函数</strong>。这种技术可以帮助你在创建对象的同时给对象赋初始值。</p>
<h2 id="析构函数">析构函数</h2>
<p>类的 <strong>析构函数</strong> 是类的一个特殊的成员函数，当类的对象超出范围时执行。</p>
<p>析构函数的名称是在类的名称前加上一个波浪形（<code>~</code>）作为前缀，它不返回值，也不带任何参数。</p>
<p>析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。</p>
<h2 id="类的静态成员">类的静态成员</h2>
<p>我们可以使用 <strong><code>static</code></strong> 关键字把类成员定义为静态的。当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。</p>
<p>关键字 <strong><code>static</code></strong> 意味着类中只有一个该成员的实例。静态变量用于定义常量，因为它们的值可以通过直接调用类而不需要创建类的实例来获取。静态变量可在成员函数或类的定义外部进行初始化。你也可以在类的定义内部初始化静态变量。</p>
<p>你也可以把一个<strong>成员函数</strong>声明为 <strong><code>static</code></strong>。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。</p>
<h1 id="c-数据类型">C# 数据类型</h1>
<p>在 C# 中，变量分为以下几种类型：</p>
<ul>
<li>值类型（Value types）</li>
<li>引用类型（Reference types）</li>
<li>指针类型（Pointer types）</li>
</ul>
<h2 id="value-types">Value types</h2>
<p>值类型变量可以直接分配给一个值。它们是从类 <strong>System.ValueType</strong> 中派生的。</p>
<p>值类型直接包含数据。比如 <strong>int、char、float</strong>，它们分别存储数字、字符、浮点数。当您声明一个 <strong>int</strong> 类型时，系统分配内存来存储值。</p>
<p>下表列出了 C# 2010 中可用的值类型：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">类型</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">范围</th>
<th style="text-align: left;">默认值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">布尔值</td>
<td style="text-align: left;">True 或 False</td>
<td style="text-align: left;">False</td>
</tr>
<tr class="even">
<td style="text-align: left;">byte</td>
<td style="text-align: left;">8 位无符号整数</td>
<td style="text-align: left;">0 到 255</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">char</td>
<td style="text-align: left;">16 位 Unicode 字符</td>
<td style="text-align: left;">U +0000 到 U +ffff</td>
<td style="text-align: left;">'\0'</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>decimal</strong></td>
<td style="text-align: left;">128 位精确的十进制值，28-29 有效位数</td>
<td style="text-align: left;">(-7.9 x 1028 到 7.9 x 1028) / 100 到 28</td>
<td style="text-align: left;">0.0M</td>
</tr>
<tr class="odd">
<td style="text-align: left;">double</td>
<td style="text-align: left;">64 位双精度浮点型</td>
<td style="text-align: left;">(+/-)5.0 x 10-324 到 (+/-)1.7 x 10308</td>
<td style="text-align: left;">0.0D</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">32 位单精度浮点型</td>
<td style="text-align: left;">-3.4 x 1038 到 + 3.4 x 1038</td>
<td style="text-align: left;">0.0F</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">32 位有符号整数类型</td>
<td style="text-align: left;">-2,147,483,648 到 2,147,483,647</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">long</td>
<td style="text-align: left;">64 位有符号整数类型</td>
<td style="text-align: left;">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
<td style="text-align: left;">0L</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sbyte</td>
<td style="text-align: left;">8 位有符号整数类型</td>
<td style="text-align: left;">-128 到 127</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">short</td>
<td style="text-align: left;">16 位有符号整数类型</td>
<td style="text-align: left;">-32,768 到 32,767</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>uint</strong></td>
<td style="text-align: left;">32 位无符号整数类型</td>
<td style="text-align: left;">0 到 4,294,967,295</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>ulong</strong></td>
<td style="text-align: left;">64 位无符号整数类型</td>
<td style="text-align: left;">0 到 18,446,744,073,709,551,615</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>ushort</strong></td>
<td style="text-align: left;">16 位无符号整数类型</td>
<td style="text-align: left;">0 到 65,535</td>
<td style="text-align: left;">0</td>
</tr>
</tbody>
</table>
<p>如需得到一个类型或一个变量在特定平台上的准确尺寸，可以使用 <strong>sizeof</strong> 方法。表达式 <em>sizeof(type)</em> 产生以字节为单位存储对象或类型的存储尺寸。</p>
<h3 id="struct-type">struct type</h3>
<p>类定义可支持继承和多形性的类型。 它们使你能够基于派生类的层次结构创建复杂的行为。 相比之下，<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/struct">结构</a>类型是较为简单的类型，其主要目的是存储数据值。 结构不能声明基类型；它们从 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.valuetype">System.ValueType</a> 隐式派生。 不能从 <code>struct</code> 类型派生其他 <code>struct</code> 类型。 这些类型已隐式密封。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> X &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Y &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span> =&gt; (X, Y) = (x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ref-struct-type"><code>ref</code> struct type</h4>
<p>你可以在<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/struct">结构类型</a>的声明中使用 <code>ref</code> 修饰符。 <code>ref struct</code> 类型的实例是在堆栈上分配的，不能转义到托管堆。 为了确保这一点，编译器将 <code>ref struct</code> 类型的使用限制如下：</p>
<ul>
<li><code>ref struct</code> 不能是数组的元素类型。</li>
<li><code>ref struct</code> 不能是类或非 <code>ref struct</code> 的字段的声明类型。</li>
<li><code>ref struct</code> 不能实现接口。</li>
<li><code>ref struct</code> 不能被装箱为 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.valuetype">System.ValueType</a> 或 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.object">System.Object</a>。</li>
<li><code>ref struct</code> 不能是类型参数。</li>
<li><code>ref struct</code> 变量不能由 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/lambda-expressions">Lambda 表达式</a>或<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/local-functions">本地函数</a>捕获。</li>
<li><code>ref struct</code> 变量不能在 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/async"><code>async</code></a> 方法中使用。 但是，可以在同步方法中使用 <code>ref struct</code> 变量，例如，在返回 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task">Task</a> 或 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1">Task</a> 的方法中。</li>
<li><code>ref struct</code> 变量不能在<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/iterators">迭代器</a>中使用。</li>
</ul>
<p>可以定义一次性的 <code>ref struct</code>。 为此，请确保 <code>ref struct</code> 符合<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-8.0/using#pattern-based-using">一次性模式</a>。 也就是说，它有一个实例 <code>Dispose</code> 方法，该方法是可访问、无参数的并且具有 <code>void</code> 返回类型。 可以将 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/using">using 语句或声明</a>与可释放的 <code>ref struct</code> 的实例一起使用。</p>
<p>通常，如果需要一种同时包含 <code>ref struct</code> 类型的数据成员的类型，可以定义 <code>ref struct</code> 类型：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">ref</span> <span class="keyword">struct</span> CustomRef</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsValid;</span><br><span class="line">    <span class="keyword">public</span> Span&lt;<span class="built_in">int</span>&gt; Inputs;</span><br><span class="line">    <span class="keyword">public</span> Span&lt;<span class="built_in">int</span>&gt; Outputs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若要将 <code>ref struct</code> 声明为 <code>readonly</code>，请在类型声明中组合使用 <code>readonly</code> 修饰符和 <code>ref</code> 修饰符（<code>readonly</code> 修饰符必须位于 <code>ref</code> 修饰符之前）：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">ref</span> <span class="keyword">struct</span> ConversionRequest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConversionRequest</span>(<span class="params"><span class="built_in">double</span> rate, ReadOnlySpan&lt;<span class="built_in">double</span>&gt; values</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Rate = rate;</span><br><span class="line">        Values = values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Rate &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> ReadOnlySpan&lt;<span class="built_in">double</span>&gt; Values &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 .NET 中，<code>ref struct</code> 的示例分别是 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.span-1">System.Span</a> 和 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.readonlyspan-1">System.ReadOnlySpan</a>。</p>
<h4 id="ref-fields"><code>ref</code> fields</h4>
<p>从 C# 11 开始，可以在 <code>ref struct</code> 中声明 <code>ref</code> 字段，如以下示例所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">ref</span> <span class="keyword">struct</span> RefFieldExample</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">ref</span> <span class="built_in">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetNumber</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.Runtime.CompilerServices.Unsafe.IsNullRef(<span class="keyword">ref</span> number))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;The number ref field is not initialized.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ref</code> 字段可能具有 <code>null</code> 值。 使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.unsafe.isnullref#system-runtime-compilerservices-unsafe-isnullref-1(-0@)">Unsafe.IsNullRef(T)</a> 方法确定 <code>ref</code> 字段是否为 <code>null</code>。</p>
<p>可通过以下方式将 <code>readonly</code> 修饰符应用于 <code>ref</code> 字段：</p>
<ul>
<li><code>readonly ref</code>：只能在构造函数或 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/init"><code>init</code> 访问器</a>中使用 <code>= ref</code> 运算符<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/assignment-operator#ref-assignment">通过 ref 重新赋值</a>此类字段。 可以在字段访问修饰符允许的任何时间点使用 <code>=</code> 运算符分配值。</li>
<li><code>ref readonly</code>：在任何时候，都不能使用 <code>=</code> 运算符为此类字段赋值。 但是，可以使用 <code>= ref</code> 运算符通过 ref 重新赋值字段。</li>
<li><code>readonly ref readonly</code>：只能在构造函数或 <code>init</code> 访问器中通过 ref 重新赋值此类字段。 在任何时候，都不能为字段赋值。</li>
</ul>
<p>编译器确保存储在 <code>ref</code> 字段中的引用的生存期不会超过其引用。</p>
<p><code>ref</code> 字段功能支持安全实现类型，例如 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.span-1">System.Span</a>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">ref</span> <span class="keyword">struct</span> Span&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">readonly</span> <span class="keyword">ref</span> T _reference;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Omitted for brevity...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Span&lt;T&gt;</code> 类型存储一个引用，通过该引用访问内存中的连续元素。 通过使用引用，<code>Span&lt;T&gt;</code> 实例可以避免复制它所引用的存储。</p>
<h3 id="enum-type">enum type</h3>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/enum">枚举</a>类型定义了一组常数值。 以下 <code>enum</code> 声明了定义不同根蔬菜的常数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> SomeRootVegetable</span><br><span class="line">&#123;</span><br><span class="line">    HorseRadish,</span><br><span class="line">    Radish,</span><br><span class="line">    Turnip</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以定义一个 <code>enum</code> 作为标志组合使用。 以下声明为四季声明了一组标志。 可以随意搭配季节组合，包括 <code>All</code> 值（包含所有季节）：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Seasons</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Summer = <span class="number">1</span>,</span><br><span class="line">    Autumn = <span class="number">2</span>,</span><br><span class="line">    Winter = <span class="number">4</span>,</span><br><span class="line">    Spring = <span class="number">8</span>,</span><br><span class="line">    All = Summer | Autumn | Winter | Spring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下示例显示了前面两个枚举的声明：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> turnip = SomeRootVegetable.Turnip;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> spring = Seasons.Spring;</span><br><span class="line"><span class="keyword">var</span> startingOnEquinox = Seasons.Spring | Seasons.Autumn;</span><br><span class="line"><span class="keyword">var</span> theYear = Seasons.All;</span><br></pre></td></tr></table></figure>
<h2 id="可为-null-的类型">可为 null 的类型</h2>
<p>任何类型的变量都可以声明为“不可为 null ”或“可为 null ”。 可为 null 的变量包含一个额外的 <code>null</code> 值，表示没有值。 可为 null 的值类型（结构或枚举）由 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.nullable-1">System.Nullable</a> 表示。 不可为 null 和可为 null 的引用类型都由基础引用类型表示。 这种区别由编译器和某些库读取的元数据体现。 当可为 null 的引用在没有先对照 <code>null</code> 检查其值的情况下取消引用时，编译器会发出警告。 当对不可为 null 的引用分配了可能为 <code>null</code> 的值时，编译器也会发出警告。 以下示例声明了“可为 null 的 int”，并将其初始化为 <code>null</code>。 然后将值设置为 <code>5</code>。 该示例通过“可为 null 的字符串” 演示了同一概念。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? optionalInt = <span class="literal">default</span>; </span><br><span class="line">optionalInt = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">string</span>? optionalText = <span class="literal">default</span>;</span><br><span class="line">optionalText = <span class="string">&quot;Hello World.&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/nullable-value-types">可为 null 的值类型</a>和<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/nullable-references">可为 null 的引用类型</a>。 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/nullable-value-types">可为 Null 的值类型</a>是使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.nullable-1">System.Nullable</a> 结构实现的。 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/nullable-reference-types">可为 Null 的引用类型</a>实现为向编译器提供语义规则的类型注释。</p>
<h2 id="temple-type">temple type</h2>
<p>C# 支持元组，后者提供了简洁的语法来将多个数据元素分组成一个轻型数据结构。 通过声明 <code>(</code> 和 <code>)</code> 之间的成员的类型和名称来实例化元组，如下例所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">double</span> Sum, <span class="built_in">int</span> Count) t2 = (<span class="number">4.5</span>, <span class="number">3</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Sum of <span class="subst">&#123;t2.Count&#125;</span> elements is <span class="subst">&#123;t2.Sum&#125;</span>.&quot;</span>);</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Sum of 3 elements is 4.5.</span></span><br></pre></td></tr></table></figure>
<p>元组为具有多个成员的数据结构提供了一种替代方法，且无需使用下一篇文章中介绍的构建基块。****</p>
<h2 id="reference-types">Reference types</h2>
<p>引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。</p>
<p>换句话说，它们指的是一个内存位置。</p>
<h3 id="class-type">class type</h3>
<h3 id="interface-type">interface type</h3>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/fundamentals/types/interfaces">接口</a>定义了可由类和结构实现的协定。 接口可以包含方法、属性、事件和索引器。 接口通常不提供所定义成员的实现，仅指定必须由实现接口的类或结构提供的成员。</p>
<p>接口可以采用 <strong><em>多重继承</em></strong>。 在以下示例中，接口 <code>IComboBox</code> 同时继承自 <code>ITextBox</code> 和 <code>IListBox</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IControl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Paint</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ITextBox</span> : <span class="title">IControl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetText</span>(<span class="params"><span class="built_in">string</span> text</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IListBox</span> : <span class="title">IControl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetItems</span>(<span class="params"><span class="built_in">string</span>[] items</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IComboBox</span> : <span class="title">ITextBox</span>, <span class="title">IListBox</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>类和结构可以实现多个接口。 在以下示例中，类 <code>EditBox</code> 同时实现 <code>IControl</code> 和 <code>IDataBound</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IDataBound</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bind</span>(<span class="params">Binder b</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditBox</span> : <span class="title">IControl</span>, <span class="title">IDataBound</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Paint</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Bind</span>(<span class="params">Binder b</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当类或结构实现特定接口时，此类或结构的实例可以隐式转换成相应的接口类型。 例如</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">EditBox editBox = <span class="keyword">new</span> EditBox();</span><br><span class="line">IControl control = editBox;</span><br><span class="line">IDataBound dataBound = editBox;</span><br></pre></td></tr></table></figure>
<h3 id="array-type">array type</h3>
<p>一维、多维和交错。 例如：<code>int[]</code>、<code>int[,]</code> 和 <code>int[][]</code></p>
<h3 id="delegate-type">delegate type</h3>
<p>格式为 <code>delegate int D(...)</code> 的用户定义类型</p>
<p>C# <strong>内置的</strong> 引用类型有：<strong>object</strong>、<strong>dynamic</strong> 和 <strong>string</strong>。</p>
<h3 id="object-type">Object type</h3>
<p><strong>对象（Object）类型</strong> 是 C# <strong>通用类型系统（Common Type System - CTS）</strong>中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p>
<p>当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> obj;</span><br><span class="line">obj = <span class="number">100</span>; <span class="comment">// 这是装箱</span></span><br></pre></td></tr></table></figure>
<h3 id="dynamic-type">Dynamic type</h3>
<p>您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</p>
<p>声明动态类型的语法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> &lt;variable_name&gt; = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> d = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。</p>
<h3 id="string-type">String type</h3>
<p><strong>字符串类型</strong> 允许您给变量分配任何字符串值。字符串类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @ 引号。</p>
<p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;runoob.com&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>一个 <span class="citation" data-cites="引号字符串">@引号字符串</span>：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="string">@&quot;runoob.com&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>C# string 字符串的前面可以加 @（称作"逐字字符串"）将转义字符（）当作普通字符对待，比如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;C:\Windows&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;C:\\Windows&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;!--</span></span><br><span class="line"><span class="string">    --&gt;</span></span><br><span class="line"><span class="string">&lt;/script&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>用户<strong>自定义</strong>引用类型有：<strong>Class、Interface 和 Delegate</strong>。我们将在以后的章节中讨论这些类型。</p>
<h2 id="pointer-types">Pointer types</h2>
<p>指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。</p>
<p>我们将在章节"<a href="https://www.runoob.com/csharp/csharp-unsafe-codes.html">C# 不安全代码 | 菜鸟教程 (runoob.com)</a>"中讨论指针类型。</p>
<p>下面是指针类型声明的实例：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">实例</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int* p</code></td>
<td style="text-align: left;"><code>p</code> 是指向整数的指针。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>double* p</code></td>
<td style="text-align: left;"><code>p</code> 是指向双精度数的指针。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>float* p</code></td>
<td style="text-align: left;"><code>p</code> 是指向浮点数的指针。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int** p</code></td>
<td style="text-align: left;"><code>p</code> 是指向整数的指针的指针。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int*[] p</code></td>
<td style="text-align: left;"><code>p</code> 是指向整数的指针的一维数组。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>char* p</code></td>
<td style="text-align: left;"><code>p</code> 是指向字符的指针。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void* p</code></td>
<td style="text-align: left;"><code>p</code> 是指向未知类型的指针。</td>
</tr>
</tbody>
</table>
<p><strong>在同一个声明中声明多个指针时，星号 * 仅与基础类型一起写入；而不是用作每个指针名称的前缀</strong>。 例如:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>* p1, p2, p3;     <span class="comment">// 正确  </span></span><br><span class="line"><span class="built_in">int</span> *p1, *p2, *p3;   <span class="comment">// 错误 </span></span><br></pre></td></tr></table></figure>
<h2 id="类型转换">类型转换</h2>
<p><a href="https://blog.csdn.net/wu_l_v/article/details/78989303">C#中的数据类型转换总结_wu_l_v的博客-CSDN博客_c#类型转换</a></p>
<p>C# 还提供了下列内置的类型转换方法：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">序号</th>
<th style="text-align: left;">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;"><strong>ToBoolean</strong> 如果可能的话，把类型转换为布尔型。</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: left;"><strong>ToByte</strong> 把类型转换为字节类型。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: left;"><strong>ToChar</strong> 如果可能的话，把类型转换为单个 Unicode 字符类型。</td>
</tr>
<tr class="even">
<td style="text-align: left;">4</td>
<td style="text-align: left;"><strong>ToDateTime</strong> 把类型（整数或字符串类型）转换为 日期-时间 结构。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">5</td>
<td style="text-align: left;"><strong>ToDecimal</strong> 把浮点型或整数类型转换为十进制类型。</td>
</tr>
<tr class="even">
<td style="text-align: left;">6</td>
<td style="text-align: left;"><strong>ToDouble</strong> 把类型转换为双精度浮点型。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">7</td>
<td style="text-align: left;"><strong>ToInt16</strong> 把类型转换为 16 位整数类型。</td>
</tr>
<tr class="even">
<td style="text-align: left;">8</td>
<td style="text-align: left;"><strong>ToInt32</strong> 把类型转换为 32 位整数类型。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">9</td>
<td style="text-align: left;"><strong>ToInt64</strong> 把类型转换为 64 位整数类型。</td>
</tr>
<tr class="even">
<td style="text-align: left;">10</td>
<td style="text-align: left;"><strong>ToSbyte</strong> 把类型转换为有符号字节类型。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">11</td>
<td style="text-align: left;"><strong>ToSingle</strong> 把类型转换为小浮点数类型。</td>
</tr>
<tr class="even">
<td style="text-align: left;">12</td>
<td style="text-align: left;"><strong>ToString</strong> 把类型转换为字符串类型。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">13</td>
<td style="text-align: left;"><strong>ToType</strong> 把类型转换为指定类型。</td>
</tr>
<tr class="even">
<td style="text-align: left;">14</td>
<td style="text-align: left;"><strong>ToUInt16</strong> 把类型转换为 16 位无符号整数类型。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">15</td>
<td style="text-align: left;"><strong>ToUInt32</strong> 把类型转换为 32 位无符号整数类型。</td>
</tr>
<tr class="even">
<td style="text-align: left;">16</td>
<td style="text-align: left;"><strong>ToUInt64</strong> 把类型转换为 64 位无符号整数类型。</td>
</tr>
</tbody>
</table>
<h3 id="var"><code>var</code></h3>
<p>从 Visual C# 3.0 开始，在方法范围中声明的变量可以具有隐式类型 <code>var</code> 。隐式类型的本地变量是强类型变量，但需要由编译器决定本地变量的类型。</p>
<p><code>var</code> 可代替任何类型，编译器会根据上下文来判断 <code>var</code> 应该用什么强类型。</p>
<blockquote>
<p>什么情况下用到 <code>var</code> ：</p>
<ul>
<li><p>当你无法确定自己将用的是什么类型，就可以使用 <code>var</code></p></li>
<li><p>类似 <code>object</code> ，但是效率比 <code>object</code> 高点</p></li>
</ul>
</blockquote>
<p>使用 <code>var</code> 定义变量时有以下特点：</p>
<ul>
<li><p>必须在定义时初始化。也就是必须是 <code>var s = “abcd”</code> 形式，而不能是如下形式：</p>
<ul>
<li><p><code>var s</code> ;</p></li>
<li><p><code>s = “abcd”</code> ；</p></li>
</ul></li>
<li><p>一但初始化完成，就不能再给变量赋与初始化值类型不同的值了</p></li>
<li><p><code>var</code> 要求是局部变量</p></li>
<li><p>使用 <code>var</code> 定义变量和 <code>object</code> 不同， <code>var</code> 在效率上和使用强类型方式定义变量完全一样</p></li>
</ul>
<h1 id="常量">常量</h1>
<p>常量是固定值，程序执行期间不会改变。常量可以是任何基本数据类型，比如整数常量、浮点常量、字符常量或者字符串常量，还有枚举常量。</p>
<p>常量可以被当作常规的变量，只是它们的值在定义后不能被修改。</p>
<h2 id="整数常量">整数常量</h2>
<p>整数常量可以是十进制、八进制或十六进制的常量。<strong>前缀</strong>指定基数：0x 或 0X 表示<strong>十六进制</strong>，0 表示<strong>八进制</strong>，没有前缀则表示<strong>十进制</strong>。</p>
<p>整数常量也可以有后缀，可以是 U 和 L 的组合，其中，U 和 L 分别表示 unsigned 和 long。后缀可以是大写<strong>或者</strong>小写，多个后缀以任意顺序进行组合。</p>
<p>这里有一些整数常量的实例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="number">212</span>         <span class="comment">/* 合法 */</span></span><br><span class="line"><span class="number">215u</span>        <span class="comment">/* 合法 */</span></span><br><span class="line"><span class="number">0xFee</span>L      <span class="comment">/* 合法 */</span></span><br><span class="line"><span class="number">078</span>         <span class="comment">/* 非法：8 不是一个八进制数字 */</span></span><br><span class="line"><span class="number">032U</span>U       <span class="comment">/* 非法：不能重复后缀 */</span></span><br></pre></td></tr></table></figure>
<p>以下是各种类型的整数常量的实例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="number">85</span>         <span class="comment">/* 十进制 */</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">/* 八进制 */</span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">/* 十六进制 */</span></span><br><span class="line"><span class="number">30</span>         <span class="comment">/* int */</span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">/* 无符号 int */</span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">/* long */</span></span><br><span class="line"><span class="number">30u</span>l       <span class="comment">/* 无符号 long */</span></span><br></pre></td></tr></table></figure>
<h2 id="浮点常量">浮点常量</h2>
<p>一个浮点常量是由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式<strong>或者</strong>指数形式来表示浮点常量。</p>
<p>这里有一些浮点常量的实例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159</span>       <span class="comment">/* 合法 */</span></span><br><span class="line"><span class="number">314159E-5</span>L    <span class="comment">/* 合法 */</span></span><br><span class="line"><span class="number">510</span>E          <span class="comment">/* 非法：不完全指数 */</span></span><br><span class="line"><span class="number">210f</span>          <span class="comment">/* 非法：没有小数或指数 */</span></span><br><span class="line">.e55          <span class="comment">/* 非法：缺少整数或小数 */</span></span><br></pre></td></tr></table></figure>
<p>使用浮点形式表示时，必须包含小数点、指数或同时包含两者。使用指数形式表示时，必须包含整数部分、小数部分或同时包含两者。有符号的指数是用 e 或 E 表示的。</p>
<p>浮点常量的后缀一般为F/f（float型），L/l（long double型）。如果无后缀默认为double型。</p>
<h2 id="字符常量">字符常量</h2>
<p>字符常量是括在单引号里，例如，'x'，且可存储在一个简单的字符类型变量中。<strong>一个字符常量</strong>可以是<strong>一个普通字符</strong>（例如 'x'）、<strong>一个转义序列</strong>（例如 '）或者<strong>一个通用字符</strong>（例如 '2C0'）。</p>
<p>在 C# 中有一些特定的字符，当它们的前面带有反斜杠时有特殊的意义，可用于表示换行符（）或制表符 tab（。在这里，列出一些转义序列码：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">转义序列</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">\\</td>
<td style="text-align: left;"> 字符</td>
</tr>
<tr class="even">
<td style="text-align: left;">\'</td>
<td style="text-align: left;">' 字符</td>
</tr>
<tr class="odd">
<td style="text-align: left;">\"</td>
<td style="text-align: left;">" 字符</td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">? 字符</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">Alert 或 bell</td>
</tr>
<tr class="even">
<td style="text-align: left;"> 退格键（Backspace）</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"> 换页符（Form feed）</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">换行符（Newline）</td>
</tr>
<tr class="odd">
<td style="text-align: left;"> 回车</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"> 水平制表符 tab</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"> 垂直制表符 tab</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">一到三位 <code>o</code> 的八进制数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">一个或多个 <code>h</code> 的十六进制数</td>
</tr>
</tbody>
</table>
<blockquote>
<p>，每一个 d 表示了一个 0-7 的数字，整个 表示一个用八进制数表示的ASCII字符。~</p>
<p>，每一个 h 表示了一个 0-9 或 A-F 或 a-f 的 16 进制字符，整个 表示一个用十六进制数表示的ASCII字符。</p>
</blockquote>
<h2 id="字符串常量">字符串常量</h2>
<p>字符串常量是括在双引号 <code>""</code> 里，或者是括在 <code>@""</code> 里。字符串常量包含的字符与字符常量相似，可以是：普通字符、转义序列和通用字符</p>
<p>使用字符串常量时，可以把一个很长的行拆成多个行，可以使用空格分隔各个部分。</p>
<p>这里是一些字符串常量的实例。下面所列的各种形式表示相同的字符串。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;hello, world&quot;</span>;                  <span class="comment">// hello, world</span></span><br><span class="line"><span class="built_in">string</span> b = <span class="string">@&quot;hello, world&quot;</span>;               <span class="comment">// hello, world</span></span><br><span class="line"><span class="built_in">string</span> c = <span class="string">&quot;hello \t world&quot;</span>;               <span class="comment">// hello     world</span></span><br><span class="line"><span class="built_in">string</span> d = <span class="string">@&quot;hello \t world&quot;</span>;               <span class="comment">// hello \t world</span></span><br><span class="line"><span class="built_in">string</span> e = <span class="string">&quot;Joe said \&quot;Hello\&quot; to me&quot;</span>;      <span class="comment">// Joe said &quot;Hello&quot; to me</span></span><br><span class="line"><span class="built_in">string</span> f = <span class="string">@&quot;Joe said &quot;&quot;Hello&quot;&quot; to me&quot;</span>;   <span class="comment">// Joe said &quot;Hello&quot; to me</span></span><br><span class="line"><span class="comment">/*注意line6和line9的区别，line6里要想输出“”，直接用引号的话会造成歧义，而且用转义字符是没有用的，只能打两个引号以示需要输出引号*/</span></span><br><span class="line"><span class="built_in">string</span> g = <span class="string">&quot;\\\\server\\share\\file.txt&quot;</span>;   <span class="comment">// \\server\share\file.txt</span></span><br><span class="line"><span class="built_in">string</span> h = <span class="string">@&quot;\\server\share\file.txt&quot;</span>;      <span class="comment">// \\server\share\file.txt</span></span><br><span class="line"><span class="built_in">string</span> i = <span class="string">&quot;one\r\ntwo\r\nthree&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> j = <span class="string">@&quot;one</span></span><br><span class="line"><span class="string">two</span></span><br><span class="line"><span class="string">three&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="定义常量">定义常量</h2>
<p>常量是使用 <strong>const</strong> 关键字来定义的 。定义一个常量的语法如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &lt;data_type&gt; &lt;constant_name&gt; = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>
<p>下面的代码演示了如何在程序中定义和使用常量：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConstTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title">SampleClass</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> c1 = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> c2 = c1 + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">SampleClass</span>(<span class="params"><span class="built_in">int</span> p1, <span class="built_in">int</span> p2</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			x = p1;</span><br><span class="line">			y = p2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		SampleClass mC = <span class="keyword">new</span> SampleClass(<span class="number">11</span>, <span class="number">22</span>);</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;x = &#123;0&#125;, y = &#123;1&#125;&quot;</span>, mC.x, mC.y);</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;c1 = &#123;0&#125;, c2 = &#123;1&#125;&quot;</span>,</span><br><span class="line">		SampleClass.c1, SampleClass.c2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">x = <span class="number">11</span>, y = <span class="number">22</span></span><br><span class="line">c1 = <span class="number">5</span>, c2 = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/baobingji/article/details/104502875?ops_request_misc=%7B%22request%5Fid%22%3A%22162700105616780357242724%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=162700105616780357242724&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-104502875.first_rank_v2_pc_rank_v29&amp;utm_term=C%23定义常量&amp;spm=1018.2226.3001.4187">C#定义常量的两种方法_baobingji的博客-CSDN博客_c#定义常量</a></p>
<h1 id="c-运算符">C# 运算符</h1>
<p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C# 有丰富的内置运算符，分类如下：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<h2 id="算术运算符">算术运算符</h2>
<p>下表显示了 C# 支持的所有算术运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">+</td>
<td style="text-align: left;">把两个操作数相加</td>
<td style="text-align: left;">A + B 将得到 30</td>
</tr>
<tr class="even">
<td style="text-align: left;">-</td>
<td style="text-align: left;">从第一个操作数中减去第二个操作数</td>
<td style="text-align: left;">A - B 将得到 -10</td>
</tr>
<tr class="odd">
<td style="text-align: left;">*</td>
<td style="text-align: left;">把两个操作数相乘</td>
<td style="text-align: left;">A * B 将得到 200</td>
</tr>
<tr class="even">
<td style="text-align: left;">/</td>
<td style="text-align: left;">分子除以分母</td>
<td style="text-align: left;">B / A 将得到 2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">%</td>
<td style="text-align: left;">取模运算符，整除后的余数</td>
<td style="text-align: left;">B % A 将得到 0</td>
</tr>
<tr class="even">
<td style="text-align: left;">++</td>
<td style="text-align: left;">自增运算符，整数值增加 1</td>
<td style="text-align: left;">A++ 将得到 11</td>
</tr>
<tr class="odd">
<td style="text-align: left;">--</td>
<td style="text-align: left;">自减运算符，整数值减少 1</td>
<td style="text-align: left;">A-- 将得到 9</td>
</tr>
</tbody>
</table>
<h2 id="关系运算符">关系运算符</h2>
<p>下表显示了 C# 支持的所有关系运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">==</td>
<td style="text-align: left;">检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td style="text-align: left;">(A == B) 不为真。</td>
</tr>
<tr class="even">
<td style="text-align: left;">!=</td>
<td style="text-align: left;">检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td style="text-align: left;">(A != B) 为真。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&gt;</td>
<td style="text-align: left;">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td style="text-align: left;">(A &gt; B) 不为真。</td>
</tr>
<tr class="even">
<td style="text-align: left;">&lt;</td>
<td style="text-align: left;">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td style="text-align: left;">(A &lt; B) 为真。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&gt;=</td>
<td style="text-align: left;">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
<td style="text-align: left;">(A &gt;= B) 不为真。</td>
</tr>
<tr class="even">
<td style="text-align: left;">&lt;=</td>
<td style="text-align: left;">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
<td style="text-align: left;">(A &lt;= B) 为真。</td>
</tr>
</tbody>
</table>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p>下表显示了 C# 支持的所有逻辑运算符。假设变量 <strong>A</strong> 为布尔值 true，变量 <strong>B</strong> 为布尔值 false，则：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">&amp;&amp;</td>
<td style="text-align: left;">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td style="text-align: left;">(A &amp;&amp; B) 为假。</td>
</tr>
<tr class="even">
<td style="text-align: left;">||</td>
<td style="text-align: left;">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
<td style="text-align: left;">(A || B) 为真。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">!</td>
<td style="text-align: left;">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td style="text-align: left;">!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody>
</table>
<h2 id="位运算符">位运算符</h2>
<p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">p</th>
<th style="text-align: left;">q</th>
<th style="text-align: left;">p &amp; q</th>
<th style="text-align: left;">p | q</th>
<th style="text-align: left;">p ^ q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">0</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
</tbody>
</table>
<p>下表列出了 C# 支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 4%" />
<col style="width: 47%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">&amp;</td>
<td style="text-align: left;">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
<td style="text-align: left;">(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr class="even">
<td style="text-align: left;">|</td>
<td style="text-align: left;">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
<td style="text-align: left;">(A | B) 将得到 61，即为 0011 1101</td>
</tr>
<tr class="odd">
<td style="text-align: left;">^</td>
<td style="text-align: left;">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>
<td style="text-align: left;">(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr class="even">
<td style="text-align: left;">~</td>
<td style="text-align: left;">按位取反运算符是一元运算符，具有"翻转"位效果，即0变成1，1变成0，包括符号位。</td>
<td style="text-align: left;">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&lt;&lt;</td>
<td style="text-align: left;">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
<td style="text-align: left;">A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr class="even">
<td style="text-align: left;">&gt;&gt;</td>
<td style="text-align: left;">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
<td style="text-align: left;">A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody>
</table>
<h2 id="赋值运算符">赋值运算符</h2>
<p>下表列出了 C# 支持的赋值运算符：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">=</td>
<td style="text-align: left;">简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td style="text-align: left;">C = A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr class="even">
<td style="text-align: left;">+=</td>
<td style="text-align: left;">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td style="text-align: left;">C += A 相当于 C = C + A</td>
</tr>
<tr class="odd">
<td style="text-align: left;">-=</td>
<td style="text-align: left;">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td style="text-align: left;">C -= A 相当于 C = C - A</td>
</tr>
<tr class="even">
<td style="text-align: left;">*=</td>
<td style="text-align: left;">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td style="text-align: left;">C <em>= A 相当于 C = C </em> A</td>
</tr>
<tr class="odd">
<td style="text-align: left;">/=</td>
<td style="text-align: left;">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td style="text-align: left;">C /= A 相当于 C = C / A</td>
</tr>
<tr class="even">
<td style="text-align: left;">%=</td>
<td style="text-align: left;">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td style="text-align: left;">C %= A 相当于 C = C % A</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&lt;&lt;=</td>
<td style="text-align: left;">左移且赋值运算符</td>
<td style="text-align: left;">C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>
</tr>
<tr class="even">
<td style="text-align: left;">&gt;&gt;=</td>
<td style="text-align: left;">右移且赋值运算符</td>
<td style="text-align: left;">C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&amp;=</td>
<td style="text-align: left;">按位与且赋值运算符</td>
<td style="text-align: left;">C &amp;= 2 等同于 C = C &amp; 2</td>
</tr>
<tr class="even">
<td style="text-align: left;">^=</td>
<td style="text-align: left;">按位异或且赋值运算符</td>
<td style="text-align: left;">C ^= 2 等同于 C = C ^ 2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">|=</td>
<td style="text-align: left;">按位或且赋值运算符</td>
<td style="text-align: left;">C |= 2 等同于 C = C | 2</td>
</tr>
</tbody>
</table>
<h2 id="其他运算符">其他运算符</h2>
<p>下表列出了 C# 支持的其他一些重要的运算符，包括 <strong>sizeof</strong>、<strong>typeof</strong> 和 <strong>? :</strong>。</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 34%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">sizeof()</td>
<td style="text-align: left;">返回数据类型的大小</td>
<td style="text-align: left;">sizeof(int)，将返回 4.</td>
</tr>
<tr class="even">
<td style="text-align: left;">typeof()</td>
<td style="text-align: left;">返回 class 的类型</td>
<td style="text-align: left;">typeof(StreamReader);</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&amp;</td>
<td style="text-align: left;">返回变量的地址</td>
<td style="text-align: left;">&amp;a; 将得到变量的实际地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;">*</td>
<td style="text-align: left;">变量的指针</td>
<td style="text-align: left;">*a; 将指向一个变量。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">? :</td>
<td style="text-align: left;">条件表达式</td>
<td style="text-align: left;">如果条件为真 ? 则为 X : 否则为 Y</td>
</tr>
<tr class="even">
<td style="text-align: left;">is</td>
<td style="text-align: left;">判断对象是否为某一类型</td>
<td style="text-align: left;">If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">as</td>
<td style="text-align: left;">强制转换，即使转换失败也不会抛出异常</td>
<td style="text-align: left;">Object obj = new StringReader("Hello"); StringReader r = obj as StringReader;</td>
</tr>
</tbody>
</table>
<h2 id="运算符优先级">运算符优先级</h2>
<p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p>
<p>例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p>
<p>下表将<strong>按运算符优先级从高到低</strong>列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">类别</th>
<th style="text-align: left;">运算符</th>
<th style="text-align: left;">结合性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">后缀</td>
<td style="text-align: left;">() [] -&gt; . ++ - -</td>
<td style="text-align: left;">从左到右</td>
</tr>
<tr class="even">
<td style="text-align: left;">一元</td>
<td style="text-align: left;">+ - ! ~ ++ - - (type) * &amp; sizeof</td>
<td style="text-align: left;">从右到左</td>
</tr>
<tr class="odd">
<td style="text-align: left;">乘除</td>
<td style="text-align: left;">* / %</td>
<td style="text-align: left;">从左到右</td>
</tr>
<tr class="even">
<td style="text-align: left;">加减</td>
<td style="text-align: left;">+ -</td>
<td style="text-align: left;">从左到右</td>
</tr>
<tr class="odd">
<td style="text-align: left;">移位</td>
<td style="text-align: left;">&lt;&lt; &gt;&gt;</td>
<td style="text-align: left;">从左到右</td>
</tr>
<tr class="even">
<td style="text-align: left;">关系</td>
<td style="text-align: left;">&lt; &lt;= &gt; &gt;=</td>
<td style="text-align: left;">从左到右</td>
</tr>
<tr class="odd">
<td style="text-align: left;">相等</td>
<td style="text-align: left;">== !=</td>
<td style="text-align: left;">从左到右</td>
</tr>
<tr class="even">
<td style="text-align: left;">位与 AND</td>
<td style="text-align: left;">&amp;</td>
<td style="text-align: left;">从左到右</td>
</tr>
<tr class="odd">
<td style="text-align: left;">位异或 XOR</td>
<td style="text-align: left;">^</td>
<td style="text-align: left;">从左到右</td>
</tr>
<tr class="even">
<td style="text-align: left;">位或 OR</td>
<td style="text-align: left;">|</td>
<td style="text-align: left;">从左到右</td>
</tr>
<tr class="odd">
<td style="text-align: left;">逻辑与 AND</td>
<td style="text-align: left;">&amp;&amp;</td>
<td style="text-align: left;">从左到右</td>
</tr>
<tr class="even">
<td style="text-align: left;">逻辑或 OR</td>
<td style="text-align: left;">||</td>
<td style="text-align: left;">从左到右</td>
</tr>
<tr class="odd">
<td style="text-align: left;">条件</td>
<td style="text-align: left;">?:</td>
<td style="text-align: left;">从右到左</td>
</tr>
<tr class="even">
<td style="text-align: left;">赋值</td>
<td style="text-align: left;">= += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= ^= |=</td>
<td style="text-align: left;">从右到左</td>
</tr>
<tr class="odd">
<td style="text-align: left;">逗号</td>
<td style="text-align: left;">,</td>
<td style="text-align: left;">从左到右</td>
</tr>
</tbody>
</table>
<h1 id="namespace">Namespace</h1>
<p><strong>命名空间</strong>的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。</p>
<h2 id="定义命名空间">定义命名空间</h2>
<p>命名空间的定义是以关键字 <strong>namespace</strong> 开始，后跟命名空间的名称，如下所示：</p>
<p><strong>namespace</strong> namespace_name { <em>// 代码声明</em> }</p>
<p>为了调用支持命名空间版本的函数或变量，会把命名空间的名称置于前面，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace_name.item_name;</span><br></pre></td></tr></table></figure>
<h2 id="using-关键字"><em>using</em> 关键字</h2>
<p><strong>using</strong> 关键字表明程序使用的是给定命名空间中的名称。例如，我们在程序中使用 <strong>System</strong> 命名空间，其中定义了类 Console。我们可以只写：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine (<span class="string">&quot;Hello there&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以写完全限定名称，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">System.Console.WriteLine(<span class="string">&quot;Hello there&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>您也可以使用 <strong>using</strong> 命名空间指令，这样在使用的时候就不用在前面加上命名空间名称。该指令告诉编译器随后的代码使用了指定命名空间中的名称。下面的代码演示了命名空间的应用。</p>
<h2 id="嵌套命名空间">嵌套命名空间</h2>
<p>命名空间可以被嵌套，即您可以在一个命名空间内定义另一个命名空间，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace namespace_name1 </span><br><span class="line">&#123;</span><br><span class="line">   // 代码声明</span><br><span class="line">   namespace namespace_name2 </span><br><span class="line">   &#123;</span><br><span class="line">     // 代码声明</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用点（.）运算符访问嵌套的命名空间的成员。</p>
<h1 id="class">Class</h1>
<p>当你定义一个类时，你定义了一个数据类型的蓝图。这实际上并没有定义任何的数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象由什么组成及在这个对象上可执行什么操作。对象是类的实例。构成类的方法和变量称为类的成员。</p>
<h2 id="类的定义">类的定义</h2>
<p>类的定义是以关键字 <strong><code>class</code></strong> 开始，后跟类的名称。类的主体，包含在一对 <code>&#123;&#125;</code> 内。下面是类定义的一般形式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;access specifier&gt; <span class="keyword">class</span> <span class="title">class_name</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// member variables</span></span><br><span class="line">	&lt;access specifier&gt; &lt;data type&gt; variable1;</span><br><span class="line">	&lt;access specifier&gt; &lt;data type&gt; variable2;</span><br><span class="line">	...</span><br><span class="line">	&lt;access specifier&gt; &lt;data type&gt; variableN;</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">// member methods</span></span><br><span class="line">	&lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; method1(parameter_list)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// method body</span></span><br><span class="line">	&#125;</span><br><span class="line">	&lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; method2(parameter_list)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// method body</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	&lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; methodN(parameter_list)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// method body</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c-switch-语句">C# switch 语句</h1>
<p>一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 <strong>switch case</strong> 进行检查。</p>
<h2 id="语法">语法</h2>
<p>C# 中 <strong>switch</strong> 语句的语法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 您可以有任意数量的 case 语句 */</span></span><br><span class="line">    <span class="literal">default</span> : <span class="comment">/* 可选的 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>switch</strong> 语句必须遵循下面的规则：</p>
<ul>
<li><strong>switch</strong> 语句中的 <strong>expression</strong> 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。</li>
<li>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</li>
<li>case 的 <strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量。</li>
<li>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</li>
<li>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</li>
<li>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句为空，则可以不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</li>
<li>C# 不允许从一个开关部分继续执行到下一个开关部分。如果 case 语句中有处理语句，则必须包含 <strong>break</strong> 或其他跳转语句。</li>
<li>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</li>
<li>C# 不支持从一个 case 标签显式贯穿到另一个 case 标签。如果要使 C# 支持从一个 case 标签显式贯穿到另一个 case 标签，可以使用 goto 一个 switch-case 或 goto default。</li>
</ul>
<h1 id="嵌套-switch">嵌套 switch</h1>
<p>您可以把一个 <strong>switch</strong> 作为一个外部 <strong>switch</strong> 的语句序列的一部分，即可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。即使内部和外部 switch 的 case 常量包含共同的值，也没有矛盾。</p>
<h2 id="语法-1">语法</h2>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch1)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">		printf(<span class="string">&quot;这个 A 是外部 switch 的一部分&quot;</span> );</span><br><span class="line">		<span class="keyword">switch</span>(ch2)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">				printf(<span class="string">&quot;这个 A 是内部 switch 的一部分&quot;</span> );</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">/* 内部 B case 代码 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">/* 外部 B case 代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>LCP 61 气温变化趋势</title>
    <url>/2024/06/21/LCP61/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.cn/problems/6CE719/">气温变化趋势 - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/6CE719/solutions/1847507/mo-ni-by-endlesscheng-mc05">简洁写法 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">temperatureTrend</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">            <span class="built_in">return</span> (x &gt; y) - (x &lt; y);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> same = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cmp</span>(a[i - <span class="number">1</span>], a[i]) == <span class="built_in">cmp</span>(b[i - <span class="number">1</span>], b[i])) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, ++same);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                same = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 100 Same Tree</title>
    <url>/2024/02/26/LeetCode100/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/same-tree/description/">Same Tree - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>经典二叉树遍历. 递归，若当前 <code>p</code> <code>q</code> 节点都不存在，返回 <code>true</code> ；若有且只有一个不存在，返回 <code>false</code> ；若都存在，则判断 <code>val</code> 是否相等，再递归判断其左右子树.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(p || q)) &#123; <span class="comment">// !p &amp;&amp; !q</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(p &amp;&amp; q)) &#123; <span class="comment">// !p || !q</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// p &amp;&amp; q</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val == q-&gt;val) &#123;</span><br><span class="line">                <span class="built_in">return</span> (<span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(h)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>binary-tree</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1004 Max Consecutive Ones III</title>
    <url>/2024/01/28/LeetCode1004/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/max-consecutive-ones-iii/description/">Max Consecutive Ones III - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>sliding window. 窗口大小不固定，需要根据 k 变化. 使用右边界指针 j 遍历 nums ，当 i j 之间的 0 的数量超过 k ，则更新 i 到下一个 0 的位置.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// number of zero</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; count &amp;&amp; nums[i++] == <span class="number">0</span>) &#123; <span class="comment">// only if (k &lt; count) holds, will (i++) be executed</span></span><br><span class="line">                <span class="comment">// keep the maximum number of window size</span></span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j - i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="another-approach">Another approach</h3>
<blockquote>
<p><strong>Binary Search</strong></p>
<p><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/solutions/608931/zui-da-lian-xu-1de-ge-shu-iii-by-leetcod-hw12/">1004. 最大连续1的个数 III 题解 - 力扣（LeetCode）</a></p>
</blockquote>
<h3 id="similar-questions">Similar questions</h3>
<p><a href="https://leetcode.com/problems/longest-repeating-character-replacement/">Longest Repeating Character Replacement</a></p>
<p><a href="https://leetcode.com/problems/max-consecutive-ones/">Max Consecutive Ones</a></p>
<p><a href="https://leetcode.com/problems/max-consecutive-ones-ii/">Max Consecutive Ones II</a></p>
<p><a href="https://leetcode.com/problems/maximize-the-confusion-of-an-exam/">Maximize the Confusion of an Exam</a></p>
<p><a href="https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/">Minimum Recolors to Get K Consecutive Black Blocks</a></p>
<p><a href="https://leetcode.com/problems/longest-nice-subarray/">Longest Nice Subarray</a></p>
<p><a href="https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/">Maximum Sum of Distinct Subarrays With Length K</a></p>
<p><a href="https://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/">Maximum Enemy Forts That Can Be Captured</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>sliding-window</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-75</tag>
        <tag>sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1026 Maximum Difference Between Node and Ancestor</title>
    <url>/2024/04/05/LeetCode1026/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/">Maximum Difference Between Node and Ancestor - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一眼递归x</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">getMaxRootDiff</span>(root, root-&gt;val, num1);</span><br><span class="line">            <span class="type">int</span> num2 = <span class="built_in">maxAncestorDiff</span>(root-&gt;left);</span><br><span class="line">            <span class="type">int</span> num3 = <span class="built_in">maxAncestorDiff</span>(root-&gt;right);</span><br><span class="line">            res = <span class="built_in">max</span>(res, num1);</span><br><span class="line">            res = <span class="built_in">max</span>(res, num2);</span><br><span class="line">            res = <span class="built_in">max</span>(res, num3);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getMaxRootDiff</span><span class="params">(TreeNode* root, <span class="type">int</span> valOfRoot, <span class="type">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="type">int</span> num = <span class="built_in">abs</span>(root-&gt;val - valOfRoot);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; res) &#123;</span><br><span class="line">                res = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">getMaxRootDiff</span>(root-&gt;left, valOfRoot, res);</span><br><span class="line">            <span class="built_in">getMaxRootDiff</span>(root-&gt;right, valOfRoot, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>time: O(n^2)</p>
<p>space: O(n^2)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<p>实际上只需要一次递归遍历找出树中最小值和最大值即可，之所以可行就是因为递归保留现场，左子树的最小值和最大值不会干扰右子树.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minVal = root-&gt;val, maxVal = root-&gt;val;</span><br><span class="line">        <span class="built_in">differ</span>(root, minVal, maxVal);</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">differ</span><span class="params">(TreeNode* root, <span class="type">int</span> minVal, <span class="type">int</span> maxVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        diff = <span class="built_in">max</span>(diff, <span class="built_in">max</span>(<span class="built_in">abs</span>(minVal - root-&gt;val), <span class="built_in">abs</span>(maxVal - root-&gt;val)));</span><br><span class="line">        minVal = <span class="built_in">min</span>(minVal, root-&gt;val);</span><br><span class="line">        maxVal = <span class="built_in">max</span>(maxVal, root-&gt;val);</span><br><span class="line">        <span class="built_in">differ</span>(root-&gt;left, minVal, maxVal);</span><br><span class="line">        <span class="built_in">differ</span>(root-&gt;right, minVal, maxVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>time: O(n)</p>
<p>space: O(n)</p>
<h3 id="another-approach">Another approach</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/solutions/2232367/liang-chong-fang-fa-zi-ding-xiang-xia-zi-wj9v">两种方法：自顶向下/自底向上 - 灵茶山艾府</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1038 Binary Search Tree to Greater Sum Tree</title>
    <url>/2024/06/25/LeetCode1038/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/">Binary Search Tree to Greater Sum Tree - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/solutions/2552797/jian-ji-xie-fa-li-yong-er-cha-sou-suo-sh-r5zm">简洁写法，利用二叉搜索树的性质 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right); <span class="comment">// 递归右子树</span></span><br><span class="line">        s += node-&gt;val;</span><br><span class="line">        node-&gt;val = s; <span class="comment">// 此时 s 就是 &gt;= node-&gt;val 的所有数之和</span></span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left); <span class="comment">// 递归左子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">bstToGst</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>binary-tree</tag>
        <tag>tree</tag>
        <tag>binary-search-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1043 Partition Array for Maximum Sum</title>
    <url>/2024/02/03/LeetCode1043/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/partition-array-for-maximum-sum/description/">Partition Array for Maximum Sum - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>想了很多，最后还是感觉直接看题解好了</p>
<blockquote>
<p><a href="https://leetcode.cn/problems/partition-array-for-maximum-sum/solutions/2234242/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-rq5i/">1043. 分隔数组以得到最大和 题解</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i, tmpMax = <span class="number">0</span>; j &gt; i - k &amp;&amp; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                tmpMax = <span class="built_in">max</span>(tmpMax, arr[j]);</span><br><span class="line">                dp[i + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>], dp[j] + (i - j + <span class="number">1</span>) * tmpMax);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nk)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>dp 最重要的破局点还是寻找子问题，写递推式.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1071 Greatest Common Divisor of Strings</title>
    <url>/2024/01/15/LeetCode1071/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/greatest-common-divisor-of-strings/description/">Greatest Common Divisor of Strings - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>仔细观察题目，若有解，则两个字符串均为循环字符串，怎样合并都是一个结果，因此可得出以下算法</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">gcdOfStrings</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str1 + str2 == str2 + str1) &#123;</span><br><span class="line">            <span class="keyword">return</span> str1.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="built_in">gcd</span>(str1.<span class="built_in">size</span>(), str2.<span class="built_in">size</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>array/string</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>LeetCode-75</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1052 Grumpy Bookstore Owner</title>
    <url>/2024/06/21/LeetCode1052/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/grumpy-bookstore-owner/">Grumpy Bookstore Owner - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/solutions/2751888/ding-chang-hua-dong-chuang-kou-fu-ti-dan-rch7">定长滑动窗口 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSatisfied</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; customers, vector&lt;<span class="type">int</span>&gt;&amp; grumpy, <span class="type">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> satisfied = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = customers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i] == <span class="number">0</span>) satisfied += customers[i];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> saved = <span class="number">0</span>, maxSaved = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            saved += grumpy[i] * customers[i];</span><br><span class="line">            <span class="keyword">if</span> (i - j + <span class="number">1</span> &gt; X) &#123;</span><br><span class="line">                saved -= grumpy[j] * customers[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxSaved = <span class="built_in">max</span>(maxSaved, saved);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> satisfied + maxSaved;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1074 Number of Submatrices That Sum to Target</title>
    <url>/2024/01/28/LeetCode1074/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/description/">Number of Submatrices That Sum to Target - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>运用 prefix sum 的思想对数组做一些预处理，然后再暴力遍历所有的情况. 遍历时，先确定子矩阵的两条边，如左边界和右边界，再遍历上边界，计算子矩阵到底边界的 cur (current sum of submatrix) 。同时在确定子矩阵的左边界和右边界的情况下，维护一个 hash map，其 key 为 cur ，其 value 为 cur 出现的次数. 遍历到一个 cur - target 的值在 map 中的情况时，说明 cur - (cur - target) == target 即当前子矩阵的面积减去之前同左右边界的子矩阵的面积等于 target ，满足条件的子矩阵数 +1 .</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(); <span class="comment">// number of row</span></span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="comment">// number of column</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">// prefix sum</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                matrix[i][j] += matrix[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// left bound</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123; <span class="comment">// right bound</span></span><br><span class="line">                unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// key: sum of submatrix, value: number of occurrences</span></span><br><span class="line">                map = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">                <span class="type">int</span> cur = <span class="number">0</span>; <span class="comment">// current sum of submatrix</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123; <span class="comment">// top bound</span></span><br><span class="line">                    cur += matrix[k][j] - (i &gt; <span class="number">0</span> ? matrix[k][i - <span class="number">1</span>] : <span class="number">0</span>); <span class="comment">// calculate the current sum of submatrix</span></span><br><span class="line">                    res += map.<span class="built_in">find</span>(cur - target) != map.<span class="built_in">end</span>() ? map[cur - target] : <span class="number">0</span>; <span class="comment">// let x = cur - target, if map has the &#x27;x&#x27; key, it shows that cur - x == target</span></span><br><span class="line">                    map[cur]++; <span class="comment">// record the &#x27;cur&#x27; key</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n * n * m)</p>
<p>Space: O(m)</p>
<h2 id="notes">Notes</h2>
<h3 id="similar-questions">Similar Questions</h3>
<p><a href="https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/description/">Disconnect Path in a Binary Matrix by at Most One Flip - LeetCode</a></p>
<p><a href="https://leetcode.com/problems/subarray-sum-equals-k/description/">Subarray Sum Equals K - LeetCode</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 11 Container With Most Water</title>
    <url>/2024/01/23/LeetCode11/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/container-with-most-water/description/">Container With Most Water - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一开始想的是递归比较指针微调的面积并返回最大值，结果没想到时间复杂度有点高.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMaxArea</span>(height, <span class="number">0</span>, height.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> area = (j - i) * <span class="built_in">min</span>(height[i], height[j]);</span><br><span class="line">        <span class="type">int</span> larea = <span class="built_in">getMaxArea</span>(height, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> rarea = <span class="built_in">getMaxArea</span>(height, i + <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(area, <span class="built_in">max</span>(larea, rarea));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(2^n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<p>直接双指针遍历记录 maxArea ，若左墙矮于右墙，则左墙往里移一格可能获得更大的面积值，右墙同理.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> currentArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            currentArea = (j - i) * <span class="built_in">min</span>(height[i], height[j]);</span><br><span class="line">            maxArea = <span class="built_in">max</span>(maxArea, currentArea);</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>two-pointers</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-75</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1143 Longest Common Subsequence</title>
    <url>/2024/01/25/LeetCode1143/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/longest-common-subsequence/description/">Longest Common Subsequence - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>dp . 但是我一开始想的 dp 递推式有问题，做了半天还是 wa ，最后学了题解. dp 代码真是一看就懂，一做就废 :)</p>
<h2 id="notes">Notes</h2>
<h3 id="approach">Approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = text1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = text2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> dp[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initiate the dp array</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt;= m; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt;= n; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         dp[i][j] = 0;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mn)</p>
<p>Space: O(mn)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1171 Remove Zero Sum Consecutive Nodes from Linked List</title>
    <url>/2024/03/12/LeetCode1171/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">Remove Zero Sum Consecutive Nodes from Linked List - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/solutions/2304678/python3javacgotypescript-yi-ti-yi-jie-qi-3vsy">一题一解：前缀和 + 哈希表 - ylb</a></p>
<p><strong>若链表节点的两个前缀和相等，说明两个前缀和之间的连续节点序列的和为 0 ，那么可以消去这部分连续节点.</strong></p>
<p><a href="https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/solutions/2297308/cong-lian-biao-zhong-shan-qu-zong-he-zhi-h18o/comments/2040654">从链表中删去总和值为零的连续节点 - 题解评论 - Edward Elric</a></p>
<p>但删除也带来了一定问题，那就是删除掉的一系列节点的区间和需要“作废”，否则后续你再次尝试查找区间和时，可能会查到已经被删除的节点对应的区间和，产生“幽灵”一般的效果。所以最初遇见这题，想要做单次遍历，想到的很自然是在需要删除时，顺便删除掉所有对应的哈希表项（间接导致我需要记录下每个节点对应的前缀和）</p>
<p>这样就不会有“幽灵区间”的问题了，但是代码看起来不大好看了，复杂度方面，由于删除的节点最多就n个，所以时间复杂度仍然是<code>O(n)</code>。而题解则是用了一种<strong>更加巧妙</strong>的做法：</p>
<ul>
<li>第一遍遍历，记录前缀和和节点，如果有多个相同的前缀和，则保留最后一个（这个很重要）</li>
<li>第二遍遍历，第一次遇到相同前缀和，则直接进行删除（删掉第一次和最后一次相同前缀和的整个序列）</li>
<li>第一遍遍历保留最后一个，确保了第二遍总是会向后查找，而非向前查找，也就不需要去动态维护 map 里的元素了</li>
</ul>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeZeroSumSublists</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">int</span> prefix = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, ListNode*&gt; seen;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* node = dummy; node; node = node-&gt;next) &#123;</span><br><span class="line">            prefix += node-&gt;val;</span><br><span class="line">            seen[prefix] = node;</span><br><span class="line">        &#125;</span><br><span class="line">        prefix = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* node = dummy; node; node = node-&gt;next) &#123;</span><br><span class="line">            prefix += node-&gt;val;</span><br><span class="line">            node-&gt;next = seen[prefix]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>hash-table</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1207 Unique Number of Occurrences</title>
    <url>/2024/01/17/LeetCode1207/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/unique-number-of-occurrences/description/">Unique Number of Occurrences - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>用一个 unordered_map 记录各数字的出现次数，再存到 vector 中 sort ，再遍历 sort 后的 vector ，若存在重复值则返回 false .</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            m[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; record;</span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; kv : m) &#123;</span><br><span class="line">            record.<span class="built_in">push_back</span>(kv.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(record.<span class="built_in">begin</span>(), record.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> pre = *record.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; record.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] == pre) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = record[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="unordered_map-c11"><code>unordered_map</code> (C++11)</h3>
<blockquote>
<p><a href="https://en.cppreference.com/w/cpp/container/unordered_map">std::unordered_map - cppreference.com</a></p>
</blockquote>
<p>unordered_map 使用了 hash map 原理实现，其增删改查时间复杂度均为 O(1) ，空间复杂度均为 O(n) .</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 122 Best Time to Buy and Sell Stock II</title>
    <url>/2024/01/13/LeetCode122/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/">Best Time to Buy and Sell Stock II - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>没什么思路，学的题解.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                profit += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="notes">Notes</h2>
<p>DP</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>top-interview-150</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>top-interview-150</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 121 Best Time to Buy and Sell Stock</title>
    <url>/2024/01/13/LeetCode121/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">Best Time to Buy and Sell Stock - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>动态规划，可以是从后往前更新最大出售价，也可以是从前往后更新最小购买价，再更新最大利益.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxPrices</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        maxPrices[n<span class="number">-1</span>] = prices[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            maxPrices[i] = <span class="built_in">max</span>(maxPrices[i+<span class="number">1</span>], prices[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            maxProfit = <span class="built_in">max</span>(maxProfit, maxPrices[i] - prices[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1239 Maximum Length of a Concatenated String with Unique Characters</title>
    <url>/2024/01/23/LeetCode1239/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/description/">Maximum Length of a Concatenated String with Unique Characters - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>学的题解. 递归回溯法遍历，记录 maxLength .</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(vector&lt;string&gt;&amp; arr, string current, <span class="type">int</span> start, <span class="type">int</span>&amp; maxLength)</span> </span>&#123;</span><br><span class="line">        maxLength = <span class="built_in">max</span>(maxLength, (<span class="type">int</span>)(current.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isValid</span>(current, arr[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">backTrack</span>(arr, current + arr[i], i + <span class="number">1</span>, maxLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> string current, <span class="type">const</span> string append)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : append) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">count</span>(ch) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">insert</span>(ch);</span><br><span class="line">            <span class="keyword">if</span> (current.<span class="built_in">find</span>(ch) != string::npos) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;string&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">backTrack</span>(arr, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, maxLength);</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(2^n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach-1">Better approach 1</h3>
<blockquote>
<p><strong>Bitmask for Character Presence:</strong></p>
<ul>
<li>It uses a bitmask (<code>charSet</code>) to efficiently track the presence of characters in the current combination.</li>
<li>Each bit in the mask corresponds to a character ('a' to 'z').</li>
<li>If a bit is set (1), it means the corresponding character is present in the combination.</li>
</ul>
<p><strong>Validation:</strong></p>
<ul>
<li><p>The <code>isValidString</code> flag is used to check if the current string can be added to the combination without repeating characters.</p></li>
<li><p>It iterates through each character of the current string, updating the bitmask.</p></li>
</ul>
<p><strong>Count Unique Characters:</strong></p>
<ul>
<li>After processing all strings in the combination, it counts the number of unique characters by counting set bits in the <code>charSet</code>.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;string&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">backTrack</span>(arr, <span class="number">0</span>, <span class="number">0</span>, maxLength);</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; arr, <span class="type">int</span> index, <span class="type">int</span> charSet, <span class="type">int</span>&amp; maxLength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == arr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((charSet &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = <span class="built_in">max</span>(maxLength, count);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> newCharSet = charSet;</span><br><span class="line">        <span class="type">bool</span> isValidString = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : arr[index]) &#123;</span><br><span class="line">            <span class="type">int</span> bit = <span class="number">1</span> &lt;&lt; (ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> ((newCharSet &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                newCharSet |= bit;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isValidString = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isValidString) &#123;</span><br><span class="line">            <span class="built_in">backTrack</span>(arr, index + <span class="number">1</span>, newCharSet, maxLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backTrack</span>(arr, index + <span class="number">1</span>, charSet, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(2^n)</p>
<p>Space: O(1)</p>
<h3 id="better-approach-2">Better approach 2</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;string&gt;&amp; arr)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// [1] we should first throw away all strings with any</span></span><br><span class="line">        <span class="comment">//    duplicate characters; strings with all unique </span></span><br><span class="line">        <span class="comment">//    characters are the subsets of the alphabet, thus,</span></span><br><span class="line">        <span class="comment">//    can be encoded using binary form</span></span><br><span class="line">        vector&lt;bitset&lt;26&gt;&gt; unique;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            bitset&lt;26&gt; bin;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch : s) bin.<span class="built_in">set</span>(ch - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (bin.<span class="built_in">count</span>() == s.<span class="built_in">size</span>())</span><br><span class="line">                unique.<span class="built_in">push_back</span>(bin);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// [2] now start with an empty concatenation and iteratively</span></span><br><span class="line">        <span class="comment">//    increase its length by trying to add more strings</span></span><br><span class="line">        vector&lt;bitset&lt;26&gt;&gt; concat = &#123;<span class="built_in">bitset</span>&lt;<span class="number">26</span>&gt;()&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; u : unique)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = concat.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> ((concat[i] &amp; u).<span class="built_in">none</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    concat.<span class="built_in">push_back</span>(concat[i] | u);</span><br><span class="line">                    max_len = <span class="built_in">max</span>(max_len, (<span class="type">int</span>)(concat[i].<span class="built_in">count</span>() + u.<span class="built_in">count</span>()));</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1248 Count Number of Nice Subarrays</title>
    <url>/2024/06/22/LeetCode1248/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/count-number-of-nice-subarrays/">Count Number of Nice Subarrays - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/count-number-of-nice-subarrays/solutions/212966/count-number-of-nice-subarrays-by-ikaruga">【统计「优美子数组」】滑动窗口一次遍历 - Ikaruga</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">numberOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; odd;</span><br><span class="line">        odd.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == nums.<span class="built_in">size</span>() || (nums[j] &amp; <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                odd.<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (odd.<span class="built_in">size</span>() - i &gt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> left = odd[i] - odd[i - <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> right = j - odd[odd.<span class="built_in">size</span>() - <span class="number">2</span>];</span><br><span class="line">                ans += left * right;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>sliding-window</tag>
        <tag>hash-table</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1261 Find Elements in a Contaminated Binary Tree</title>
    <url>/2024/03/12/LeetCode1261/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/">Find Elements in a Contaminated Binary Tree - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>dfs 加辅助存储用空间换时间.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FindElements</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="built_in">FindElements</span>(TreeNode* root) &#123;</span><br><span class="line">        root-&gt;val = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(TreeNode*)&gt; dfs = [&amp;](TreeNode* root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = root-&gt;val * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                    ++map[tmp];</span><br><span class="line">                    root-&gt;left-&gt;val = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = root-&gt;val * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">                    ++map[tmp];</span><br><span class="line">                    root-&gt;right-&gt;val = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">                <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map[target] &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FindElements object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FindElements* obj = new FindElements(root);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;find(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Time:</p>
<ul>
<li>FindElements(): O(n)</li>
<li>find(): O(1)</li>
</ul>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="faster-dfs-hash-map-approach">Faster DFS + hash map approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FindElements</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = root-&gt;val * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                ++map[tmp];</span><br><span class="line">                root-&gt;left-&gt;val = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = root-&gt;val * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">                ++map[tmp];</span><br><span class="line">                root-&gt;right-&gt;val = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FindElements</span>(TreeNode* root) &#123;</span><br><span class="line">        root-&gt;val = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map[target] &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FindElements object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FindElements* obj = new FindElements(root);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;find(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Time:</p>
<ul>
<li>FindElements(): O(n)</li>
<li>find(): O(1)</li>
</ul>
<p>Space: O(n)</p>
<h3 id="dfs-bit-manipulation-approach">DFS + bit manipulation approach</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/solutions/2674238/zai-shou-wu-ran-de-er-cha-shu-zhong-cha-5l56x">在受污染的二叉树中查找元素</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FindElements</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode *root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FindElements</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = root;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *node, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = val;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left, val * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right, val * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        target++;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">30</span> - __builtin_clz(target);</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((target &amp; (<span class="number">1</span> &lt;&lt; k)) == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(min(H, log target))</p>
<blockquote>
<p>Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>binary-tree</tag>
        <tag>tree</tag>
        <tag>hash-table</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 129 Sum Root to Leaf Numbers</title>
    <url>/2024/04/15/LeetCode129/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">Sum Root to Leaf Numbers - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接 DFS 就好. 遇到叶子节点就把累计的数值加到结果上.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>, TreeNode*)&gt; dfs = [&amp;](<span class="type">int</span> num, TreeNode* root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + root-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">                    res += num;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">dfs</span>(num, root-&gt;left);</span><br><span class="line">                <span class="built_in">dfs</span>(num, root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>binary-tree</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1249 Minimum Remove to Make Valid Parentheses</title>
    <url>/2024/04/06/LeetCode1249/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/">Minimum Remove to Make Valid Parentheses - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>栈的应用. 括号匹配，不过这次右括号也要入栈，最后栈中残余的括号就是无法匹配的括号，将其从字符串中删除即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minRemoveToMakeValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res = s;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; s[stk.<span class="built_in">top</span>()] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    stk.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">erase</span>(stk.<span class="built_in">top</span>(), <span class="number">1</span>);</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="counting-approach">Counting approach</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/solutions/1081746/2chong-jie-fa-jian-ji-dai-ma-miao-dong-x-a1lg">2种解法,简洁代码,秒懂详解--[1249] - 疯子</a></p>
<p><a href="https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/solutions/914566/cpython18xing-dai-ma-fei-zhan-shi-xian-t-00bs">C++/Python【18行代码/非栈实现】：统计右括号个数，遍历时挨个判断是否需要保留 - Bandari</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minRemoveToMakeValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="built_in">count</span>(<span class="built_in">begin</span>(s), <span class="built_in">end</span>(s), <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r &gt; <span class="number">0</span>) result += c, l++, r--; <span class="comment">// 增加配对计数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                l &gt; <span class="number">0</span> ? result += c, l-- : r--; <span class="comment">// 进行配对</span></span><br><span class="line">            <span class="keyword">else</span> result += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1291 Sequential Digits</title>
    <url>/2024/02/02/LeetCode1291/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/sequential-digits/description/">Sequential Digits - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接遍历显然太慢，需要缩小遍历范围. 一开始想着固定位数的 sequential digits 少，打算根据 low 和 high 的位数遍历位数对应的范围内的 sequential digits ，但实现起来有点麻烦，觉得不该如此:) 看了题解，发现可以用空间换时间，直接把所有的 sequential digits 编成数组，遍历该数组即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sequentialDigits</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> allNums[<span class="number">37</span>] = &#123;<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">45</span>, <span class="number">56</span>, <span class="number">67</span>, <span class="number">78</span>, <span class="number">89</span>,</span><br><span class="line">                           <span class="number">123</span>, <span class="number">234</span>, <span class="number">345</span>, <span class="number">456</span>, <span class="number">567</span>, <span class="number">678</span>, <span class="number">789</span>,</span><br><span class="line">                           <span class="number">1234</span>, <span class="number">2345</span>, <span class="number">3456</span>, <span class="number">4567</span>, <span class="number">5678</span>, <span class="number">6789</span>,</span><br><span class="line">                           <span class="number">12345</span>, <span class="number">23456</span>, <span class="number">34567</span>, <span class="number">45678</span>, <span class="number">56789</span>,</span><br><span class="line">                           <span class="number">123456</span>, <span class="number">234567</span>, <span class="number">345678</span>, <span class="number">456789</span>,</span><br><span class="line">                           <span class="number">1234567</span>, <span class="number">2345678</span>, <span class="number">3456789</span>,</span><br><span class="line">                           <span class="number">12345678</span>, <span class="number">23456789</span>,</span><br><span class="line">                           <span class="number">123456789</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">37</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (allNums[i] &lt; low) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (allNums[i] &gt; high) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(allNums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(1)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="another-approach">Another approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sequentialDigits</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums, ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string x = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                x += s[j];</span><br><span class="line">                <span class="type">int</span> num = <span class="built_in">stoi</span>(x); <span class="comment">// stoi-C++11</span></span><br><span class="line">                <span class="keyword">if</span> (low &lt;= num &amp;&amp; num &lt;= high) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(1)</p>
<p>Space: O(1)</p>
<h3 id="dfs-approach">DFS approach</h3>
<p>将数字视作节点， dfs 时记录当前路径所代表的 sequential digit 值，若该值在范围内则弹入结果数组中. 若该值大于 high 或当前数字节点大于 9 ，则表明需要回溯到上一节点.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> low,<span class="type">int</span> high,<span class="type">int</span> i,<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= low &amp;&amp; num &lt;= high) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; high || i &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(low, high, i + <span class="number">1</span>, num * <span class="number">10</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sequentialDigits</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">          <span class="built_in">dfs</span>(low, high, i, <span class="number">0</span>);</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(1)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>depth-first-search</tag>
        <tag>enumeration</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1347 Minimum Number of Steps to Make Two Strings Anagram</title>
    <url>/2024/01/13/LeetCode1347/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/description/">Minimum Number of Steps to Make Two Strings Anagram - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一眼就觉得是做一个 <code>map</code> ，当然也可以对两个字符串先排序再双指针对比遍历.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSteps</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            m[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[c] != <span class="number">0</span>) &#123;</span><br><span class="line">                m[c]--;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>访问某下标的元素， <code>map</code> 的 <code>operator[]</code> 时间复杂度为 <code>O(logn)</code> 而数组是 <code>O(1)</code> ，因此自建一个数组会更好.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1379 Find a Corresponding Node of a Binary Tree in a Clone of That Tree</title>
    <url>/2024/04/03/LeetCode1379/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/">Find a Corresponding Node of a Binary Tree in a Clone of That Tree - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接 DFS 就行. 要是树中可能存在相同值节点，就同时 DFS 原树和克隆树.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getTargetCopy</span><span class="params">(TreeNode* original, TreeNode* cloned, TreeNode* target)</span> </span>&#123;</span><br><span class="line">        TreeNode* res;</span><br><span class="line">        function&lt;<span class="type">void</span>(TreeNode*)&gt; dfs = [&amp;](TreeNode* root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;val == target-&gt;val) &#123;</span><br><span class="line">                    res = root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">                <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(cloned);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(h)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>binary-tree</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1382 Balance a Binary Search Tree</title>
    <url>/2024/06/26/LeetCode1382/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/balance-a-binary-search-tree/">Balance a Binary Search Tree - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/balance-a-binary-search-tree/solutions/241897/jiang-er-cha-sou-suo-shu-bian-ping-heng-by-leetcod">将二叉搜索树变平衡 - 力扣官方题解</a></p>
<p><a href="https://leetcode.cn/problems/balance-a-binary-search-tree/solutions/150820/shou-si-avlshu-wo-bu-guan-wo-jiu-shi-yao-xuan-zhua">手撕AVL树，我不管，我就是要旋转 - 失火的夏天</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt; list;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">balanceBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="type">int</span> n = list.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        list.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        TreeNode* root = list[mid];</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(l, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>binary-tree</tag>
        <tag>tree</tag>
        <tag>binary-search-tree</tag>
        <tag>greedy</tag>
        <tag>divide-and-conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 141 Linked List Cycle</title>
    <url>/2024/03/06/LeetCode141/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/linked-list-cycle/">Linked List Cycle - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>可以用 hash table 记录每个节点的 parent 节点，也可以用快慢指针遍历判断俩指针会否重叠. 因为若链表中存在环，则快慢指针必会遇上.</p>
<h2 id="fast-slow-pointers-codes">Fast-slow pointers Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>two-pointers</tag>
        <tag>hash-table</tag>
        <tag>linked-list</tag>
        <tag>fast-slow-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1431 Kids With the Greatest Number of Candies</title>
    <url>/2024/01/16/LeetCode1431/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/description/">Kids With the Greatest Number of Candies - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>简单的模拟.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">kidsWithCandies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candies, <span class="type">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> candy : candies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candy &gt; max) &#123;</span><br><span class="line">                max = candy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> candy : candies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candy + extraCandies &gt;= max) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p><code>std::max_element</code></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/max_element">std::max_element - cppreference.com</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> max = std::<span class="built_in">max_element</span>(candies.<span class="built_in">begin</span>(), candies.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>array/string</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>LeetCode-75</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1438 Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</title>
    <url>/2024/06/23/LeetCode1438/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solutions/612688/jue-dui-chai-bu-chao-guo-xian-zhi-de-zui-5bki">绝对差不超过限制的最长连续子数组 - 力扣官方题解</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; dqMax, dqMin;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!dqMax.<span class="built_in">empty</span>() &amp;&amp; dqMax.<span class="built_in">back</span>() &lt; nums[right])&#123;</span><br><span class="line">                dqMax.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!dqMin.<span class="built_in">empty</span>() &amp;&amp; dqMin.<span class="built_in">back</span>() &gt; nums[right])&#123;</span><br><span class="line">                dqMin.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            dqMax.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">            dqMin.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">            <span class="keyword">while</span>(!dqMax.<span class="built_in">empty</span>() &amp;&amp; !dqMin.<span class="built_in">empty</span>() &amp;&amp; dqMax.<span class="built_in">front</span>() - dqMin.<span class="built_in">front</span>() &gt; limit)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == dqMin.<span class="built_in">front</span>())&#123;</span><br><span class="line">                    dqMin.<span class="built_in">pop_front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == dqMax.<span class="built_in">front</span>())&#123;</span><br><span class="line">                    dqMax.<span class="built_in">pop_front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>sliding-window</tag>
        <tag>queue</tag>
        <tag>ordered-set</tag>
        <tag>monotonic-queue</tag>
        <tag>heap/priority-queue</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1456 Maximum Number of Vowels in a Substring of Given Length</title>
    <url>/2024/01/26/LeetCode1456/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/">Maximum Number of Vowels in a Substring of Given Length - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>滑动窗口. 窗口大小为 k , 边界为 i , j , 遍历 s ，统计窗口中的元音字母个数，并记录最大值.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isVowel</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (c == &#x27;a&#x27; || c == &#x27;A&#x27;) &#123;</span></span><br><span class="line">        <span class="comment">//     return true;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if (c == &#x27;e&#x27; || c == &#x27;E&#x27;) &#123;</span></span><br><span class="line">        <span class="comment">//     return true;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if (c == &#x27;i&#x27; || c == &#x27;I&#x27;) &#123;</span></span><br><span class="line">        <span class="comment">//     return true;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if (c == &#x27;o&#x27; || c == &#x27;O&#x27;) &#123;</span></span><br><span class="line">        <span class="comment">//     return true;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if (c == &#x27;u&#x27; || c == &#x27;U&#x27;) &#123;</span></span><br><span class="line">        <span class="comment">//     return true;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// s consists of lowercase English letters</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxVowels</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isVowel</span>(s[m])) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = count;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isVowel</span>(s[i++])) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isVowel</span>(s[++j])) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; max) &#123;</span><br><span class="line">                max = count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: (1)</p>
<h2 id="notes">Notes</h2>
<h3 id="faster-approach">faster approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isVowel</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxVowels</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxVowel = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, amountVowel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; k; i++) &#123;</span><br><span class="line">            amountVowel += <span class="built_in">isVowel</span>(s[i]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxVowel = amountVowel;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">            amountVowel += <span class="built_in">isVowel</span>(s[i]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            amountVowel -= <span class="built_in">isVowel</span>(s[i-k]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            maxVowel = <span class="built_in">max</span>(maxVowel, amountVowel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxVowel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>sliding-window</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-75</tag>
        <tag>sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1457 Pseudo-Palindromic Paths in a Binary Tree</title>
    <url>/2024/01/24/LeetCode1457/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/description/">Pseudo-Palindromic Paths in a Binary Tree - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>树状结构一般就是遍历，而回文需要各个元素的出现次数最多有一个奇数，否则不能构成回文（例：<code>(2, 2, 2, 1, 1, 1)</code> 2 的出现次数为奇数， 1 的出现次数也为奇数），证明是显然的. 因此，需要在遍历树的过程中，记录各元素出现的次数，在到达叶节点时，判断该条路径中的元素能否构成回文.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, count);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            count[root-&gt;val]++;</span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">                <span class="type">int</span> numOfOdd = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> num : count) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">2</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        numOfOdd++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (numOfOdd &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left, count);</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right, count);</span><br><span class="line">            count[root-&gt;val]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="literal">true</span> : !(n&amp;(n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        value ^= <span class="number">1</span> &lt;&lt; root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == root-&gt;right)&#123;</span><br><span class="line">            result += <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">isPowerOfTwo</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left, value);</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        root-&gt;left = root-&gt;right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1463 Cherry Pickup II</title>
    <url>/2024/02/11/LeetCode1463/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/cherry-pickup-ii/description/">Cherry Pickup II - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>DP. 直接看 Notes 吧 :)</p>
<h2 id="notes">Notes</h2>
<h3 id="dynamic-programming-down-top-optimized-approach">Dynamic programming down-top optimized approach</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/cherry-pickup-ii/solutions/521172/zhai-ying-tao-ii-by-leetcode-solution-v2k5/">1463. 摘樱桃 II - 力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cherryPickup</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>)), <span class="built_in">g</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        f[<span class="number">0</span>][n - <span class="number">1</span>] = grid[<span class="number">0</span>][<span class="number">0</span>] + grid[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j1 = <span class="number">0</span>; j1 &lt; n; ++j1) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j2 = <span class="number">0</span>; j2 &lt; n; ++j2) &#123;</span><br><span class="line">                    <span class="type">int</span> best = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> dj1 = j1 - <span class="number">1</span>; dj1 &lt;= j1 + <span class="number">1</span>; ++dj1) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> dj2 = j2 - <span class="number">1</span>; dj2 &lt;= j2 + <span class="number">1</span>; ++dj2) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (dj1 &gt;= <span class="number">0</span> &amp;&amp; dj1 &lt; n &amp;&amp; dj2 &gt;= <span class="number">0</span> &amp;&amp; dj2 &lt; n &amp;&amp; f[dj1][dj2] != <span class="number">-1</span>) &#123;</span><br><span class="line">                                best = <span class="built_in">max</span>(best, f[dj1][dj2] + (j1 == j2 ? grid[i][j1] : grid[i][j1] + grid[i][j2]));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    g[j1][j2] = best;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(f, g);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j1 = <span class="number">0</span>; j1 &lt; n; ++j1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j2 = <span class="number">0</span>; j2 &lt; n; ++j2) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, f[j1][j2]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(m*n^2)</p>
<p>Space: O(n^2)</p>
<blockquote>
<p>空间优化后.</p>
</blockquote>
<h3 id="dynamic-programming-top-down-approach">Dynamic programming top-down approach</h3>
<blockquote>
<p><a href="https://leetcode.com/problems/cherry-pickup-ii/solutions/660562/c-java-python-top-down-dp-clean-code/">Cherry Pickup II - hiepit's solution</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">70</span>][<span class="number">70</span>][<span class="number">70</span>] = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cherryPickup</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(grid, m, n, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col1, <span class="type">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == m) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Reach to bottom row</span></span><br><span class="line">        <span class="keyword">if</span> (dp[row][col1][col2] != <span class="number">-1</span>) <span class="keyword">return</span> dp[row][col1][col2];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> ncol1 = col1 + i;</span><br><span class="line">                <span class="type">int</span> ncol2 = col2 + j;</span><br><span class="line">                <span class="keyword">if</span> (ncol1 &gt;= <span class="number">0</span> &amp;&amp; ncol1 &lt; n &amp;&amp; ncol2 &gt;= <span class="number">0</span> &amp;&amp; ncol2 &lt; n) &#123;</span><br><span class="line">                    res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(grid, m, n, row + <span class="number">1</span>, ncol1, ncol2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cherries = c1 == c2 ? grid[row][col1] : grid[row][col1] + grid[row][col2];</span><br><span class="line">        <span class="keyword">return</span> dp[row][col1][col2] = res + cherries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(m*n^2)</p>
<p>Space: O(m*n^2)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>dynamic-programming</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1481 Least Number of Unique Integers after K Removals</title>
    <url>/2024/02/16/LeetCode1481/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/description/">Least Number of Unique Integers after K Removals - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>用 hash map 存储各数字的频次，再将频次数组进行 sort ，遍历 sort 后的频次数组与 k 进行比对模拟：</p>
<p>若数字 <code>i</code> 的频次 &lt;= <code>k</code> ，则表明可以在 <code>k</code> 次之内清除数字 <code>i</code> ，即最小不同数的个数 -1</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLeastNumOfUniqueInts</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            ++m[num];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : m) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] &lt;= k) &#123;</span><br><span class="line">                --res;</span><br><span class="line">                k -= v[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(nlogn)</p>
<blockquote>
<p><code>sort()</code> 's complexity.</p>
</blockquote>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<p>hash map 可优化.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLeastNumOfUniqueInts</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">		<span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i<span class="number">-1</span>] == arr[i]) &#123;</span><br><span class="line">            	cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="keyword">else</span> &#123;</span><br><span class="line">            	v.<span class="built_in">push_back</span>(cnt);</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v.<span class="built_in">push_back</span>(cnt);</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; i &lt; v.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            k -= v[i];</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            	++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v.<span class="built_in">size</span>() - i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(nlogn)</p>
<h3 id="greedy-thought">Greedy thought</h3>
<p>要想使得不同整数的数目最少，我们应当优先删除出现次数少的那些整数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLeastNumOfUniqueInts</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; group;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: arr) &#123;</span><br><span class="line">            ++group[num];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">freq</span>(group.<span class="built_in">begin</span>(), group.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(freq.<span class="built_in">begin</span>(), freq.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; u, <span class="type">const</span> <span class="keyword">auto</span>&amp; v) &#123;<span class="keyword">return</span> u.second &lt; v.second;&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = freq.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [_, occ]: freq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= occ) &#123;</span><br><span class="line">                --ans;</span><br><span class="line">                k -= occ;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(nlogn)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>hash-table</tag>
        <tag>greedy</tag>
        <tag>sorting</tag>
        <tag>counting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1482 Minimum Number of Days to Make m Bouquets</title>
    <url>/2024/06/19/LeetCode1482/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/">Minimum Number of Days to Make m Bouquets - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/solutions/764671/zhi-zuo-m-shu-hua-suo-xu-de-zui-shao-tia-mxci">制作 m 束花所需的最少天数 - 力扣官方题解</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bloomDay, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; bloomDay.<span class="built_in">size</span>() / k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> low = INT_MAX, high = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length = bloomDay.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            low = <span class="built_in">min</span>(low, bloomDay[i]);</span><br><span class="line">            high = <span class="built_in">max</span>(high, bloomDay[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> days = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">canMake</span>(bloomDay, days, m, k)) &#123;</span><br><span class="line">                high = days;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = days + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canMake</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bloomDay, <span class="type">int</span> days, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> bouquets = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> flowers = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length = bloomDay.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length &amp;&amp; bouquets &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bloomDay[i] &lt;= days) &#123;</span><br><span class="line">                flowers++;</span><br><span class="line">                <span class="keyword">if</span> (flowers == k) &#123;</span><br><span class="line">                    bouquets++;</span><br><span class="line">                    flowers = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flowers = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bouquets &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlog(high - low))</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1483 Kth Ancestor of a Tree Node</title>
    <url>/2024/04/06/LeetCode1483/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/kth-ancestor-of-a-tree-node/">Kth Ancestor of a Tree Node - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/solutions/287974/li-kou-zai-zhu-jian-ba-acm-mo-ban-ti-ban-shang-lai">力扣在逐渐把 ACM 模板题搬上来，这个问题是 Binary Lifting - liuyubobobo</a></p>
<p><a href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/solutions/2305895/mo-ban-jiang-jie-shu-shang-bei-zeng-suan-v3rw">【模板讲解】树上倍增算法（以及最近公共祖先） - 灵茶山艾府</a></p>
</blockquote>
<p>Binary lifting, 倍增算法. 好难:(</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeAncestor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TreeAncestor</span>(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; parent) : <span class="built_in">dp</span>(n) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            dp[i].<span class="built_in">push_back</span>(parent[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; ; j ++)&#123;</span><br><span class="line">            <span class="type">bool</span> allneg = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">                <span class="type">int</span> t = dp[i][j - <span class="number">1</span>] != <span class="number">-1</span> ? dp[dp[i][j - <span class="number">1</span>]][j - <span class="number">1</span>] : <span class="number">-1</span>;</span><br><span class="line">                dp[i].<span class="built_in">push_back</span>(t);</span><br><span class="line">                <span class="keyword">if</span>(t != <span class="number">-1</span>) allneg = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(allneg) <span class="keyword">break</span>; <span class="comment">// 所有的节点的 2^j 的祖先都是 -1 了，就不用再计算了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthAncestor</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || node== <span class="number">-1</span>) <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">ffs</span>(k) - <span class="number">1</span>; <span class="comment">// C++ 语言中 ffs(k) 求解出 k 的最右侧第一个 1 的位置（1-based）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pos &lt; dp[node].<span class="built_in">size</span>() ? <span class="built_in">getKthAncestor</span>(dp[node][pos], k - (<span class="number">1</span> &lt;&lt; pos)) : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(nlogn)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>tree</tag>
        <tag>dynamic-programming</tag>
        <tag>binary-lifiting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1493 Longest Subarray of 1&#39;s After Deleting One Element</title>
    <url>/2024/01/29/LeetCode1493/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/description/">Longest Subarray of 1's After Deleting One Element - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>Sliding window. 相似题：<a href="https://xrose7.github.io/2024/01/28/LeetCode1004/">LeetCode 1456 Max Consecutive Ones III | XRose's blog (xrose7.github.io)</a></p>
<p>维护一个最多含一个 0 的滑动窗口，遍历完 nums 返回窗口大小减一即可.</p>
<h2 id="codes">Codes</h2>
<p>移动右边界 j ，根据窗口内 0 的数量 count 判断是否移动左边界 i .</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// number of zero</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span> &amp;&amp; nums[i++] == <span class="number">0</span>) &#123; <span class="comment">// only if (k &lt; count) holds, will (i++) be executed</span></span><br><span class="line">                <span class="comment">// keep the maximum number of window size</span></span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j - i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>sliding-window</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-75</tag>
        <tag>sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 150 Evaluate Reverse Polish Notation</title>
    <url>/2024/01/30/LeetCode150/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/">Evaluate Reverse Polish Notation - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>栈的应用——逆波兰式（后缀）表达式求值. 遍历 tokens ，遇到数字压入 stack 中，遇到运算符则弹出两个数字进行运算，将运算结果压回 stack . 遍历完成后，栈顶元素即为表达式的值.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (string str : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="string">&quot;+&quot;</span> || str == <span class="string">&quot;-&quot;</span> || str == <span class="string">&quot;*&quot;</span> || str == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                b = s1.<span class="built_in">top</span>();</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">                a = s1.<span class="built_in">top</span>();</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (str == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                    s1.<span class="built_in">push</span>(a + b);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (str == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                    s1.<span class="built_in">push</span>(a - b);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (str == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                    s1.<span class="built_in">push</span>(a * b);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (str == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                    s1.<span class="built_in">push</span>(a / b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s1.<span class="built_in">push</span>(<span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="convert-string-to-int">convert <code>string</code> to <code>int</code></h3>
<h4 id="atoi"><code>atoi</code></h4>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/atoi">std::atoi, std::atol, std::atoll - cppreference.com</a></p>
<h4 id="stringstream"><code>stringstream</code></h4>
<p><a href="https://en.cppreference.com/w/cpp/io/basic_stringstream">std::basic_stringstream - cppreference.com</a></p>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string s1 = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;-10&quot;</span>;</span><br><span class="line">string s3 = <span class="string">&quot;10a&quot;</span>;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; s1;</span><br><span class="line">ss &gt;&gt; num;</span><br></pre></td></tr></table></figure>
<h4 id="stoi-c11"><code>stoi</code> (C++11)</h4>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string/stol">std::stoi, std::stol, std::stoll - cppreference.com</a></p>
<h3 id="convert-int-to-string">convert <code>int</code> to <code>string</code></h3>
<h4 id="stringstream-1"><code>stringstream</code></h4>
<p><a href="https://en.cppreference.com/w/cpp/io/basic_stringstream">std::basic_stringstream - cppreference.com</a></p>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">string str;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; num;</span><br><span class="line">str = ss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>
<h4 id="to_string-c11"><code>to_string</code> (C++11)</h4>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string/to_string">std::to_string - cppreference.com</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 151 Reverse Words in a String</title>
    <url>/2024/01/17/LeetCode151/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/reverse-words-in-a-string/description/">Reverse Words in a String - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>按字符遍历字符串，未遇到空格则接到 word 后，若遇到空格，则将 word push_back 到 vector 中，更新 word 为空. 注意处理最后一个 word . 接着 reverse vector 输出即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; words;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="type">int</span> wordLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (wordLen != <span class="number">0</span>) &#123;</span><br><span class="line">                    words.<span class="built_in">push_back</span>(word);</span><br><span class="line">                    word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    wordLen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                word.<span class="built_in">push_back</span>(c);</span><br><span class="line">                wordLen++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wordLen != <span class="number">0</span>) &#123; <span class="comment">// handle the last one word if no trailing space</span></span><br><span class="line">            words.<span class="built_in">push_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (string word : words) &#123;</span><br><span class="line">            s.<span class="built_in">append</span>(word);</span><br><span class="line">            s.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>array/string</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>LeetCode-75</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1544 Make The String Great</title>
    <url>/2024/04/05/LeetCode1544/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/make-the-string-great/">Make The String Great - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>栈的应用，FILO . 直接借助栈模拟即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">makeGood</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="string">&quot;&quot;</span> || <span class="built_in">abs</span>(s[i] - *res.<span class="built_in">rbegin</span>()) != <span class="number">32</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<blockquote>
<p>返回值不计入空间复杂度.</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>stack</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1552 Magnetic Force Between Two Balls</title>
    <url>/2024/06/20/LeetCode1552/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/magnetic-force-between-two-balls/">Magnetic Force Between Two Balls - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/magnetic-force-between-two-balls/solutions/403701/liang-qiu-zhi-jian-de-ci-li-by-leetcode-solution">两球之间的磁力 - 力扣官方题解</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, vector&lt;<span class="type">int</span>&gt;&amp; position, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pre = position[<span class="number">0</span>], cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; position.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (position[i] - pre &gt;= x) &#123;</span><br><span class="line">                pre = position[i];</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; position, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(position.<span class="built_in">begin</span>(), position.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = position.<span class="built_in">back</span>() - position[<span class="number">0</span>], ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid, position, m)) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlog(nS))</p>
<p>Space: O(logn)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>sorting</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1600 Throne Inheritance</title>
    <url>/2024/04/07/LeetCode1600/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/throne-inheritance/">Throne Inheritance - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>树的前序遍历.</p>
<h2 id="notes">Notes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThroneInheritance</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string king;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; children;</span><br><span class="line">    unordered_set&lt;string&gt; dead;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThroneInheritance</span>(string kingName) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;king = kingName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">birth</span><span class="params">(string parentName, string childName)</span> </span>&#123;</span><br><span class="line">        children[parentName].<span class="built_in">push_back</span>(childName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">death</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        dead.<span class="built_in">insert</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getInheritanceOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(king, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string king, vector&lt;string&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!dead.<span class="built_in">contains</span>(king)) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(king);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; child : children[king]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(child, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ThroneInheritance object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ThroneInheritance* obj = new ThroneInheritance(kingName);</span></span><br><span class="line"><span class="comment"> * obj-&gt;birth(parentName,childName);</span></span><br><span class="line"><span class="comment"> * obj-&gt;death(name);</span></span><br><span class="line"><span class="comment"> * vector&lt;string&gt; param_3 = obj-&gt;getInheritanceOrder();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Time:</p>
<ul>
<li><code>ThroneInheritance(kingName)</code> : O(1)</li>
<li><code>birth(parentName, childName)</code> : O(1)</li>
<li><code>death(name)</code> : O(1)</li>
<li><code>getInheritanceOrder()</code> : O(n)</li>
</ul>
<p>Space: O(n)</p>
<h2 id="notes-1">Notes</h2>
<h3 id="better-approach---singly-linked-list-approach">Better approach - Singly linked list approach</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/throne-inheritance/solutions/836076/gong-shui-san-xie-shi-yong-dan-xiang-lia-7t65">【宫水三叶】使用「单向链表 &amp; 标记删除」实现 - 宫水三叶</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>tree</tag>
        <tag>hash-table</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1609 Even Odd Tree</title>
    <url>/2024/02/29/LeetCode1609/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/even-odd-tree/description/">Even Odd Tree - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>层次遍历（BFS）模拟.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEvenOddTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            TreeNode* p = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> pre = p-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> ((level &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (p-&gt;val &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((level &amp; <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; (p-&gt;val &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                p = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> ((level &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; ((p-&gt;val &amp; <span class="number">1</span>) == <span class="number">0</span> || p-&gt;val &lt;= pre)) &#123;</span><br><span class="line">                    <span class="comment">// even level</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((level &amp; <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; ((p-&gt;val &amp; <span class="number">1</span>) &gt; <span class="number">0</span> || p-&gt;val &gt;= pre)) &#123;</span><br><span class="line">                    <span class="comment">// odd level</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = p-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(width of level)</p>
<h2 id="notes">Notes</h2>
<h3 id="another-approach">Another approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEvenOddTree</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cin.<span class="built_in">tie</span>(<span class="number">0</span>) -&gt; <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* u = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (depth % <span class="number">2</span> == u-&gt;val % <span class="number">2</span>) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (depth % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; u-&gt;val &gt;= pre)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (depth % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; u-&gt;val &lt;= pre)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(u-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (u-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(u-&gt;right);</span><br><span class="line">                pre = u-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(width of level)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>breadth-first-search</tag>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1614 Maximum Nesting Depth of the Parentheses</title>
    <url>/2024/04/04/LeetCode1614/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/">Maximum Nesting Depth of the Parentheses - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>栈的应用之括号匹配:) 遍历字符串，遇到左括号就入栈，遇到右括号则弹出栈顶元素. 过程中，栈长的最大值即为所求深度.</p>
<p>这里我用了一个变量 <code>count</code> 模拟维护栈里的左括号数，省去了一个完整栈的占用空间.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                res = <span class="built_in">max</span>(res, count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1642 Furthest Building You Can Reach</title>
    <url>/2024/02/17/LeetCode1642/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/furthest-building-you-can-reach/description/">Furthest Building You Can Reach - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>没想到用堆x）直接看题解吧</p>
<p><a href="https://leetcode.cn/problems/furthest-building-you-can-reach/solutions/468787/ke-yi-dao-da-de-zui-yuan-jian-zhu-by-zerotrac2/">可以到达的最远建筑 - zerotrac</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">furthestBuilding</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights, <span class="type">int</span> bricks, <span class="type">int</span> ladders)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// the number of used bricks</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> delta_h = heights[i] - heights[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (delta_h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(delta_h);</span><br><span class="line">                <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; ladders) &#123;</span><br><span class="line">                    sum += q.<span class="built_in">top</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; bricks) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(ladders)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>greedy</tag>
        <tag>heap/priority-queue</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1657 Determine if Two Strings Are Close</title>
    <url>/2024/01/14/LeetCode1657/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/determine-if-two-strings-are-close/description/">Determine if Two Strings Are Close - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>记录两个字符串中出现的字符及各字符的出现次数，对比即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">closeStrings</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ch1[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// mark the number of character in word1</span></span><br><span class="line">        <span class="type">int</span> ch2[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// mark the number of character in word2</span></span><br><span class="line">        <span class="type">int</span> tag1[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// mark the character appeared in word1</span></span><br><span class="line">        <span class="type">int</span> tag2[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// mark the character appeared in word2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word1) &#123;</span><br><span class="line">            ch1[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            tag1[c - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word2) &#123;</span><br><span class="line">            ch2[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            tag2[c - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ch1, ch1 + <span class="number">26</span>);</span><br><span class="line">        <span class="built_in">sort</span>(ch2, ch2 + <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch1[i] != ch2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag1[i] != tag2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1700 Number of Students Unable to Eat Lunch</title>
    <url>/2024/04/08/LeetCode1700/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/">Number of Students Unable to Eat Lunch - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接模拟即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countStudents</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; students, vector&lt;<span class="type">int</span>&gt;&amp; sandwiches)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">count</span>(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), sandwiches[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (students[<span class="number">0</span>] == sandwiches[<span class="number">0</span>]) &#123;</span><br><span class="line">                students.<span class="built_in">erase</span>(students.<span class="built_in">begin</span>());</span><br><span class="line">                sandwiches.<span class="built_in">erase</span>(sandwiches.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                students.<span class="built_in">push_back</span>(students[<span class="number">0</span>]);</span><br><span class="line">                students.<span class="built_in">erase</span>(students.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> students.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="another-approach">Another approach</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/solutions/1900373/wu-fa-chi-wu-can-de-xue-sheng-shu-liang-fv3f5">力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countStudents</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; students, vector&lt;<span class="type">int</span>&gt;&amp; sandwiches)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s1 = <span class="built_in">accumulate</span>(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> s0 = students.<span class="built_in">size</span>() - s1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sandwiches.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sandwiches[i] == <span class="number">0</span> &amp;&amp; s0 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                s0--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sandwiches[i] == <span class="number">1</span> &amp;&amp; s1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                s1--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s0 + s1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>stack</tag>
        <tag>queue</tag>
        <tag>simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1669 Merge In Between Linked Lists</title>
    <url>/2024/03/20/LeetCode1669/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/merge-in-between-linked-lists/">Merge In Between Linked Lists - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>双指针直接遍历.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeInBetween</span><span class="params">(ListNode* list1, <span class="type">int</span> a, <span class="type">int</span> b, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = list1, q = list1;</span><br><span class="line">        <span class="keyword">while</span> (--a) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (b--) &#123;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = list2;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        q-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 169 Majority Element</title>
    <url>/2024/01/12/LeetCode169/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/majority-element/description/">Majority Element - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一开始就想着暴力求解，拿个 map 存各元素的出现次数。后来想一想，先排序再取中间元素就是主元素，可以用反证法证明。</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> nums[n/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(logn)</p>
<blockquote>
<p>若使用语言自带的排序算法，需要使用 <span class="math inline">\(O(\log{n})\)</span> 的栈空间. 若自己编写<strong>堆排序</strong>，则只需要使用 <span class="math inline">\(O(1)\)</span> 的额外空间.</p>
</blockquote>
<h2 id="notes">Notes</h2>
<h3 id="hash-map-approach">Hash map approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">        <span class="type">int</span> majority = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            ++counts[num];</span><br><span class="line">            <span class="keyword">if</span> (counts[num] &gt; cnt) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                cnt = counts[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h3 id="b-m-voting-algorithm">B-M Voting Algorithm</h3>
<p>B-M Voting Algorithm is based on the fact that if there is a majority element in an array, it will always remain in the lead, even after encountering other elements.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> candidate = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (num == candidate) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<blockquote>
<p><strong>关于 B-M Voting Algorithm</strong></p>
<p>若记 <code>nums</code> 的众数为 <span class="math inline">\(x\)</span> ，数组长度为 <span class="math inline">\(n\)</span> .</p>
<p><strong>推论一</strong>： 若记<strong>众数</strong>的票数为 +1 ，<strong>非众数</strong>的票数为 -1 ，则一定有所有数字的<strong>票数和</strong> &gt; 0 .</p>
<p><strong>推论二</strong>： 若数组的前 a 个数字的<strong>票数和</strong> = 0，则数组剩余 (n-a) 个数字的<strong>票数和</strong>一定仍 &gt; 0，即后 (n-a) 个数字的<strong>众数</strong>仍为 <span class="math inline">\(x\)</span> .</p>
<p>作者：Krahets 链接：https://leetcode.cn/problems/majority-element/solutions/2362000/169-duo-shu-yuan-su-mo-er-tou-piao-qing-ledrh/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="divide-and-conquer-approach">Divide and conquer approach</h3>
<blockquote>
<p>如果数 <span class="math inline">\(a\)</span> 是数组 <code>nums</code> 的众数，如果我们将 <code>nums</code> 分成两部分，那么 <span class="math inline">\(a\)</span> 必定是至少一部分的众数。</p>
<p>我们可以使用反证法来证明这个结论。假设 <span class="math inline">\(a\)</span> 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 <span class="math inline">\(l / 2 + r / 2\)</span> 次，其中 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span> 分别是左半部分和右半部分的长度。由于 <span class="math inline">\(l / 2 + r / 2 &lt;= (l + r) / 2\)</span>，说明 <span class="math inline">\(a\)</span> 也不是数组 <code>nums</code> 的众数，因此出现了矛盾。所以这个结论是正确的。</p>
<p>这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。</p>
<p>算法：</p>
<p>我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。</p>
<p>长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</p>
<p>作者：力扣官方题解 链接：https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_in_range</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lo; i &lt;= hi; ++i)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">                ++count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majority_element_rec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi)</span><br><span class="line">            <span class="keyword">return</span> nums[lo];</span><br><span class="line">        <span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> left_majority = <span class="built_in">majority_element_rec</span>(nums, lo, mid);</span><br><span class="line">        <span class="type">int</span> right_majority = <span class="built_in">majority_element_rec</span>(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">count_in_range</span>(nums, left_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> left_majority;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">count_in_range</span>(nums, right_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> right_majority;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">majority_element_rec</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(logn)</p>
<blockquote>
<p>函数 <code>majority_element_rec()</code> 会求解 2 个长度为 <span class="math inline">\(\dfrac{n}{2}\)</span> 的子问题，并做两遍长度为 n 的线性扫描。因此，分治算法的时间复杂度可以表示为：</p>
<p><span class="math display">\[
T(n) = 2T(\frac{n}{2}) + 2n
\]</span> 根据<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AE%9A%E7%90%86/3463232?fr=aladdin">主定理</a>，本题满足第二种情况，所以时间复杂度可以表示为： <span class="math display">\[
\begin{aligned} T(n) &amp;= \Theta(n^{log_{b}a}\log n) \\ &amp;= \Theta(n^{log_{2}2}\log n) \\ &amp;= \Theta(n \log n) \\ \end{aligned}
\]</span> 尽管分治算法没有直接分配额外的数组空间，但在递归的过程中使用了额外的栈空间。算法每次将数组从中间分成两部分，所以数组长度变为 1 之前需要进行 <span class="math inline">\(O(\log n)\)</span> 次递归，即空间复杂度为 <span class="math inline">\(O(\log n)\)</span> .</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>top-interview-150</category>
        <category>array/string</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>hash-table</tag>
        <tag>top-interview-150</tag>
        <tag>divide-and-conquer</tag>
        <tag>sorting</tag>
        <tag>counting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1679 Max Number of K-Sum Pairs</title>
    <url>/2024/01/24/LeetCode1679/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/max-number-of-k-sum-pairs/description/">Max Number of K-Sum Pairs - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>遍历 nums ，将小于 k 的值计数，根据 i 的数量和 k - i 的数量计算能配对的数量. 结果 MLE 了.</p>
<h2 id="my-mle-codes">My MLE Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; k) &#123;</span><br><span class="line">                count[num]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = k &gt;&gt; <span class="number">1</span>; <span class="comment">// (k &gt;&gt; 1) == k / 2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; mid; i++) &#123;</span><br><span class="line">            res += <span class="built_in">min</span>(count[i], count[k - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) &#123; <span class="comment">// k is an odd number</span></span><br><span class="line">            res += <span class="built_in">min</span>(count[mid], count[mid + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="built_in">floor</span>(count[mid] / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(k)</p>
<h2 id="notes">Notes</h2>
<h3 id="approach">Approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[l] + nums[r]) &gt; k) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nums[l] + nums[r]) &lt; k)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>two-pointers</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-75</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1702 Maximum Binary String After Change</title>
    <url>/2024/04/10/LeetCode1702/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-binary-string-after-change/">Maximum Binary String After Change - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/maximum-binary-string-after-change/solutions/2732155/tan-xin-jian-ji-xie-fa-pythonjavacgojsru-szie">贪心，简洁写法 - 灵茶山艾府</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">maximumBinaryString</span><span class="params">(string binary)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = binary.<span class="built_in">find</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> binary;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt1 = <span class="built_in">count</span>(binary.<span class="built_in">begin</span>() + i, binary.<span class="built_in">end</span>(), <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(binary.<span class="built_in">size</span>() - <span class="number">1</span> - cnt1, <span class="string">&#x27;1&#x27;</span>) + <span class="string">&#x27;0&#x27;</span> + <span class="built_in">string</span>(cnt1, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1704 Determine if String Halves Are Alike</title>
    <url>/2024/01/12/LeetCode1704/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/determine-if-string-halves-are-alike/description/">Determine if String Halves Are Alike - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一道简单的字符串遍历</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isVowel</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;u&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">halvesAreAlike</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = s.<span class="built_in">length</span>() / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isVowel</span>(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; mid) &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    --res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="another-approach">Another approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">halvesAreAlike</span><span class="params">(std::string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; vowels = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> vowelsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> midIndex = s.<span class="built_in">length</span>() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; midIndex; i++) &#123;</span><br><span class="line">            <span class="type">char</span> charA = s[i];</span><br><span class="line">            <span class="type">char</span> charB = s[midIndex + i];</span><br><span class="line">            <span class="keyword">if</span> (vowels.<span class="built_in">count</span>(charA)) vowelsCount++;</span><br><span class="line">            <span class="keyword">if</span> (vowels.<span class="built_in">count</span>(charB)) vowelsCount--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vowelsCount == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1732 Find the Highest Altitude</title>
    <url>/2024/01/30/LeetCode1732/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-the-highest-altitude/description/">Find the Highest Altitude - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>Prefix sum. 维护一个 max 变量，每得到一个前缀和便更新 max .</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestAltitude</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gain)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; gain.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            sum = sum + gain[i];</span><br><span class="line">            res = <span class="built_in">max</span>(sum, res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>prefix-sum</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-75</tag>
        <tag>prefix-sum</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1748 Merge Strings Alternately</title>
    <url>/2024/01/15/LeetCode1748/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/merge-strings-alternately/description/">Merge Strings Alternately - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接模拟.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">mergeAlternately</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        string word3 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len1 = word1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len2 = word2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len1 &gt;= len2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * len2; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    word3.<span class="built_in">push_back</span>(word1[i / <span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    word3.<span class="built_in">push_back</span>(word2[i / <span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = len2; i &lt; len1; i++) &#123;</span><br><span class="line">                word3.<span class="built_in">push_back</span>(word1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * len1; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    word3.<span class="built_in">push_back</span>(word1[i / <span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    word3.<span class="built_in">push_back</span>(word2[i / <span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = len1; i &lt; len2; i++) &#123;</span><br><span class="line">                word3.<span class="built_in">push_back</span>(word2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> word3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">mergeAlternately</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">      string a;</span><br><span class="line">      <span class="type">int</span> maxlen = (word1.<span class="built_in">size</span>() &gt; word2.<span class="built_in">size</span>()? word1.<span class="built_in">size</span>() : word2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;  i &lt; maxlen; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt; word1.<span class="built_in">size</span>())&#123;</span><br><span class="line">          a += word1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt; word2.<span class="built_in">size</span>())&#123;</span><br><span class="line">          a += word2[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>array/string</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>LeetCode-75</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1750 Minimum Length of String After Deleting Similar Ends</title>
    <url>/2024/03/05/LeetCode1750/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/">Minimum Length of String After Deleting Similar Ends - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>有点贪心策略的味道？反正是尽可能得往长了取前缀和后缀，再更新 <code>left</code> 和 <code>right</code> 边界指针，最后由这俩边界指针计算长度.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumLength</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[l];</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; s[l] == c) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; s[r] == c) &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1766 Tree of Coprimes</title>
    <url>/2024/04/11/LeetCode1766/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/tree-of-coprimes/">Tree of Coprimes - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/tree-of-coprimes/solutions/2729332/hu-zhi-shu-by-leetcode-solution-ef42">力扣官方题解</a></p>
</blockquote>
<p>DFS.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; gcds; </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dep;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> x, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        dep[x] = depth;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : gcds[nums[x]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[val].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="type">int</span> las = tmp[val].<span class="built_in">back</span>();</span><br><span class="line">            <span class="keyword">if</span> (ans[x] == <span class="number">-1</span> || dep[las] &gt; dep[ans[x]]) &#123;</span><br><span class="line">                ans[x] = las;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp[nums[x]].<span class="built_in">push_back</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : g[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[val] == <span class="number">-1</span>) &#123; <span class="comment">// 被访问过的点dep不为-1</span></span><br><span class="line">                <span class="built_in">dfs</span>(nums, val, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp[nums[x]].<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getCoprimes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        gcds.<span class="built_in">resize</span>(<span class="number">51</span>);</span><br><span class="line">        tmp.<span class="built_in">resize</span>(<span class="number">51</span>);</span><br><span class="line">        ans.<span class="built_in">resize</span>(n, <span class="number">-1</span>);</span><br><span class="line">        dep.<span class="built_in">resize</span>(n, <span class="number">-1</span>);</span><br><span class="line">        g.<span class="built_in">resize</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">gcd</span>(i, j) == <span class="number">1</span>) &#123;</span><br><span class="line">                    gcds[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;val : edges) &#123;</span><br><span class="line">            g[val[<span class="number">0</span>]].<span class="built_in">push_back</span>(val[<span class="number">1</span>]);</span><br><span class="line">            g[val[<span class="number">1</span>]].<span class="built_in">push_back</span>(val[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(Cn)</p>
<p>Space: O(C^2logC + Cn)</p>
<h2 id="better-approach">Better approach</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/tree-of-coprimes/solutions/2733992/dfs-zhong-ji-lu-jie-dian-zhi-de-shen-du-4v5d2">DFS 中记录节点值的深度和编号，回溯写法 - 灵茶山艾府</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MX = <span class="number">51</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; coprime[MX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> init = [] &#123;</span><br><span class="line">    <span class="comment">// 预处理：coprime[i] 保存 [1, MX) 中与 i 互质的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MX; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; MX; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">gcd</span>(i, j) == <span class="number">1</span>) &#123;</span><br><span class="line">                coprime[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; val_depth_id[MX]; <span class="comment">// 包含深度和节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> depth, vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> val = nums[x]; <span class="comment">// x 的节点值</span></span><br><span class="line">        <span class="comment">// 计算与 val 互质的数中，深度最大的节点编号</span></span><br><span class="line">        <span class="type">int</span> max_depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : coprime[val]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [depth, id] = val_depth_id[j];</span><br><span class="line">            <span class="keyword">if</span> (depth &gt; max_depth) &#123;</span><br><span class="line">                max_depth = depth;</span><br><span class="line">                ans[x] = id;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> tmp = val_depth_id[val]; <span class="comment">// 用于恢复现场</span></span><br><span class="line">        val_depth_id[val] = &#123;depth, x&#125;; <span class="comment">// 保存 val 对应的节点深度和节点编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y : g[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(y, x, depth + <span class="number">1</span>, nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        val_depth_id[val] = tmp; <span class="comment">// 恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getCoprimes</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        g.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            <span class="type">int</span> x = e[<span class="number">0</span>], y = e[<span class="number">1</span>];</span><br><span class="line">            g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">            g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans.<span class="built_in">resize</span>(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(Cn)</p>
<p>Space: O(c + n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>tree</tag>
        <tag>math</tag>
        <tag>number-theory</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1791 Find Center of Star Graph</title>
    <url>/2024/06/27/LeetCode1791/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-center-of-star-graph/">Find Center of Star Graph - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/find-center-of-star-graph/solutions/1264727/zhao-chu-xing-xing-tu-de-zhong-xin-jie-d-1xzm">找出星型图的中心节点 - 力扣官方题解</a></p>
<p><a href="https://leetcode.cn/problems/find-center-of-star-graph/solutions/1273588/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-qoix">简单模拟题（进阶到欧拉回路问题） - 宫水三叶</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCenter</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[<span class="number">0</span>][<span class="number">0</span>] == edges[<span class="number">1</span>][<span class="number">0</span>] || edges[<span class="number">0</span>][<span class="number">0</span>] == edges[<span class="number">1</span>][<span class="number">1</span>] ? edges[<span class="number">0</span>][<span class="number">0</span>] : edges[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(1)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1793 Maximum Score of a Good Subarray</title>
    <url>/2024/03/19/LeetCode1793/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-score-of-a-good-subarray/">Maximum Score of a Good Subarray - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/maximum-score-of-a-good-subarray/solutions/2695415/liang-chong-fang-fa-dan-diao-zhan-shuang-24zl">两种方法：单调栈/双指针 - 灵茶山艾府</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = nums[k];</span><br><span class="line">        <span class="type">int</span> minH = nums[k];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i = k;</span><br><span class="line">        <span class="type">int</span> j = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; n - <span class="number">1</span>; ++t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == n - <span class="number">1</span> || i &amp;&amp; nums[i - <span class="number">1</span>] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                minH = <span class="built_in">min</span>(minH, nums[--i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                minH = <span class="built_in">min</span>(minH, nums[++j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, minH * (j - i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>two-pointers</tag>
        <tag>stack</tag>
        <tag>binary-search</tag>
        <tag>monotonic-stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1883 Minimum Skips to Arrive at Meeting On Time</title>
    <url>/2024/04/20/LeetCode1883/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-skips-to-arrive-at-meeting-on-time/">Minimum Skips to Arrive at Meeting On Time - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/solutions/2746611/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-gxd2">教你一步步思考动态规划：从记忆化搜索到递推 - 灵茶山艾府</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSkips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dist, <span class="type">int</span> speed, <span class="type">int</span> hoursBefore)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">accumulate</span>(dist.<span class="built_in">begin</span>(), dist.<span class="built_in">end</span>(), <span class="number">0</span>) &gt; (<span class="type">long</span> <span class="type">long</span>) speed * hoursBefore) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = dist.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = f[j + <span class="number">1</span>];</span><br><span class="line">                f[j + <span class="number">1</span>] = (f[j] + dist[j] + speed - <span class="number">1</span>) / speed * speed;</span><br><span class="line">                <span class="keyword">if</span> (i) &#123;</span><br><span class="line">                    f[j + <span class="number">1</span>] = <span class="built_in">min</span>(f[j + <span class="number">1</span>], pre + dist[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f[n - <span class="number">1</span>] + dist[n - <span class="number">1</span>] &lt;= (<span class="type">long</span> <span class="type">long</span>) speed * hoursBefore) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^2)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 189 Rotate Array</title>
    <url>/2024/01/12/LeetCode189/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/rotate-array/description/">Rotate Array - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>之前做过类似的题目，反转反转再反转即可，证明是显然的. 要注意 <code>k</code> 可能大于 <code>nums</code> 的长度，需要先求模.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = k % nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>() - m);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">end</span>() - m, nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="notes">Notes</h2>
<h3 id="reverse"><code>reverse</code></h3>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/reverse">std::reverse - cppreference.com</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>top-interview-150</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>top-interview-150</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 19 Remove Nth Node From End of List</title>
    <url>/2024/03/03/LeetCode19/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description">Remove Nth Node From End of List - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>先遍历一遍算出链表长度，再根据 <code>Nth</code> 判断出需要删除节点离 <code>head</code> 的距离，维护 <code>pre</code> 和 <code>p</code> 指针遍历到需要删除的节点，进行删除即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>; <span class="comment">// size of the singly-linked list</span></span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            ++m;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == n) &#123;</span><br><span class="line">            p = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">            ListNode* pre = head;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (++count &lt; m - n + <span class="number">1</span>) &#123;</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>其实也可以使用<strong>快慢指针</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fast-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ListNode* slow = head;</span><br><span class="line">            ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">while</span> (fast-&gt;next) &#123;</span><br><span class="line">                prev = slow;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev-&gt;next = slow-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>two-pointers</tag>
        <tag>linked-list</tag>
        <tag>fast-slow-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1969 Minimum Non-Zero Product of the Array Elements</title>
    <url>/2024/03/20/LeetCode1969/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-non-zero-product-of-the-array-elements/">Minimum Non-Zero Product of the Array Elements - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/solutions/936621/tan-xin-ji-qi-shu-xue-zheng-ming-by-endl-uumv">贪心+构造 - 灵茶山艾府</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mod = <span class="number">1&#x27;000&#x27;000&#x27;007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        x %= mod;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p--) &#123;</span><br><span class="line">            res = res * x % mod;</span><br><span class="line">            x = x * x % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNonZeroProduct</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> k = (<span class="number">1LL</span> &lt;&lt; p) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> k % mod * <span class="built_in">pow</span>(k - <span class="number">1</span>, p - <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(p)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>math</tag>
        <tag>greedy</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1976 Number of Ways to Arrive at Destination</title>
    <url>/2024/03/05/LeetCode1976/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/">Number of Ways to Arrive at Destination - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>LeetCode 上的最短路一般就是 Dijkstra 吧？） Floyd 很少见x</p>
<blockquote>
<h2 id="最短路动态规划">最短路+动态规划</h2>
<p>这个题在 LeetCode 上刚出来的时候应该还是挺难的，现在就差不多是个套路题了。记得还有个统计最长递增子序列数目的题目，和这个题也是异曲同工。</p>
<p>首先我们需要求的是最短路，注意到这个图的节点数 <span class="math inline">\(n \leq 200\)</span> ，但是边数却能到 <span class="math inline">\(O(n^2)\)</span> 级别，因此是一个稠密图，可以用朴素版的 Dijkstra 算法来求解最短路（没有太理解官解为什么非要用堆优化， m 是 <span class="math inline">\(n^2\)</span> 规模，堆优化下来还多个 log ，其实并没有优化）。在求最短路的时候一边跑动态规划来计数，状态定义和转移如下：</p>
<h3 id="状态定义">状态定义</h3>
<p><code>dp[i]</code> 表示从 0 到 <code>i</code> 最短路的数目，在这个定义下，最终答案就应该是 <code>dp[n−1]</code> 。</p>
<h3 id="状态转移">状态转移</h3>
<p>在 Dijkstra 更新最短路的时候考虑转移，如果当前节点为 t ，下一个节点为 j ：</p>
<ol type="1">
<li>当 <span class="math inline">\(dist[j] \gt dist[t] + w_{tj}\)</span> 时，最短路会被更新掉，此时从起点到 j 的最短路数目就是从起点到 t 的数目，状态转移方程为 <span class="math inline">\(dp[j]=dp[t]\)</span> .</li>
<li>当 <span class="math inline">\(dist[j]=dist[t] + w_{tj}\)</span> 时，不更新最短路，但是又多了一个从 j 到 t 的最短路，因此从起点到 j 的最短路要在当前 <span class="math inline">\(dp[j]\)</span> 的基础上加上从起点到 t 的最短路方案数<span class="math inline">\(dp[t]\)</span> ，状态转移方程为$ dp[j]+=dp[t]$ .</li>
<li>当 <span class="math inline">\(dist[j] \lt dist[t] + w_{tj}\)</span> 时，新方案比当前最短路长，直接忽略.</li>
</ol>
<p>这样一边运行 Dijkstra 算法一边进行<code>DP</code>，最终 <span class="math inline">\(dp[n−1]\)</span> 就是从起点到 n−1 的最短路方案数。</p>
<p><a href="https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/solutions/951921/dao-da-mu-de-di-de-fang-an-shu-by-leetco-5ptp/comments/2245342">最短路+动态规划 - Pein</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPaths</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// create the graph</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">graph</span>(n , <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : roads) &#123;</span><br><span class="line">            <span class="type">int</span> x = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> w = edge[<span class="number">2</span>];</span><br><span class="line">            graph[x][y] = w;</span><br><span class="line">            graph[y][x] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dijkstra + dp</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dist</span><span class="params">(n, LLONG_MAX)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; (t &lt; <span class="number">0</span> || dist[j] &lt; dist[t])) &#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[t] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!graph[t][j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dist[t] + graph[t][j] &lt; dist[j]) &#123;</span><br><span class="line">                    dp[j] = dp[t];</span><br><span class="line">                    dist[j] = dist[t] + graph[t][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dist[t] + graph[t][j] == dist[j]) &#123;</span><br><span class="line">                    dp[j] = (dp[j] + dp[t]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^2)</p>
<p>Space: O(n^2)</p>
<h2 id="notes">Notes</h2>
<h3 id="dijkstra-approach-with-priority-queue">Dijkstra approach with priority queue</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/solutions/951921/dao-da-mu-de-di-de-fang-an-shu-by-leetco-5ptp">到达目的地的方案数 - 力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPaths</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">e</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; road : roads) &#123;</span><br><span class="line">            <span class="type">int</span> x = road[<span class="number">0</span>], y = road[<span class="number">1</span>], t = road[<span class="number">2</span>];</span><br><span class="line">            e[x].<span class="built_in">emplace_back</span>(y, t);</span><br><span class="line">            e[y].<span class="built_in">emplace_back</span>(x, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dis</span><span class="params">(n, LLONG_MAX)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">ways</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;LL, <span class="type">int</span>&gt;, vector&lt;pair&lt;LL, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;LL, <span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        ways[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [t, u] = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (t &gt; dis[u]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[v, w] : e[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t + w &lt; dis[v]) &#123;</span><br><span class="line">                    dis[v] = t + w;</span><br><span class="line">                    ways[v] = ways[u];</span><br><span class="line">                    q.<span class="built_in">emplace</span>(t + w, v);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t + w == dis[v]) &#123;</span><br><span class="line">                    ways[v] = (ways[u] + ways[v]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ways[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mlogm)</p>
<p>Space: O(m)</p>
<blockquote>
<p>其中 m 为 <span class="math inline">\(\textit{roads}\)</span> 的长度。由于 <span class="math inline">\(m\ge n-1\)</span>，分析复杂度时以 m 为主. 注意堆中会有重复节点，所以至多有 <span class="math inline">\(\mathcal{O}(m)\)</span> 个元素，单次操作的复杂度是 <span class="math inline">\(\mathcal{O}(\log m)\)</span> . 值得注意的是，如果输入的是稠密图，写法二的时间复杂度为 <span class="math inline">\(\mathcal{O}(n^2\log n)\)</span> ，不如朴素 Dijkstra .</p>
<p>作者：灵茶山艾府 链接：https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/solutions/2668041/zai-ji-suan-zui-duan-lu-de-tong-shi-dpfu-g4f3/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>dynamic-programming</tag>
        <tag>graph</tag>
        <tag>topological-sort</tag>
        <tag>shortest-path</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 198 House Robber</title>
    <url>/2024/01/21/LeetCode198/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/house-robber/description/">House Robber - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>DP . <span class="math inline">\(dp[i] = max(dp[i + 2], dp[i + 3]) + nums[i]\)</span></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(((i + <span class="number">2</span> &lt; n) ? dp[i + <span class="number">2</span>] : <span class="number">0</span>), ((i + <span class="number">3</span> &lt; n) ? dp[i + <span class="number">3</span>] : <span class="number">0</span>)) + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<blockquote>
<ol type="1">
<li>Use two variables, <code>rob</code> and <code>norob</code>, to keep track of the maximum amount of money robbed with or without robbing the current house.</li>
<li>Iterate through each house, and at each step, calculate the maximum amount of money if the current house is robbed (<code>newRob</code>) and if it is not robbed (<code>newNoRob</code>).</li>
<li>Update <code>rob</code> and <code>norob</code> for the next iteration.</li>
<li>The final result is the maximum amount between the two scenarios: robbing the last house or not robbing it.</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rob = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> norob = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> newRob = norob + nums[i];</span><br><span class="line">            <span class="type">int</span> newNoRob = <span class="built_in">max</span>(norob, rob);</span><br><span class="line">            rob = newRob;</span><br><span class="line">            norob = newNoRob;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rob, norob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1992 Find All Groups of Farmland</title>
    <url>/2024/04/19/LeetCode1992/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-all-groups-of-farmland/">Find All Groups of Farmland - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/find-all-groups-of-farmland/solutions/978685/python3-1bfsji-yi-hua-by-hanxin_hanxin-9u1i">（1）bfs+记忆化 （2）dfs+记忆化 - HanXin</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; land;</span><br><span class="line">    <span class="type">int</span> Row;</span><br><span class="line">    <span class="type">int</span> Col;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">bfs</span><span class="params">(<span class="type">int</span> sr, <span class="type">int</span> sc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> r2 = sr;</span><br><span class="line">        <span class="type">int</span> c2 = sc;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;sr, sc&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = q.<span class="built_in">front</span>();    q.<span class="built_in">pop</span>();</span><br><span class="line">            r2 = <span class="built_in">max</span>(r2, r);</span><br><span class="line">            c2 = <span class="built_in">max</span>(c2, c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">4</span>; di ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> dr = dirs[di][<span class="number">0</span>],    dc = dirs[di][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> nr = r + dr,    nc = c + dc;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; Row &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; Col &amp;&amp; land[nr][nc] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    land[nr][nc] = <span class="number">0</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;nr, nc&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&#123;r2, c2&#125;;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findFarmland</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; land) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;land = land;</span><br><span class="line">        Row = (<span class="type">int</span>)land.<span class="built_in">size</span>();</span><br><span class="line">        Col = (<span class="type">int</span>)land[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; Row; r ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; Col; c ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;land[r][c] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;land[r][c] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">auto</span> [r2, c2] = <span class="built_in">bfs</span>(r, c);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;r, c, r2, c2&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1997 First Day Where You Have Been in All the Rooms</title>
    <url>/2024/03/28/LeetCode1997/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/first-day-where-you-have-been-in-all-the-rooms/">First Day Where You Have Been in All the Rooms - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接递归果然超时了x</p>
<blockquote>
<p><a href="https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/solutions/979221/qian-zhui-he-you-hua-dp-by-endlesscheng-j10b">前缀和优化 DP - 灵茶山艾府</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstDayBeenInAllRooms</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nextVisit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nextVisit.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">s</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = nextVisit[i];</span><br><span class="line">            s[i + <span class="number">1</span>] = (s[i] * <span class="number">2</span> - s[j] + <span class="number">2</span> + MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2007 Find Original Array From Doubled Array</title>
    <url>/2024/04/18/LeetCode2007/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-original-array-from-doubled-array/">Find Original Array From Doubled Array - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/find-original-array-from-doubled-array/solutions/2740671/cong-shuang-bei-shu-zu-zhong-huan-yuan-y-0vgc">力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOriginalArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; changed)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(changed.<span class="built_in">begin</span>(), changed.<span class="built_in">end</span>());</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : changed) &#123;</span><br><span class="line">            ++count[a];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : changed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[a] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --count[a];</span><br><span class="line">            <span class="keyword">if</span> (count[a * <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            --count[a * <span class="number">2</span>];</span><br><span class="line">            res.<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>hash-table</tag>
        <tag>greedy</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 200 Number of Islands</title>
    <url>/2024/04/20/LeetCode200/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/number-of-islands/">Number of Islands - leetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/number-of-islands/solutions/13103/dao-yu-shu-liang-by-leetcode">力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mn)</p>
<p>Space: O(min(m, n))</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>matrix</tag>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2009 Minimum Number of Operations to Make Array Continuous</title>
    <url>/2024/04/08/LeetCode2009/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/">Minimum Number of Operations to Make Array Continuous - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p>So hard:(</p>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/solutions/1005398/on-zuo-fa-by-endlesscheng-l7yi">正难则反+滑动窗口，附题单 - 灵茶山艾府</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(nums);</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) - nums.<span class="built_in">begin</span>(); <span class="comment">// 原地去重</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[left] &lt; nums[i] - n + <span class="number">1</span>) &#123; <span class="comment">// nums[left] 不在窗口内</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>sliding-window</tag>
        <tag>binary-search</tag>
        <tag>hahs-table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 201 Bitwise AND of Numbers Range</title>
    <url>/2024/02/21/LeetCode201/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/bitwise-and-of-numbers-range/description/">Bitwise AND of Numbers Range - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接不减枝的暴力遍历计算一眼不能过.</p>
<p>问题的核心是，找出 left 和 right 两数的二进制格式的最长相同前缀.</p>
<blockquote>
<p>由于数据的连续性和按位与运算有 0 出 0 的特点，在最长相同前缀后的位数总会存在一个数在该位上为 0 .</p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left &lt;&lt; count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Time: O(logn)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="bit-manipulation-tricky-approach">Bit manipulation tricky approach</h3>
<blockquote>
<p><a href="https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/593317/simple-3-line-java-solution-faster-than-100">Simple 3 line Java solution faster than 100% - yash0695</a></p>
</blockquote>
<p><strong>Bitwise-AND of any two numbers will always produce a number less than or equal to the smaller number.</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">            right = right &amp; (right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left &amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(1)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>bit-manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2037 Minimum Number of Moves to Seat Everyone</title>
    <url>/2024/06/13/LeetCode2037/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-number-of-moves-to-seat-everyone/">Minimum Number of Moves to Seat Everyone - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-number-of-moves-to-seat-everyone/solutions/2037615/shi-mei-wei-xue-sheng-du-you-zuo-wei-de-oll4i">使每位学生都有座位的最少移动次数 - 力扣官方题解</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMovesToSeat</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; seats, vector&lt;<span class="type">int</span>&gt;&amp; students)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(seats.<span class="built_in">begin</span>(), seats.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seats.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res += <span class="built_in">abs</span>(seats[i] - students[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(logn)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>greedy</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 206 Reverse Linked List</title>
    <url>/2024/03/21/LeetCode206/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/reverse-linked-list/">Reverse Linked List - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>简单的链表翻转.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            ListNode* tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = pre;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="recursion-approach">Recursion approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode75</category>
        <category>Linked-List</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>linked-list</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 205 Isomorphic Strings</title>
    <url>/2024/04/02/LeetCode205/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/isomorphic-strings/">Isomorphic Strings - LeetCode</a></p>
</blockquote>
<h1 id="thinkings">Thinkings</h1>
<p>用 hash table 存储映射，判断映射是否为双射.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; m;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; visited;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(t[i]) == m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[s[i]] != <span class="number">1</span>) &#123;</span><br><span class="line">                    m[t[i]] = s[i];</span><br><span class="line">                    visited[s[i]] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m[t[i]] != s[i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<p>用数组而不是 map .</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">256</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">bool</span> istCharmapped[<span class="number">256</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[i]] == <span class="number">0</span> &amp;&amp; istCharmapped[t[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                hash[s[i]] = t[i];</span><br><span class="line">                istCharmapped[t[i]] = <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">char</span>(hash[s[i]]) != t[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2073 Time Needed to Buy Tickets</title>
    <url>/2024/04/09/LeetCode2073/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/time-needed-to-buy-tickets/">Time Needed to Buy Tickets - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/time-needed-to-buy-tickets/solutions/1102684/mai-piao-xu-yao-de-shi-jian-by-leetcode-jnfxx">力扣官方题解</a></p>
<ul>
<li><p>如果这个人初始在第 k 个人的前方，或者这个人恰好为第 k 个人，即 <span class="math inline">\(i \le k\)</span> ，此时在第 k 个人买完票之前他最多可以购买 <span class="math inline">\(\textit{tickets}[k]\)</span> 张。考虑到他想要购买的票数，那么他买票所需时间即为 <span class="math inline">\(\min(\textit{tickets}[k], \textit{tickets}[i])\)</span></p></li>
<li><p>如果这个人初始在第 k 个人的后方，即 <span class="math inline">\(i &gt; k\)</span> ，此时在第 k 个人买完票之前他最多可以购买 <span class="math inline">\(\textit{tickets}[k] - 1\)</span> 张。考虑到他想要购买的票数，那么他买票所需时间即为 <span class="math inline">\(\min(\textit{tickets}[k] - 1, \textit{tickets}[i])\)</span> .</p></li>
</ul>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">timeRequiredToBuy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; tickets, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = tickets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= k) &#123;</span><br><span class="line">                res += <span class="built_in">min</span>(tickets[i], tickets[k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += <span class="built_in">min</span>(tickets[i], tickets[k] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>queue</tag>
        <tag>simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2092 Find All People With Secret</title>
    <url>/2024/02/24/LeetCode2092/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-all-people-with-secret/description/">Find All People With Secret - LeetCode</a></p>
</blockquote>
<h2 id="dfs-approach">DFS approach</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/find-all-people-with-secret/solutions/1126268/an-zhao-xiang-tong-shi-jian-fen-zu-jian-2y4yx">按照相同时间分组 + 建图 DFS - 灵茶山艾府</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAllPeople</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; meetings, <span class="type">int</span> firstPerson)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort by time</span></span><br><span class="line">        <span class="built_in">sort</span>(meetings.<span class="built_in">begin</span>(), meetings.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; infected&#123;<span class="number">0</span>, firstPerson&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// iterate by time</span></span><br><span class="line">        <span class="type">int</span> m = meetings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">            <span class="comment">// construct the graph</span></span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; graph;</span><br><span class="line">            <span class="type">int</span> time = meetings[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; m &amp;&amp; meetings[i][<span class="number">2</span>] == time) &#123;</span><br><span class="line">                <span class="type">int</span> x = meetings[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> y = meetings[i][<span class="number">1</span>];</span><br><span class="line">                graph[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">                graph[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> v) &#123;</span><br><span class="line">                infected.<span class="built_in">insert</span>(v);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; w : graph[v]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!infected.<span class="built_in">count</span>(w)) &#123;</span><br><span class="line">                        <span class="built_in">dfs</span>(w);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [v, _] : graph) &#123;</span><br><span class="line">                <span class="keyword">if</span> (infected.<span class="built_in">count</span>(v)) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : infected) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mlogm)</p>
<p>Space: O(m + n)</p>
<blockquote>
<p>当然也可以用 BFS 解决.</p>
</blockquote>
<h2 id="union-find-approach">Union find approach</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/find-all-people-with-secret/solutions/1126597/bing-cha-ji-pai-xu-javashuang-bai-xiang-5gbrx">并查集+排序，Java双百详细题解 - 无人生还</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) &#123;</span><br><span class="line">			p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAllPeople</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; meetings, <span class="type">int</span> firstPerson)</span> </span>&#123;</span><br><span class="line">		p.<span class="built_in">resize</span>(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			p[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		p[firstPerson] = <span class="number">0</span>;</span><br><span class="line">		map&lt;<span class="type">int</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; meeting;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; m : meetings) &#123;</span><br><span class="line">		    meeting[m[<span class="number">2</span>]].<span class="built_in">push_back</span>(&#123;m[<span class="number">0</span>], m[<span class="number">1</span>]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [t, m] : meeting) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [p1, p2] : m) &#123;</span><br><span class="line">				<span class="keyword">if</span> (p[<span class="built_in">find</span>(p1)] == <span class="number">0</span> || p[<span class="built_in">find</span>(p2)] == <span class="number">0</span>) &#123;</span><br><span class="line">					p[<span class="built_in">find</span>(p1)] = <span class="number">0</span>;</span><br><span class="line">					p[<span class="built_in">find</span>(p2)] = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				p[<span class="built_in">find</span>(p2)] = p[<span class="built_in">find</span>(p1)]; <span class="comment">// merge sets</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [p1, p2] : m) &#123;</span><br><span class="line">				<span class="keyword">if</span> (p[<span class="built_in">find</span>(p1)] == <span class="number">0</span> || p[<span class="built_in">find</span>(p2)] == <span class="number">0</span>) &#123;</span><br><span class="line">					p[<span class="built_in">find</span>(p1)] = <span class="number">0</span>;</span><br><span class="line">					p[<span class="built_in">find</span>(p2)] = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// divide</span></span><br><span class="line">					p[p1] = p1;</span><br><span class="line">					p[p2] = p2;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">find</span>(i)) &#123;</span><br><span class="line">				res.<span class="built_in">push_back</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mlogm)</p>
<p>Space: O(m + n)</p>
<h4 id="faster-union-find-approach">Faster union find approach</h4>
<blockquote>
<p><code>for</code> 比 <code>foreach</code> 快一丢丢，且直接在 <code>meetings</code> 上排序比另维护一个 <code>time, meeting</code> 的 map 更快更省空间.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parents, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parents[k] == k) <span class="keyword">return</span> k;</span><br><span class="line">        <span class="keyword">return</span> parents[k] = <span class="built_in">find</span>(parents, parents[k]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAllPeople</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; meetings, <span class="type">int</span> firstPerson)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = meetings.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parents</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (i != firstPerson) parents[i] = i;</span><br><span class="line">        <span class="keyword">auto</span> comp = [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y) &#123; <span class="keyword">return</span> x[<span class="number">2</span>] &lt; y[<span class="number">2</span>]; &#125;;</span><br><span class="line">        <span class="built_in">sort</span>(meetings.<span class="built_in">begin</span>(), meetings.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m; i = j + <span class="number">1</span>, j = j + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j + <span class="number">1</span> &lt; m &amp;&amp; meetings[j + <span class="number">1</span>][<span class="number">2</span>] == meetings[i][<span class="number">2</span>]) j++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">                <span class="type">int</span> x = meetings[k][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> y = meetings[k][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> px = parents[<span class="built_in">find</span>(parents, x)];</span><br><span class="line">                <span class="type">int</span> py = parents[<span class="built_in">find</span>(parents, y)];</span><br><span class="line">                <span class="keyword">if</span> (px == <span class="number">0</span> || py == <span class="number">0</span>) &#123;</span><br><span class="line">                    parents[<span class="built_in">find</span>(parents, x)] = <span class="number">0</span>;</span><br><span class="line">                    parents[<span class="built_in">find</span>(parents, y)] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                parents[<span class="built_in">find</span>(parents, x)] = parents[<span class="built_in">find</span>(parents, y)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">                <span class="type">int</span> x = meetings[k][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> y = meetings[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (parents[<span class="built_in">find</span>(parents, x)] != <span class="number">0</span>) parents[x] = x;</span><br><span class="line">                <span class="keyword">if</span> (parents[<span class="built_in">find</span>(parents, y)] != <span class="number">0</span>) parents[y] = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (parents[<span class="built_in">find</span>(parents, i)] == <span class="number">0</span>) ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mlogm)</p>
<p>Space: O(m + n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>sorting</tag>
        <tag>graph</tag>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2095 Delete the Middle Node of a Linked List</title>
    <url>/2024/02/21/LeetCode2095/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/description/">Delete the Middle Node of a Linked List - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>经典快慢指针找中点.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteMiddle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line">        ListNode* pre = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>Linked-List</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>two-pointers</tag>
        <tag>linked-list</tag>
        <tag>fast-slow-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2108 Find First Palindromic String in the Array</title>
    <url>/2024/02/13/LeetCode2108/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-first-palindromic-string-in-the-array/description/">Find First Palindromic String in the Array - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>遍历一遍 <code>words</code> ，对每一个 <code>word</code> 进行回文判断. 其中回文判断使用首尾双指针向内缩进的方式判断.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">firstPalindrome</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> r = words[i].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (words[i][l] != words[i][r]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">return</span> words[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2129 Capitalize the Title</title>
    <url>/2024/03/11/LeetCode2129/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/capitalize-the-title/">Capitalize the Title - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>字符串分割后模拟.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">capitalizeTitle</span><span class="params">(string title)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; tokens;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(title)</span></span>;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">            tokens.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; token : tokens) &#123;</span><br><span class="line">            <span class="type">int</span> n = token.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                token[i] = <span class="built_in">toupper</span>(token[i]);</span><br><span class="line">                <span class="keyword">while</span> (++i &lt; n) &#123;</span><br><span class="line">                    token[i] = <span class="built_in">tolower</span>(token[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">                    token[i] = <span class="built_in">tolower</span>(token[i]);</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += token + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<h4 id="faster-stringstream-split-approach">Faster <code>stringstream</code> split approach</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">capitalizeTitle</span><span class="params">(string title)</span> </span>&#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(title)</span></span>;</span><br><span class="line">        string s;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!res.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                res += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                res += <span class="built_in">toupper</span>(s[<span class="number">0</span>]);</span><br><span class="line">                s = s.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; c : s) &#123;</span><br><span class="line">                res += <span class="built_in">tolower</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="istringstream-split-approach"><code>istringstream</code> split approach</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">capitalizeTitle</span><span class="params">(string title)</span> </span>&#123;</span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(title)</span></span>;</span><br><span class="line">        string res;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">while</span> (iss &gt;&gt; s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!res.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                res += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                res += <span class="built_in">toupper</span>(s[<span class="number">0</span>]);</span><br><span class="line">                s = s.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; c : s) &#123;</span><br><span class="line">                res += <span class="built_in">tolower</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h4 id="approach-without-split">approach without split</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">capitalizeTitle</span><span class="params">(string title)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = title.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;   <span class="comment">// 单词左右边界（左闭右开）</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; n &amp;&amp; title[r] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于每个单词按要求处理</span></span><br><span class="line">            <span class="keyword">if</span> (r - l &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                title[l++] = <span class="built_in">toupper</span>(title[l]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                title[l++] = <span class="built_in">tolower</span>(title[l]);</span><br><span class="line">            &#125;</span><br><span class="line">            l = ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h3 id="standard-library-header"><a href="https://en.cppreference.com/w/cpp/header/cctype">Standard library header <cctype></a></h3>
<ul>
<li><code>std::toupper()</code></li>
<li><code>std::tolower()</code></li>
</ul>
<h3 id="split-a-string---c-f.a.q."><a href="https://cplusplus.com/faq/sequences/strings/split/">Split a string - C++ F.A.Q.</a></h3>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2130 Maximum Twin Sum of a Linked List</title>
    <url>/2024/03/06/LeetCode2130/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/">Maximum Twin Sum of a Linked List - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>快慢指针找中点，把后半部分翻转之后，同时遍历前半和后半，维护 Maximum twin sum. 当然，翻转遍历这部分还可以用 stack 的 LIFO 特性.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pairSum</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse the back part</span></span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            ListNode* tmp = fast-&gt;next;</span><br><span class="line">            fast-&gt;next = pre;</span><br><span class="line">            pre = fast;</span><br><span class="line">            fast = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = pre;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// iterate the twin sum</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, slow-&gt;val + fast-&gt;val);</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="another-approach">Another approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pairSum</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = slow;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pre &amp;&amp; head) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(pre-&gt;val + head -&gt;val, res);</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>Linked-List</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>two-pointers</tag>
        <tag>linked-list</tag>
        <tag>stack</tag>
        <tag>fast-slow-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1379 All Ancestors of a Node in a Directed Acyclic Graph</title>
    <url>/2024/06/29/LeetCode2192/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/">All Ancestors of a Node in a Directed Acyclic Graph - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solutions/2723203/liang-chong-fang-fa-ni-xiang-zheng-xiang-rwjs">两种方法：逆向/正向 - 灵茶山艾府</a></p>
</blockquote>
<h3 id="reverse-dfs-approach">Reverse DFS approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getAncestors</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            g[e[<span class="number">1</span>]].<span class="built_in">push_back</span>(e[<span class="number">0</span>]); <span class="comment">// inverse graph building</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            vis[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y : g[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ranges::<span class="built_in">fill</span>(vis, <span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[j]) &#123;</span><br><span class="line">                    ans[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n(m + n))</p>
<p>Space: O(m + n)</p>
<h3 id="topological-sort-approach">Topological sort approach</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solutions/1364674/you-xiang-wu-huan-tu-zhong-yi-ge-jie-dia-6ed5">有向无环图中一个节点的所有祖先 - 力扣官方题解</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>graph</tag>
        <tag>topological-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2149 Rearrange Array Elements by Sign</title>
    <url>/2024/02/14/LeetCode2149/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/rearrange-array-elements-by-sign/description/">Rearrange Array Elements by Sign - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>由于相同符号数字间保持原序，可以使用两个队列分别存储正数和负数. 又可空间优化为双指针，一个指针指向正数在结果数组 <code>res</code> 中的位置，另一个指针则指向负数的位置.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rearrangeArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> neg = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                res[pos] = nums[i];</span><br><span class="line">                pos += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[neg] = nums[i];</span><br><span class="line">                neg += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>two-pointers</tag>
        <tag>simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2215 Find the Difference of Two Arrays</title>
    <url>/2024/01/31/LeetCode2215/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-the-difference-of-two-arrays/description/">Find the Difference of Two Arrays - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>维护两个 hash set ，将两个数组中出现的值分别加进 hash set 中. 接着遍历数组，若某元素不在另一数组对应的 hash set 中，则将该元素弹入该数组对应的 vector 中. 最后返回两个 vector 构成的 vector 即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findDifference</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123;</span><br><span class="line">            s1.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            s2.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans1;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : s1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.<span class="built_in">find</span>(num) == s2.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans1.<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : s2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.<span class="built_in">find</span>(num) == s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans2.<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;ans1, ans2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findDifference</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set1</span><span class="params">(nums1.begin(),nums1.end())</span></span>;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set2</span><span class="params">(nums2.begin(),nums2.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; distinct_nums1, distinct_nums2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: set1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set2.<span class="built_in">count</span>(num)==<span class="number">0</span>)</span><br><span class="line">                distinct_nums1.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: set2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.<span class="built_in">count</span>(num)==<span class="number">0</span>)</span><br><span class="line">                distinct_nums2.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;distinct_nums1,distinct_nums2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h3 id="unordered_set-c11"><code>unordered_set (C++11)</code></h3>
<p><a href="https://en.cppreference.com/w/cpp/container/unordered_set">std::unordered_set - cppreference.com</a></p>
<h4 id="initialization">initialization</h4>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt; mySet&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>&#125;; <span class="comment">// creates a set of ints</span></span><br></pre></td></tr></table></figure>
<h4 id="insert"><code>insert</code></h4>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">5</span>); <span class="comment">// puts an element 5 in the set</span></span><br></pre></td></tr></table></figure>
<h4 id="erase"><code>erase</code></h4>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt; mySet&#123;<span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">mySet.<span class="built_in">erase</span>(<span class="number">2</span>); <span class="comment">// removes an element 2 in the set</span></span><br><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt;::iterator iter = mySet.<span class="built_in">front</span>();</span><br><span class="line">mySet.<span class="built_in">erase</span>(iter); <span class="comment">// removes an element pointed to by iter</span></span><br></pre></td></tr></table></figure>
<h4 id="traverse">traverse</h4>
<p>for-each:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt; mySet&#123;<span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : mySet) &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iterator:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt; mySet&#123;<span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (std::unordered_set&lt;<span class="type">int</span>&gt;::interator it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="determine-if-a-number-is-in-the-set">determine if a number is in the set</h4>
<p><code>find</code> : <code>(mySet.find(num) == mySet.end())</code> 若 num 不在 mySet 中，返回 true.</p>
<p><code>count</code> : <code>(mySet.count(num) == 0)</code> 若 num 不在 mySet 中，返回 true.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>hash-map/set</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-75</tag>
        <tag>hash-table</tag>
        <tag>unordered_set</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 225 Implement Stack using Queues</title>
    <url>/2024/03/03/LeetCode225/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/implement-stack-using-queues/">Implement Stack using Queues - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>使用两个队列模拟栈的 LIFO .</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            q2.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            q1.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">if</span> (q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (q2.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                q1.<span class="built_in">push</span>(q2.<span class="built_in">front</span>());</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            res = q2.<span class="built_in">front</span>();</span><br><span class="line">            q2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (q1.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            res = q1.<span class="built_in">front</span>();</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> q2.<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q1.<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>() &amp;&amp; q2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>design</tag>
        <tag>stack</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2225 Find Players With Zero or One Losses</title>
    <url>/2024/01/15/LeetCode2225/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-players-with-zero-or-one-losses/description/">Find Players With Zero or One Losses - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>遍历一遍维护一个记录败场的 pair ，再遍历一遍找出无败和 1 败的选手，并维护相应的容器，最后 sort 整合输出结果.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findWinners</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matches) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; winner0;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; winner1;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m; <span class="comment">// the record of the pair </span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; match : matches) &#123;</span><br><span class="line">            m[match[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; match : matches) &#123;</span><br><span class="line">            <span class="type">int</span> winner = match[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> loser = match[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (m[winner] == <span class="number">0</span>) &#123;</span><br><span class="line">                winner0.<span class="built_in">push_back</span>(winner);</span><br><span class="line">                m[winner] = <span class="number">-1</span>; <span class="comment">// if not, it would repeat</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m[loser] == <span class="number">1</span>) &#123;</span><br><span class="line">                winner1.<span class="built_in">push_back</span>(loser);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(winner0.<span class="built_in">begin</span>(), winner0.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(winner1.<span class="built_in">begin</span>(), winner1.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(winner0);</span><br><span class="line">        res.<span class="built_in">push_back</span>(winner1);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 231 Power of Two</title>
    <url>/2024/02/19/LeetCode231/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/power-of-two/description/">Power of Two - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接就是一个递归x</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span> || n % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; <span class="built_in">isPowerOfTwo</span>(n / <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(logn)</p>
<p>Space: O(logn)</p>
<h2 id="notes">Notes</h2>
<h3 id="bit-manipulation-approach">Bit manipulation approach</h3>
<p>事实上我们可以证明 <span class="math display">\[
2^n \; \text{BAND} \; (2^n - 1) = 0
\]</span></p>
<blockquote>
<p><a href="https://leetcode.com/problems/power-of-two/solutions/1638707/python-c-java-detailly-explain-why-n-n-1-works-1-line-100-faster-easy">Detailly Explain Why n &amp; n - 1 Works? - linfq</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; !(n &amp; n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(1)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>math</tag>
        <tag>recursion</tag>
        <tag>bit-manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2285 Maximum Total Importance of Roads</title>
    <url>/2024/06/28/LeetCode2285/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-total-importance-of-roads/">Maximum Total Importance of Roads - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/maximum-total-importance-of-roads/solutions/1523886/by-endlesscheng-9p6y">排序不等式 - 灵茶山艾府</a></p>
<p><a href="https://leetcode.com/problems/maximum-total-importance-of-roads/solutions/5380283/beats-100-explained-with-video-c-java-python-js-count-frequency-degree">Count Frequency &amp; Degree - lancertech6</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumImportance</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">graph</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; road: roads) &#123;</span><br><span class="line">            graph[road[<span class="number">0</span>]] += <span class="number">1</span>;</span><br><span class="line">            graph[road[<span class="number">1</span>]] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(graph.<span class="built_in">begin</span>(), graph.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            res += (i + <span class="number">1</span>) * (<span class="type">long</span>)graph[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn + m)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>greedy</tag>
        <tag>sorting</tag>
        <tag>graph</tag>
        <tag>heap/priority-heap</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2288 Apply Discount to Prices</title>
    <url>/2024/06/18/LeetCode2288/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/apply-discount-to-prices/">Apply Discount to Prices - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/apply-discount-to-prices/solutions/2809596/jie-ge-jian-mian-by-leetcode-solution-m8tx">价格减免 - 力扣官方题解</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string discountPrices(string sentence, int discount) &#123;</span><br><span class="line">        stringstream sin(sentence), sout;</span><br><span class="line">        sout &lt;&lt; fixed &lt;&lt; setprecision(2);</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; words;</span><br><span class="line">        string word;</span><br><span class="line">        while (sin &gt;&gt; word) &#123;</span><br><span class="line">            if (word[0] == &#x27;$&#x27; &amp;&amp; word.size() &gt; 1 &amp;&amp; all_of(word.begin() + 1, word.end(), ::isdigit)) &#123;</span><br><span class="line">                double price = stoll(word.substr(1, word.size() - 1)) * (1.0 - discount / 100.0);</span><br><span class="line">                sout &lt;&lt; &#x27;$&#x27; &lt;&lt; price;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                sout &lt;&lt; word;</span><br><span class="line">            &#125;</span><br><span class="line">            sout &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans = sout.str();</span><br><span class="line">        ans.pop_back();</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2312 Selling Pieces of Wood</title>
    <url>/2024/03/15/LeetCode2312/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/selling-pieces-of-wood/">Selling Pieces of Wood - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/selling-pieces-of-wood/solutions/1611240/by-endlesscheng-mrmd">动态规划：枚举切割位置+循环优化 - 灵茶山艾府</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sellingWood</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; price : prices) &#123;</span><br><span class="line">            dp[price[<span class="number">0</span>]][price[<span class="number">1</span>]] = price[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= j / <span class="number">2</span>; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k] + dp[i][j - k]); <span class="comment">// vertical</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;=i / <span class="number">2</span>; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[k][j] + dp[i - k][j]); <span class="comment">// horizontal</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mn(m + n))</p>
<p>Space: O(nm)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>dynamic-programming</tag>
        <tag>memoization</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 232 Implement Queue using Stacks</title>
    <url>/2024/03/04/LeetCode232/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/">Implement Queue using Stacks - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>经典数据结构题. 用两个 stack 模拟 queue . 入队是将 s2 全弹到 s1 再入 s1 ，出队是将 s1 全弹到 s2 再 弹出 s2 的顶部元素. 画个简单的示意图就懂了.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = s2.<span class="built_in">top</span>();</span><br><span class="line">            s1.<span class="built_in">push</span>(tmp);</span><br><span class="line">            s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = s1.<span class="built_in">top</span>();</span><br><span class="line">            s2.<span class="built_in">push</span>(tmp);</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = s2.<span class="built_in">top</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = s1.<span class="built_in">top</span>();</span><br><span class="line">            s2.<span class="built_in">push</span>(tmp);</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>() &amp;&amp; s2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Time:</p>
<p>​ push: O(n)</p>
<p>​ pop: O(n)</p>
<p>​ peek: O(n)</p>
<p>​ empty: O(1)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 234 Palindrome Linked List</title>
    <url>/2024/03/22/LeetCode234/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/palindrome-linked-list/">Palindrome Linked List - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>快慢指针找中点，可以用辅助存储，也可以反转一半再遍历对比.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast) &#123;</span><br><span class="line">            <span class="comment">// odd length</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            ListNode* tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = slow;</span><br><span class="line">            slow = p;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (slow) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val != slow-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>two-pointers</tag>
        <tag>linked-list</tag>
        <tag>stack</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2352 Equal Row and Column Pairs</title>
    <url>/2024/01/31/LeetCode2352/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/equal-row-and-column-pairs/description/">Equal Row and Column Pairs - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>偷看 topic 是 hash table:) 就构造一个 rowMap 和一个 colMap，再二重循环遍历这两个 map ，遇到相等则 count++，最后返回 count.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">equalPairs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; rowMap;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; colMap;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                rowMap[i].<span class="built_in">push_back</span>(grid[i][j]);</span><br><span class="line">                colMap[j].<span class="built_in">push_back</span>(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="type">const</span> <span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; row : rowMap) &#123;</span><br><span class="line">            <span class="keyword">for</span> (pair&lt;<span class="type">const</span> <span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; col : colMap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row.second == col.second) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^2)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">equalPairs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Number to store the count of equal pairs.</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        map&lt;vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="comment">// Storing each row int he map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++)</span><br><span class="line">            mp[grid[i]]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="comment">// extracting column in a vector.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid.<span class="built_in">size</span>(); j++)</span><br><span class="line">                v.<span class="built_in">push_back</span>(grid[j][i]);</span><br><span class="line">            <span class="comment">// Add the number of times that column appeared as a row.</span></span><br><span class="line">            ans += mp[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Return the number of count</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^2)</p>
<p>Space: O(n)</p>
<h3 id="unordered_map-c11"><code>unordered_map (C++11)</code></h3>
<p><a href="https://en.cppreference.com/w/cpp/container/unordered_map">std::unordered_map - cppreference.com</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>hash-map/set</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-75</tag>
        <tag>hash-table</tag>
        <tag>unordered_map</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2368 Reachable Nodes With Restrictions</title>
    <url>/2024/03/02/LeetCode2368/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/reachable-nodes-with-restrictions/description/">Reachable Nodes With Restrictions - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>需要数据预处理的树遍历，否则会超时. 可以用哈希集合或布尔数组记录受限节点，之后根据该预处理结果构造树（ <code>vector&lt;vector&lt;int&gt;</code> ）.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reachableNodes</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; restricted)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(restricted.begin(), restricted.end())</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> x = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!r.<span class="built_in">contains</span>(x) &amp;&amp; !r.<span class="built_in">contains</span>(y)) &#123;</span><br><span class="line">                graph[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">                graph[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> counts = <span class="number">1</span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[node]) &#123;</span><br><span class="line">                visited[node] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> w : graph[node]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                        ++counts;</span><br><span class="line">                        <span class="built_in">dfs</span>(w);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<p><strong>但是很慢很慢</strong></p>
<h2 id="notes">Notes</h2>
<h3 id="faster-approach---union-find">Faster approach - Union find</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/reachable-nodes-with-restrictions/solutions/2654302/shou-xian-tiao-jian-xia-ke-dao-da-jie-di-9qee">受限条件下可到达节点的数目 - 力扣官方题解</a></p>
<p>如果忽略受限的点，树就会变成若干个连通块，我们要计算的就是 0 号点所在连通块的大小。</p>
<p>因此，我们可以用并查集来不断地将点集进行合并，依次考虑每一条边，如果边上两个点都没有受限，那么合并这两个点的所在集合，否则跳过该边。最终查询 0 号点所在连通块的大小即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) : <span class="built_in">f</span>(n), <span class="built_in">rank</span>(n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="comment">// merge two sets into one</span></span><br><span class="line">        <span class="type">int</span> rx = <span class="built_in">find</span>(x); <span class="comment">// the root of x</span></span><br><span class="line">        <span class="type">int</span> ry = <span class="built_in">find</span>(y); <span class="comment">// the root of y</span></span><br><span class="line">        <span class="keyword">if</span> (rx != ry) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank[rx] &gt; rank[ry]) &#123;</span><br><span class="line">                f[ry] = rx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rank[rx] &lt; rank[ry]) &#123;</span><br><span class="line">                f[rx] = ry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f[ry] = rx;</span><br><span class="line">                rank[rx]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">// find the root of x</span></span><br><span class="line">        <span class="keyword">if</span> (x != f[x]) &#123;</span><br><span class="line">            x = <span class="built_in">find</span>(f[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="comment">// the number of element in set</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rt = <span class="built_in">find</span>(<span class="number">0</span>); <span class="comment">//root of &#x27;0&#x27; node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; f.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rt == <span class="built_in">find</span>(i)) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; f; <span class="comment">// maintain the root of nodes</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rank; <span class="comment">// maintain the level of the root nodes</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reachableNodes</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; restricted)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">isrestricted</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : restricted) &#123;</span><br><span class="line">            isrestricted[x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        UnionFind uf = <span class="built_in">UnionFind</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isrestricted[v[<span class="number">0</span>]] || isrestricted[v[<span class="number">1</span>]]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            uf.<span class="built_in">merge</span>(v[<span class="number">0</span>], v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.<span class="built_in">count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Time: <span class="math inline">\(O(n \cdot \alpha (n))\)</span></p>
<p>Space: <span class="math inline">\(O(n)\)</span></p>
<blockquote>
<p>其中 n 是无向树中点的个数，<span class="math inline">\(\alpha\)</span> 是反阿克曼函数</p>
<p>使用路径压缩和按秩合并优化后的并查集，单次查询和合并操作的时间复杂度是 <span class="math inline">\(O(\alpha (n))\)</span></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>tree</tag>
        <tag>hash-table</tag>
        <tag>graph</tag>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2369 Check if There is a Valid Partition For The Array</title>
    <url>/2024/03/01/LeetCode2369/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/description/">Check if There is a Valid Partition For The Array - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/1728735/by-endlesscheng-8y73">如何想出状态定义？ - 灵茶山艾府</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> dp[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="literal">false</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((dp[i - <span class="number">1</span>] &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) || </span><br><span class="line">                (i &gt; <span class="number">1</span> &amp;&amp; dp[i - <span class="number">2</span>] &amp;&amp; (</span><br><span class="line">                    nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; nums[i] == nums[i - <span class="number">2</span>] || </span><br><span class="line">                    nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                ))) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 238 Product of Array Except Self</title>
    <url>/2024/03/15/LeetCode238/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/product-of-array-except-self/description/">Product of Array Except Self - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>遍历一遍 vector 获取某元素的左累积结果，再遍历一遍 vector 获取某元素的右累积结果，以此得到最终结果.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">product</span><span class="params">(n)</span></span>;</span><br><span class="line">        product[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// get left product</span></span><br><span class="line">            product[i] = product[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// get right product</span></span><br><span class="line">            product[i] *= right;</span><br><span class="line">            right *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="dynamic-programming-approachtabulation">Dynamic Programming Approach(tabulation)</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_Product</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_Product</span><span class="params">(n)</span></span>;</span><br><span class="line">        left_Product[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            left_Product[i] = left_Product[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        right_Product[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            right_Product[i] = right_Product[i+<span class="number">1</span>] * nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            ans[i] = left_Product[i] * right_Product[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h3 id="dynamic-programming-approachspace-optimization">Dynamic Programming Approach(Space Optimization)</h3>
<p>同我的 code .</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>array/string</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>LeetCode-75</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2390 Removing Stars From a String</title>
    <url>/2024/02/05/LeetCode2390/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/removing-stars-from-a-string/description/">Removing Stars From a String - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>栈. 遍历 s ，字母 push ，’*‘ pop.</p>
<p>但实际上这道题真用 stack 的话，会由于 string 和 stack 的转换超空间:) 因此得直接如下用 string .</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeStars</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                result.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="two-pointer-approach">Two pointer approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeStars</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s[j++] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(<span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>two-pointers</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2385 Amount of Time for Binary Tree to Be Infected</title>
    <url>/2024/01/10/LeetCode2385/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/description/">Amount of Time for Binary Tree to Be Infected - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>首先根据参数 <code>start</code> 找到起始节点，可使用任意遍历方法；其次使用非递归的后后序遍历获得各节点的父节点；接着从起始节点开始，使用类层次遍历进行传染并获取层数，得到的层数即传染整棵树所需的时间.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">amountOfTime</span><span class="params">(TreeNode* root, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">        TreeNode* startNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">findStartNode</span>(root, start, startNode);</span><br><span class="line">        map&lt;TreeNode*, TreeNode*&gt; parentOfNodes = <span class="built_in">getParentOfNodes</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">infection</span>(startNode, parentOfNodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findStartNode</span><span class="params">(TreeNode* root, <span class="type">int</span> start, TreeNode*&amp; startNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val == start) &#123;</span><br><span class="line">                startNode = root;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">findStartNode</span>(root-&gt;left, start, startNode);</span><br><span class="line">            <span class="built_in">findStartNode</span>(root-&gt;right, start, startNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">infection</span><span class="params">(TreeNode* root, map&lt;TreeNode*, TreeNode*&gt; parentOfNodes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> time = <span class="number">-1</span>;</span><br><span class="line">        map&lt;TreeNode*, <span class="type">bool</span>&gt;visited;</span><br><span class="line">        deque&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode* p = root;</span><br><span class="line">        q.<span class="built_in">push_back</span>(p);</span><br><span class="line">        TreeNode* last = p;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            p = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            visited[p] = <span class="literal">true</span>;</span><br><span class="line">            TreeNode* parent = parentOfNodes.<span class="built_in">at</span>(p);</span><br><span class="line">            <span class="keyword">if</span> (parent &amp;&amp; visited[parent] == <span class="literal">false</span>) &#123; <span class="comment">// if key &#x27;parent&#x27; is not in the map, a new pair (parent, false) will be created in the map</span></span><br><span class="line">                q.<span class="built_in">push_back</span>(parent);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left &amp;&amp; visited[p-&gt;left] == <span class="literal">false</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push_back</span>(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right &amp;&amp; visited[p-&gt;right] == <span class="literal">false</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push_back</span>(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == last) &#123;</span><br><span class="line">                last = q.<span class="built_in">back</span>();</span><br><span class="line">                ++time;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">map&lt;TreeNode*, TreeNode*&gt; <span class="title">getParentOfNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        map&lt;TreeNode*, TreeNode*&gt; parentOfNodes;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* p = root;</span><br><span class="line">        TreeNode* r = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* parent = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (p || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = s.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right &amp;&amp; p-&gt;right != r) &#123;</span><br><span class="line">                    p = p-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p = s.<span class="built_in">top</span>();</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    parent = s.<span class="built_in">empty</span>() ? <span class="literal">nullptr</span> : s.<span class="built_in">top</span>();</span><br><span class="line">                    parentOfNodes[p] = parent;</span><br><span class="line">                    r = p;</span><br><span class="line">                    p = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parentOfNodes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="complexity">Complexity</h3>
<p><strong>Time</strong>: O(n)</p>
<p><strong>Space</strong>: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="deque"><code>deque</code></h3>
<p><a href="https://en.cppreference.com/w/cpp/container/deque">std::deque - cppreference.com</a></p>
<h3 id="map"><code>map</code></h3>
<p><a href="https://en.cppreference.com/w/cpp/container/map">std::map - cppreference.com</a></p>
<h3 id="another-approach">Another approach</h3>
<ol type="1">
<li><strong>Graph Construction:</strong>
<ul>
<li>The solution creates a graph representation of the tree using a default dictionary <code>g</code> of lists in the <code>dfs</code> (Depth-First Search) function.</li>
</ul></li>
<li><strong>Initialization:</strong>
<ul>
<li>Initialize an empty set <code>vis</code> to keep track of visited nodes (infected nodes) and a queue <code>q</code> to maintain the BFS's order of node processing, with the start node as the initial node to be processed.</li>
</ul></li>
<li><strong>BFS Algorithm:</strong>
<ul>
<li>The solution sets up a while loop that continues until the queue <code>q</code> is empty, signifying that there are no more nodes to be infected.<br />
</li>
</ul></li>
<li><strong>Return Value:</strong>
<ul>
<li>By the end of the BFS loop, <code>ans</code> holds the number of minutes it took to infect the entire tree since each loop iteration represents one minute of infection time passing.</li>
<li>The return value <code>ans</code> represents the required number of minutes for the infection to spread through the entire tree, as determined by our BFS algorithm.</li>
</ul></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">amountOfTime</span><span class="params">(TreeNode* root, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">constructGraph</span>(root);</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minutesPassed = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++minutesPassed;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> levelSize = q.<span class="built_in">size</span>(); levelSize &gt; <span class="number">0</span>; --levelSize) &#123;</span><br><span class="line">                <span class="type">int</span> currentNode = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                visited.<span class="built_in">insert</span>(currentNode);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> adjacentNode : graph[currentNode]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.<span class="built_in">count</span>(adjacentNode)) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(adjacentNode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minutesPassed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">constructGraph</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            graph[root-&gt;val].<span class="built_in">push_back</span>(root-&gt;left-&gt;val);</span><br><span class="line">            graph[root-&gt;left-&gt;val].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            graph[root-&gt;val].<span class="built_in">push_back</span>(root-&gt;right-&gt;val);</span><br><span class="line">            graph[root-&gt;right-&gt;val].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">constructGraph</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">constructGraph</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Time</strong>: O(n)</p>
<p><strong>Space</strong>: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2402 Meeting Rooms III</title>
    <url>/2024/02/18/LeetCode2402/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/meeting-rooms-iii/description/">Meeting Rooms III - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>思路混乱x直接看题解吧</p>
<blockquote>
<p>用两个小顶堆模拟：</p>
<p><span class="math inline">\(\textit{idle}\)</span> 维护在 <span class="math inline">\(\textit{start}_i\)</span> 时刻空闲的会议室的编号； <span class="math inline">\(\textit{using}\)</span> 维护在 <span class="math inline">\(\textit{start}_i\)</span> 时刻使用中的会议室的结束时间和编号。 这两类会议室是互补关系，伴随着会议的开始和结束，会议室在这两类中来回倒。</p>
<p>对 <span class="math inline">\(\textit{meetings}\)</span> 按照开始时间排序，然后遍历 <span class="math inline">\(\textit{meetings}\)</span> ，按照题目要求模拟即可，具体模拟方式见代码。</p>
<p>作者：灵茶山艾府 链接：https://leetcode.cn/problems/meeting-rooms-iii/solutions/1799420/shuang-dui-mo-ni-pythonjavacgo-by-endles-ctwc/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mostBooked</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; meetings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count[n];</span><br><span class="line">        <span class="built_in">memset</span>(count, <span class="number">0</span>, <span class="built_in">sizeof</span>(count));</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; free; <span class="comment">// the element is the room&#x27;s index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// initialize the free room&#x27;s heap</span></span><br><span class="line">            free.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">long</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">long</span>, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; occupied; <span class="comment">// the element is the paif of room&#x27;s meeting end time and index</span></span><br><span class="line">        <span class="built_in">sort</span>(meetings.<span class="built_in">begin</span>(), meetings.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> &amp;a, <span class="keyword">auto</span> &amp;b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;); <span class="comment">// sort by start time</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; m : meetings) &#123;</span><br><span class="line">            <span class="type">long</span> st = m[<span class="number">0</span>]; <span class="comment">// m&#x27;s start time</span></span><br><span class="line">            <span class="type">long</span> et = m[<span class="number">1</span>]; <span class="comment">// m&#x27;s end time</span></span><br><span class="line">            <span class="type">long</span> id; <span class="comment">// the index of the room to be occupied</span></span><br><span class="line">            <span class="keyword">while</span> (!occupied.<span class="built_in">empty</span>() &amp;&amp; occupied.<span class="built_in">top</span>().first &lt;= st) &#123;</span><br><span class="line">                <span class="comment">// the occupied room&#x27;s meeting end time &lt;= m&#x27;s start time</span></span><br><span class="line">                free.<span class="built_in">push</span>(occupied.<span class="built_in">top</span>().second); <span class="comment">// push occupied.top()&#x27;s index to free</span></span><br><span class="line">                occupied.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (free.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="comment">// no available rooms</span></span><br><span class="line">                <span class="keyword">auto</span>[e, i] = occupied.<span class="built_in">top</span>();</span><br><span class="line">                occupied.<span class="built_in">pop</span>();</span><br><span class="line">                et += e - st; <span class="comment">// end time = end time + (new start time - start time)</span></span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                id = free.<span class="built_in">top</span>();</span><br><span class="line">                free.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ++count[id];</span><br><span class="line">            occupied.<span class="built_in">emplace</span>(et, id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// the number of the room that held the most meetings</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; count[res]) &#123;</span><br><span class="line">                res = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n + m * (logn + logm))</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>hash-table</tag>
        <tag>heap/priority-queue</tag>
        <tag>sorting</tag>
        <tag>simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 243 Shortest Word Distance</title>
    <url>/2024/03/04/LeetCode243/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/shortest-word-distance/">Shortest Word Distance - LeetCode</a></p>
</blockquote>
<p>Given an array of strings <code>wordsDict</code> and two different strings that already exist in the array <code>word1</code> and <code>word2</code>, return <em>the shortest distance between these two words in the list</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: wordsDict = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;], word1 = &quot;coding&quot;, word2 = &quot;practice&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: wordsDict = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;], word1 = &quot;makes&quot;, word2 = &quot;coding&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= wordsDict.length &lt;= 3 * 104</code></li>
<li><code>1 &lt;= wordsDict[i].length &lt;= 10</code></li>
<li><code>wordsDict[i]</code> consists of lowercase English letters.</li>
<li><code>word1</code> and <code>word2</code> are in <code>wordsDict</code>.</li>
<li><code>word1 != word2</code></li>
</ul>
<h2 id="thinkings">Thinkings</h2>
<p>遍历 <code>wordsDict</code> ，更新 <code>word1</code> 和 <code>word2</code> 在数组中的下标及当前最短距离.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestDistance</span><span class="params">(vector&lt;string&gt;&amp; wordsDict, string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = wordsDict.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = n;</span><br><span class="line">        <span class="type">int</span> word1Index = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> word2Index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordsDict[i] == word1) &#123;</span><br><span class="line">                word1Index = i;</span><br><span class="line">                <span class="keyword">if</span> (word2Index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(word2Index - word1Index));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (wordsDict[i] == word2) &#123;</span><br><span class="line">                word2Index = i;</span><br><span class="line">                <span class="keyword">if</span> (word1Index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(word2Index - word1Index));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="another-approach">Another approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestDistance</span><span class="params">(vector&lt;string&gt;&amp; wordsDict, string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx1 = -wordsDict.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> idx2 = -wordsDict.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ret = wordsDict.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wordsDict.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordsDict[i] == word1) &#123;</span><br><span class="line">                idx1 = i;</span><br><span class="line">                ret = <span class="built_in">min</span>(ret, idx1 - idx2);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wordsDict[i] == word2) &#123;</span><br><span class="line">                idx2 = i;</span><br><span class="line">                ret = <span class="built_in">min</span>(ret, idx2 - idx1);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Premium</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 244 Shortest Word Distance II</title>
    <url>/2024/03/05/LeetCode244/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/shortest-word-distance-ii/">Shortest Word Distance II - LeetCode</a></p>
</blockquote>
<p>Design a data structure that will be initialized with a string array, and then it should answer queries of the shortest distance between two different strings from the array.</p>
<p>Implement the <code>WordDistance</code> class:</p>
<ul>
<li><code>WordDistance(String[] wordsDict)</code> initializes the object with the strings array <code>wordsDict</code>.</li>
<li><code>int shortest(String word1, String word2)</code> returns the shortest distance between <code>word1</code> and <code>word2</code> in the array <code>wordsDict</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;WordDistance&quot;, &quot;shortest&quot;, &quot;shortest&quot;]</span><br><span class="line">[[[&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]], [&quot;coding&quot;, &quot;practice&quot;], [&quot;makes&quot;, &quot;coding&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null, 3, 1]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">WordDistance wordDistance = new WordDistance([&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]);</span><br><span class="line">wordDistance.shortest(&quot;coding&quot;, &quot;practice&quot;); // return 3</span><br><span class="line">wordDistance.shortest(&quot;makes&quot;, &quot;coding&quot;);    // return 1</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= wordsDict.length &lt;= 3 * 104</code></li>
<li><code>1 &lt;= wordsDict[i].length &lt;= 10</code></li>
<li><code>wordsDict[i]</code> consists of lowercase English letters.</li>
<li><code>word1</code> and <code>word2</code> are in <code>wordsDict</code>.</li>
<li><code>word1 != word2</code></li>
<li>At most <code>5000</code> calls will be made to <code>shortest</code>.</li>
</ul>
<h2 id="thinkings">Thinkings</h2>
<p>由于多次调用，不能跟<a href="https://xrose7.github.io/2024/03/04/LeetCode243/">LeetCode 243 Shortest Word Distance</a>一样使用蛮力求解，我们需要对数据进行预处理以减少时间浪费.</p>
<p>我们可以使用一个哈希表记录每个单词的下标列表.</p>
<p>为了计算最短距离，应根据 <span class="math inline">\(\textit{index}_1\)</span> 和 <span class="math inline">\(\textit{index}_2\)</span> 的大小关系执行相应的操作：</p>
<ul>
<li>如果 <span class="math inline">\(\textit{index}_1 &lt; \textit{index}_2\)</span>，则将 <span class="math inline">\(\textit{index}_1\)</span> 移动到下一个 <span class="math inline">\(\textit{word}_1\)</span> 的下标；</li>
<li>如果 <span class="math inline">\(\textit{index}_1 &gt; \textit{index}_2\)</span>，则将 <span class="math inline">\(\textit{index}_2\)</span> 移动到下一个 <span class="math inline">\(\textit{word}_2\)</span> 的下标。</li>
</ul>
<blockquote>
<p><a href="https://leetcode.cn/problems/shortest-word-distance-ii/solutions/1501483/zui-duan-dan-ci-ju-chi-ii-by-leetcode-so-no7m">最短单词距离 II - 力扣官方题解</a></p>
</blockquote>
<p>此外，还可以增加一个备忘录（也可以叫 Cache） <code>shortestDistanceMap</code> 以提高再次调用的速度.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDistance</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; wordsDict;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    unordered_map&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; indicesMap;</span><br><span class="line">    map&lt;pair&lt;string, string&gt;, <span class="type">int</span>&gt; shortestDistanceMap;</span><br><span class="line">    <span class="built_in">WordDistance</span>(vector&lt;string&gt;&amp; wordsDict) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;wordsDict = wordsDict;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len = wordsDict.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            indicesMap[wordsDict[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortest</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1 &gt; word2) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(word1, word2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shortestDistanceMap[&#123;word1, word2&#125;] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> shortestDistanceMap[&#123;word1, word2&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; indices1 = indicesMap[word1];</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; indices2 = indicesMap[word2];</span><br><span class="line">            <span class="type">int</span> len1 = indices1.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> len2 = indices2.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> dis = len;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class="line">                <span class="type">int</span> index1 = indices1[i];</span><br><span class="line">                <span class="type">int</span> index2 = indices2[j];</span><br><span class="line">                dis = <span class="built_in">min</span>(dis, <span class="built_in">abs</span>(index2 - index1));</span><br><span class="line">                <span class="keyword">if</span> (index1 &lt; index2) &#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            shortestDistanceMap[&#123;word1, word2&#125;] = dis;</span><br><span class="line">            <span class="keyword">return</span> dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDistance object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDistance* obj = new WordDistance(wordsDict);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;shortest(word1,word2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Premium</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>two-pointers</tag>
        <tag>hash-table</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2444 Count Subarrays With Fixed Bounds</title>
    <url>/2024/03/31/LeetCode2444/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/count-subarrays-with-fixed-bounds/">Count Subarrays With Fixed Bounds - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/solutions/1895713/jian-ji-xie-fa-pythonjavacgo-by-endlessc-gag2">简洁写法：一次遍历+O(1) 空间 - 灵茶山艾府</a></p>
<p>令人感叹的题解:(</p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> min_k, <span class="type">int</span> max_k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> min_i = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> max_i = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> i0 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (x == min_k) &#123;</span><br><span class="line">                min_i = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == max_k) &#123;</span><br><span class="line">                max_i = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; min_k || x &gt; max_k) &#123;</span><br><span class="line">                i0 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="built_in">min</span>(min_i, max_i) - i0, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>sliding-window</tag>
        <tag>queue</tag>
        <tag>monotonic-queue</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2485 Find the Pivot Integer</title>
    <url>/2024/03/13/LeetCode2485/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-the-pivot-integer/">Find the Pivot Integer - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>等差数列求和列等式解 <span class="math inline">\(x\)</span> .</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotInteger</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> x = <span class="built_in">sqrt</span>(n * (n + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">floor</span>(x) == <span class="built_in">ceil</span>(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">floor</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(1)</p>
<p>Space: O(1)</p>
<blockquote>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/floor">std::floor, std::floorf, std::floorl - cppreference</a></p>
<p>The <code>floor()</code> function in C++ returns the largest possible integer value which is less than or equal to the given argument.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/ceil">std::ceil, std::ceilf, std::ceill - cppreference</a></p>
<p>The <code>ceil()</code> function in C++ returns the smallest possible integer value which is greater than or equal to the given argument.</p>
</blockquote>
<h2 id="notes">Notes</h2>
<h3 id="prefix-sum-approach">Prefix-sum approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotInteger</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t == s - t - i) &#123;</span><br><span class="line">            	<span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            	t += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>math</tag>
        <tag>prefix-sum</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2529 Maximum Count of Positive Integer and Negative Integer</title>
    <url>/2024/04/09/LeetCode2529/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/">Maximum Count of Positive Integer and Negative Integer - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>这题直接遍历计数就行.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> neg = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ++neg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++zero;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(neg, n - neg - zero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="notes">Notes</h2>
<h3 id="binary-search-approach">Binary-search approach</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/2050916/mo-ni-by-endlesscheng-8e43">两种方法：遍历 / 二分查找 - 灵茶山艾府</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> neg = ranges::<span class="built_in">lower_bound</span>(nums, <span class="number">0</span>) - nums.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> pos = nums.<span class="built_in">end</span>() - ranges::<span class="built_in">upper_bound</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(neg, pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(logn)</p>
<p>Space: O(1)</p>
<h3 id="constrained-algorithms-since-c20">Constrained algorithms (since C++20)</h3>
<blockquote>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/ranges">Constrained algorithms (since C++20) - cppreference,com</a></p>
<p>C++20 provides <a href="https://en.cppreference.com/w/cpp/language/constraints">constrained</a> versions of most algorithms in the namespace <code>std::ranges</code>. In these algorithms, a range can be specified as either an <a href="https://en.cppreference.com/w/cpp/iterator/input_or_output_iterator">iterator</a>-<a href="https://en.cppreference.com/w/cpp/iterator/sentinel_for">sentinel</a> pair or as a single <a href="https://en.cppreference.com/w/cpp/ranges/range"><code>range</code></a> argument, and projections and pointer-to-member callables are supported. Additionally, the <a href="https://en.cppreference.com/w/cpp/algorithm/ranges#Return_types">return types</a> of most algorithms have been changed to return all potentially useful information computed during the execution of the algorithm.</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Binary search operations (on sorted ranges)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://en.cppreference.com/w/cpp/algorithm/ranges/lower_bound">ranges::lower_bound</a>(C++20)</td>
<td>returns an iterator to the first element <em>not less</em> than the given value (niebloid)</td>
</tr>
<tr class="even">
<td><a href="https://en.cppreference.com/w/cpp/algorithm/ranges/upper_bound">ranges::upper_bound</a>(C++20)</td>
<td>returns an iterator to the first element <em>greater</em> than a certain value (niebloid)</td>
</tr>
</tbody>
</table>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>counting</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2540 Minimum Common Value</title>
    <url>/2024/03/09/LeetCode2540/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-common-value/">Minimum Common Value - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>类似于归并排序的双指针遍历比较. 当然也可以直接用 hash-table 遍历两数组，最后得出结果.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCommon</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n + m)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="binary-search-approach">Binary search approach</h3>
<blockquote>
<p>由于两个数组都按升序排序，因此对于数组 <span class="math inline">\(\textit{nums}_1\)</span>中的每个元素 <span class="math inline">\(\textit{num}\)</span> ，可以使用二分查找判断 <span class="math inline">\(\textit{num}\)</span> 是否在数组 <span class="math inline">\(\textit{nums}_2\)</span> 中出现，在两个数组中都出现的最小元素即为答案。如果数组 <span class="math inline">\(\textit{nums}_1\)</span> 中的所有元素都不在数组 <span class="math inline">\(\textit{nums}_2\)</span> 中出现，则答案是 −1 .</p>
<p>由于两个数组都按升序排序，因此可以从左向右遍历数组 <span class="math inline">\(\textit{nums}_1\)</span> 中的每个元素，找到的第一个在两个数组中都出现的元素即为答案.</p>
<p>作者：Storm 链接：https://leetcode.cn/problems/minimum-common-value/solutions/2584484/2540-zui-xiao-gong-gong-zhi-by-stormsuns-d9z4/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCommon</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">binarySearch</span>(nums2, num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">boolean <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mlogn)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>two-pointers</tag>
        <tag>hash-table</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2575 Find the Divisibility Array of a String</title>
    <url>/2024/03/07/LeetCode2575/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-the-divisibility-array-of-a-string/">Find the Divisibility Array of a String - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/solutions/2668264/zhao-chu-zi-fu-chuan-de-ke-zheng-chu-shu-pv8v">找出字符串的可整除数组 - 力扣官方题解</a></p>
<p>我们可以将主要问题抽象为计算 <span class="math inline">\(a \; \text{mod} \; m\)</span> 以及 <span class="math inline">\((a \times 10 + b) \; \text{mod} \; m\)</span> ，而 <span class="math display">\[
(a \times 10 + b) \; \text{mod} \; m = (a \; \text{mod} \; m \times 10 + b) \; \text{mod} \; m
\]</span> 由此递推式可解.</p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">divisibilityArray</span><span class="params">(string word, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; c : word) &#123;</span><br><span class="line">            cur = (cur * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>)) % m;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1) 不计算返回结果</p>
<h2 id="notes">Notes</h2>
<h3 id="quick-multiply-approach">Quick multiply approach</h3>
<blockquote>
<p>可先参阅：</p>
<p><a href="https://oi-wiki.org/math/binary-exponentiation/">快速幂 - OI Wiki</a></p>
</blockquote>
<p>数据直接乘 <code>10</code> 可能会爆 <code>int</code> ，要是不想爆，可以将乘法改成加法，同时每一步都 <code>mod m</code> . 而加法还可以使用<strong>快速乘</strong>算法，将被乘数写成二进制形式，再用乘法分配律将其写成加法形式.</p>
<p>快速乘会比普通的循环加法快一些，但花费时间还是比直接使用 <code>long long</code> 类型多.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">divisibilityArray</span><span class="params">(string word, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; c : word) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = cur;</span><br><span class="line">            <span class="comment">// quick multiply: &#x27;cur = (cur * 10) % m&#x27; =&gt; &#x27;cur = (cur * 2^3 + cur * 2^1) % m&#x27;</span></span><br><span class="line">            <span class="type">int</span> k = <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    add = (add + cur) % m;</span><br><span class="line">                &#125;</span><br><span class="line">                k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                cur = (cur + cur) % m;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = add;</span><br><span class="line">            <span class="comment">// for (int i = 0; i &lt; 9; ++i) &#123;</span></span><br><span class="line">            <span class="comment">//     // calculate &#x27;(cur * 10) % m&#x27;</span></span><br><span class="line">            <span class="comment">//     cur = (cur + tmp) % m;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            cur = (cur + (c - <span class="string">&#x27;0&#x27;</span>)) % m;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1) 不计算返回结果.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>math</tag>
        <tag>bit-manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 245 Shortest Word Distance III</title>
    <url>/2024/03/16/LeetCode245/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/shortest-word-distance-iii/">Shortest Word Distance III - LeetCode</a></p>
</blockquote>
<p>Given an array of strings <code>wordsDict</code> and two strings that already exist in the array <code>word1</code> and <code>word2</code>, return <em>the shortest distance between the occurrence of these two words in the list</em>.</p>
<p><strong>Note</strong> that <code>word1</code> and <code>word2</code> may be the same. It is guaranteed that they represent <strong>two individual words</strong> in the list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: wordsDict = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;], word1 = &quot;makes&quot;, word2 = &quot;coding&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: wordsDict = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;], word1 = &quot;makes&quot;, word2 = &quot;makes&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= wordsDict.length &lt;= 105</code></li>
<li><code>1 &lt;= wordsDict[i].length &lt;= 10</code></li>
<li><code>wordsDict[i]</code> consists of lowercase English letters.</li>
<li><code>word1</code> and <code>word2</code> are in <code>wordsDict</code>.</li>
</ul>
<h2 id="thinkings">Thinkings</h2>
<p>维护两个指针分别指向遍历过程中遇到的 word1 和 word2 ，并随时更新最短距离. 当 word1 和 word2 相同时，用 pre 指针指向前一个 word1 ，并随时更新最短距离.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestWordDistance</span><span class="params">(vector&lt;string&gt;&amp; wordsDict, string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = wordsDict.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = n;</span><br><span class="line">        <span class="keyword">if</span> (word1 == word2) &#123;</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (wordsDict[i] == word1) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pre &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        res = <span class="built_in">min</span>(res, i - pre);</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> index1 = <span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> index2 = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (wordsDict[i] == word1) &#123;</span><br><span class="line">                    index1 = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (wordsDict[i] == word2) &#123;</span><br><span class="line">                    index2 = i;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index1 &gt;= <span class="number">0</span> &amp;&amp; index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(index2 - index1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Premium</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2580 Count Ways to Group Overlapping Ranges</title>
    <url>/2024/03/27/LeetCode2580/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/count-ways-to-group-overlapping-ranges/">Count Ways to Group Overlapping Ranges - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/solutions/2706464/tong-ji-jiang-zhong-die-qu-jian-he-bing-be3bs">统计将重叠区间合并成组的方案数 - 力扣官方题解</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countWays</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ranges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(ranges.<span class="built_in">begin</span>(), ranges.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = ranges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> r = ranges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; ranges[j][<span class="number">0</span>] &lt;= r) &#123;</span><br><span class="line">                r = <span class="built_in">max</span>(r, ranges[j][<span class="number">1</span>]);</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">2</span> % MOD;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(logn)</p>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/solutions/2147717/tiao-yue-you-xi-bian-xing-by-endlesschen-hatn">合并区间，附题单 - 灵茶山艾府</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2617 Minimum Number of Visited Cells in a Grid</title>
    <url>/2024/03/22/LeetCode2617/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-number-of-visited-cells-in-a-grid/">Minimum Number of Visited Cells in a Grid - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/solutions/2216329/dan-diao-zhan-you-hua-dp-by-endlesscheng-mc50">两种方法：单调栈优化 DP / 贪心+最小堆 - 灵茶山艾府</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumVisitedCells</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>(), mn;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">col_stacks</span>(n); <span class="comment">// 每列的单调栈</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; row_st; <span class="comment">// 行单调栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            row_st.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">int</span> g = grid[i][j];</span><br><span class="line">                <span class="keyword">auto</span> &amp;col_st = col_stacks[j];</span><br><span class="line">                mn = i &lt; m - <span class="number">1</span> || j &lt; n - <span class="number">1</span> ? INT_MAX : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (g) &#123; <span class="comment">// 可以向右/向下跳</span></span><br><span class="line">                    <span class="comment">// 在单调栈上二分查找最优转移来源</span></span><br><span class="line">                    <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(row_st.<span class="built_in">begin</span>(), row_st.<span class="built_in">end</span>(), j + g, [](<span class="type">const</span> <span class="keyword">auto</span> &amp;a, <span class="type">const</span> <span class="type">int</span> b) &#123;</span><br><span class="line">                        <span class="keyword">return</span> a.second &gt; b;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">if</span> (it &lt; row_st.<span class="built_in">end</span>()) mn = it-&gt;first + <span class="number">1</span>;</span><br><span class="line">                    it = <span class="built_in">lower_bound</span>(col_st.<span class="built_in">begin</span>(), col_st.<span class="built_in">end</span>(), i + g, [](<span class="type">const</span> <span class="keyword">auto</span> &amp;a, <span class="type">const</span> <span class="type">int</span> b) &#123;</span><br><span class="line">                        <span class="keyword">return</span> a.second &gt; b;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">if</span> (it &lt; col_st.<span class="built_in">end</span>()) mn = <span class="built_in">min</span>(mn, it-&gt;first + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mn &lt; INT_MAX) &#123;</span><br><span class="line">                    <span class="comment">// 插入单调栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!row_st.<span class="built_in">empty</span>() &amp;&amp; mn &lt;= row_st.<span class="built_in">back</span>().first) &#123;</span><br><span class="line">                        row_st.<span class="built_in">pop_back</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    row_st.<span class="built_in">emplace_back</span>(mn, j);</span><br><span class="line">                    <span class="keyword">while</span> (!col_st.<span class="built_in">empty</span>() &amp;&amp; mn &lt;= col_st.<span class="built_in">back</span>().first) &#123;</span><br><span class="line">                        col_st.<span class="built_in">pop_back</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    col_st.<span class="built_in">emplace_back</span>(mn, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mn &lt; INT_MAX ? mn : <span class="number">-1</span>; <span class="comment">// 最后一个算出的 mn 就是 f[0][0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mn(logm + logn))</p>
<p>Space: O(mn)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>breadth-first-search</tag>
        <tag>dynamic-programming</tag>
        <tag>stack</tag>
        <tag>matrix</tag>
        <tag>monotonic-stack</tag>
        <tag>union-find</tag>
        <tag>heap/priority-heap</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 26 Remove Duplicates from Sorted Array</title>
    <url>/2024/01/11/LeetCode26/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">Remove Duplicates from Sorted Array - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>简单的重构数组</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>; <span class="comment">// k is the end index of new nums</span></span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[k] = nums[i];</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - k; ++i) &#123;</span><br><span class="line">            nums.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>top-interview-150</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>top-interview-150</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2642 Design Graph With Shortest Path Calculator</title>
    <url>/2024/03/26/LeetCode2642/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/design-graph-with-shortest-path-calculator/">Design Graph With Shortest Path Calculator - LeetCode</a></p>
</blockquote>
<p>自己实现 dijkstra 还是有点困难··</p>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://oi-wiki.org/graph/shortest-path/">最短路 - OI Wiki</a></p>
<p><a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/solutions/2701377/she-ji-ke-yi-qiu-zui-duan-lu-jing-de-tu-hj8e9">设计可以求最短路径的图类 - 力扣官方题解</a></p>
<p><a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/solutions/2229013/dijkstra-suan-fa-mo-ban-pythonjavacgo-by-unmv">两种方法：Dijkstra / Floyd，附题单 - 灵茶山艾府</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; g; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges) : <span class="built_in">g</span>(n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            g[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>], e[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; e)</span> </span>&#123;</span><br><span class="line">        g[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>], e[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dis[i] 表示从起点 start 出发，到节点 i 的最短路长度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(g.size(), INT_MAX)</span></span>;</span><br><span class="line">        dis[start] = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(<span class="number">0</span>, start);</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [d, x] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (x == end) &#123; <span class="comment">// 计算出从起点到终点的最短路长度</span></span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (d &gt; dis[x]) &#123; <span class="comment">// x 之前出堆过，无需更新邻居的最短路</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[y, w] : g[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d + w &lt; dis[y]) &#123;</span><br><span class="line">                    dis[y] = d + w; <span class="comment">// 更新最短路长度</span></span><br><span class="line">                    pq.<span class="built_in">push</span>(&#123;dis[y], y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 无法到达终点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^3)</p>
<ul>
<li>constructor: O(n^3)</li>
<li>addEdge: O(n^2)</li>
<li>shortestPath: O(1)</li>
</ul>
<p>Space: O(n^2)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>design</tag>
        <tag>heap/priority-queue</tag>
        <tag>graph</tag>
        <tag>shortest-path</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2663 Lexicographically Smallest Beautiful String</title>
    <url>/2024/06/22/LeetCode2663/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/lexicographically-smallest-beautiful-string/">Lexicographically Smallest Beautiful String - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/solutions/2251229/tan-xin-pythonjavacgo-by-endlesscheng-yix5">贪心 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestBeautifulString</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k += <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> i = n - <span class="number">1</span>; <span class="comment">// 从最后一个字母开始</span></span><br><span class="line">        s[i]++; <span class="comment">// 先加一</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == k) &#123; <span class="comment">// 需要进位</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 无法进位</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 进位</span></span><br><span class="line">                s[i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                s[--i]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &amp;&amp; s[i] == s[i - <span class="number">1</span>] || i &gt; <span class="number">1</span> &amp;&amp; s[i] == s[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                s[i]++; <span class="comment">// 如果 s[i] 和左侧的字符形成回文串，就继续增加 s[i]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++; <span class="comment">// 反过来检查后面是否有回文串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2671 Frequency Tracker</title>
    <url>/2024/03/20/LeetCode2671/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/frequency-tracker/">Frequency Tracker - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/frequency-tracker/solutions/2260092/shuang-ha-xi-biao-o1-zuo-fa-pythonjavacg-jo68">双哈希表 - 灵茶山艾府</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FrequencyTracker</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FrequencyTracker</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        --freq[cnt[number]];</span><br><span class="line">        ++freq[++cnt[number]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteOne</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cnt[number]) <span class="keyword">return</span>;</span><br><span class="line">        --freq[cnt[number]];</span><br><span class="line">        ++freq[--cnt[number]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasFrequency</span><span class="params">(<span class="type">int</span> frequency)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> freq[frequency];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FrequencyTracker object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FrequencyTracker* obj = new FrequencyTracker();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(number);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteOne(number);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;hasFrequency(frequency);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Time: O(1)</p>
<p>Space: O(q)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>hash-table</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 268 Missing Number</title>
    <url>/2024/02/20/LeetCode268/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/missing-number/description/">Missing Number - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一眼排序预处理再遍历，找不连续的数字. 当然也可以直接遍历维护一个记录频次的 hash map ，输出频次为 0 的数字.</p>
<p>在看了眼 <strong>Follow up</strong>之后，恍然大悟这题完全可以做一个累加求减找缺失的值.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res -= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="xor-approach">XOR approach</h3>
<ul>
<li>a number XOR itself will become 0</li>
<li>any number XOR with 0 will stay unchanged</li>
</ul>
<blockquote>
<p>So if every number from 1...n XOR with itself except the missing number, the result will be the missing number.</p>
<p>Example:</p>
<p>[0, 1, 2] missing 3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 ^ 0</span><br><span class="line">^ 1 ^ 1</span><br><span class="line">^ 2 ^ 2</span><br><span class="line">^ 3</span><br><span class="line"></span><br><span class="line">=</span><br><span class="line"></span><br><span class="line">0 ^ 0 ^ 0 ^ 3 = 3</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://leetcode.com/problems/missing-number/solutions/69786/3-different-ideas-xor-sum-binary-search-java-code">3 different ideas: XOR, SUM, Binary Search. Java code - LeetCode</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res ^= i;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h3 id="binary-search-approach">Binary search approach</h3>
<p><a href="https://leetcode.com/problems/missing-number/solutions/69786/3-different-ideas-xor-sum-binary-search-java-code">3 different ideas: XOR, SUM, Binary Search. Java code - LeetCode</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> </span>&#123; <span class="comment">//binary search</span></span><br><span class="line">    Arrays.<span class="built_in">sort</span>(nums);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.length, mid= (left + right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;mid) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = n;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">			m = (l + r) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (nums[m] &gt; m) &#123;</span><br><span class="line">				r = m;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				l = m + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>hash-table</tag>
        <tag>math</tag>
        <tag>sorting</tag>
        <tag>binary-search</tag>
        <tag>bit-manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2684 Maximum Number of Moves in a Grid</title>
    <url>/2024/03/16/LeetCode2684/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/">Maximum Number of Moves in a Grid - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一眼动态规划.</p>
<p>用 <code>dp[i][j]</code> 存储从 <code>(i, j)</code> 格子开始的最大移动次数.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxMoves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j + <span class="number">1</span>] &gt; grid[i][j]) &#123;</span><br><span class="line">                    tmp = <span class="built_in">max</span>(tmp, dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; grid[i + <span class="number">1</span>][j + <span class="number">1</span>] &gt; grid[i][j]) &#123;</span><br><span class="line">                    tmp = <span class="built_in">max</span>(tmp, dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j + <span class="number">1</span>] &gt; grid[i][j]) &#123;</span><br><span class="line">                    tmp = <span class="built_in">max</span>(tmp, dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mn)</p>
<p>Space: O(mn)</p>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/solutions/2269244/cong-ji-yi-hua-sou-suo-dao-di-tui-by-end-pgq3">两种方法：DFS / BFS - 灵茶山艾府</a></p>
<p>空间优化的BFS：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxMoves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row: grid) &#123;</span><br><span class="line">            row[<span class="number">0</span>] *= <span class="number">-1</span>; <span class="comment">// 入队标记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] &gt; <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 不在队列中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="built_in">max</span>(i - <span class="number">1</span>, <span class="number">0</span>); k &lt; <span class="built_in">min</span>(i + <span class="number">2</span>, m); k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[k][j + <span class="number">1</span>] &gt; -grid[i][j]) &#123;</span><br><span class="line">                        grid[k][j + <span class="number">1</span>] *= <span class="number">-1</span>; <span class="comment">// 入队标记</span></span><br><span class="line">                        ok = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ok) &#123; <span class="comment">// 无法再往右走了</span></span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mn)</p>
<p>Space: O(1)</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>dynamic-programming</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 27 Remove Element</title>
    <url>/2024/01/09/LeetCode27/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/remove-element/description/">Remove Element - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>简单的 <code>std::vector::iterator</code> 及 <code>std::vector::erase</code> 的应用.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;::iterator iter1 = nums.<span class="built_in">begin</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;::iterator iter2 = nums.<span class="built_in">end</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter1 != iter2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*iter1 != val) &#123;</span><br><span class="line">                ++iter1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums.<span class="built_in">erase</span>(iter1);</span><br><span class="line">                iter1 = nums.<span class="built_in">begin</span>();</span><br><span class="line">                iter2 = nums.<span class="built_in">end</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="notes">Notes</h2>
<p>iterator 用法与 pointer 类似.</p>
<p><a href="https://en.cppreference.com/w/cpp/container/vector">std::vector - cppreference.com</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/vector/erase">std::vector::erase - cppreference.com</a></p>
<h3 id="another-approach">Another Approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>top-interview-150</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>top-interview-150</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2709 Greatest Common Divisor Traversal</title>
    <url>/2024/02/25/LeetCode2709/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/greatest-common-divisor-traversal/description/">Greatest Common Divisor Traversal - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>题解都看不太明白:) 过两天再回顾完善一下好了</p>
<h2 id="union-find-approach">Union find approach</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> lpf[N];  <span class="comment">// lpf[x]表示x元素的最小质因子，注意1不是质数也不是质因子</span></span><br><span class="line">    <span class="type">int</span> p[N * <span class="number">2</span>]; </span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到每个数的最小质因子</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lpf[i]) &#123;</span><br><span class="line">                lpf[i] = i; <span class="comment">// 质数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= x / i; j++) &#123;</span><br><span class="line">                    <span class="comment">// 这里必须是还没初始化过，不然的话比如10，会先被2筛，在被5筛</span></span><br><span class="line">                    <span class="keyword">if</span> (!lpf[j * i]) &#123;</span><br><span class="line">                        lpf[j * i] = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">get</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">get</span>(a), pb = <span class="built_in">get</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (pa != pb) &#123;</span><br><span class="line">            p[pa] = pb; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canTraverseAllPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ma = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">init</span>(ma + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化并查集, 并查集一共有 ：质因子最大值 + n个下标点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + ma + <span class="number">1</span>; i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 把nums[i]和它所有的质因子连边</span></span><br><span class="line">            <span class="type">int</span> t = nums[i];</span><br><span class="line">            <span class="keyword">while</span> (t &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> x = lpf[t];</span><br><span class="line">              	<span class="built_in">merge</span>(i, n + x);</span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 一直除以最小质因子</span></span><br><span class="line">                <span class="keyword">while</span> (x == lpf[t]) t /= x;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// // 判断每个数的是否都相连, 只用判断是否每个数都和0在一个集合中即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get</span>(i) != <span class="built_in">get</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="another-solution">Another solution</h2>
<blockquote>
<p><a href="https://leetcode.com/problems/greatest-common-divisor-traversal/solutions/4778225/eratosthenes-sieve-common-factor-dfs-union-find-55ms-beats-100/?envType=daily-question&amp;envId=2024-02-25">Eratosthenes' Sieve-&gt;common factor+DFS|Union Find||55ms Beats 100% - anwendeng</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;O3&quot;</span>, <span class="string">&quot;unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; root, size;</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) : <span class="built_in">root</span>(n), <span class="built_in">size</span>(n) &#123;</span><br><span class="line">        size.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">iota</span>(root.<span class="built_in">begin</span>(), root.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == root[x]) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root[x] = <span class="built_in">Find</span>(root[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rX = <span class="built_in">Find</span>(x), rY = <span class="built_in">Find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (rX == rY)  <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (size[rX] &gt; size[rY]) <span class="built_in">swap</span>(rX, rY);   </span><br><span class="line">        root[rX] = rY;</span><br><span class="line">        size[rY] += size[rX];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Find</span>(x) == <span class="built_in">Find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//Useful for removal</span></span><br><span class="line">        root[x]=x;</span><br><span class="line">        size[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; num_state;</span><br><span class="line"></span><br><span class="line">    bitset&lt;100001&gt; sieved=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Sieve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">//TC: O(n log log n)</span></span><br><span class="line">        sieved[<span class="number">0</span>]=sieved[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>&amp;&amp; n_sqrt=<span class="built_in">int</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n_sqrt; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!sieved[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i*i ; j&lt;=n; j+=i)</span><br><span class="line">                    sieved[j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prime.<span class="built_in">reserve</span>((<span class="type">int</span>)<span class="built_in">log</span>(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!sieved[i]) prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Different from the one for DFS</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build_commonFactor_path</span><span class="params">(<span class="keyword">auto</span>&amp; nums, <span class="type">int</span> M, UnionFind&amp; graph)</span> </span>&#123;</span><br><span class="line">        num_state.<span class="built_in">assign</span>(M+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums)</span><br><span class="line">            num_state[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : prime) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = p*<span class="number">2</span>; i &lt;= M; i += p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num_state[i]==<span class="number">1</span>) &#123;</span><br><span class="line">                    graph.<span class="built_in">Union</span>(i, p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canTraverseAllPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> M=*<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> sqrtM=<span class="built_in">sqrt</span>(M);</span><br><span class="line">        <span class="built_in">Sieve</span>(M);</span><br><span class="line">        bitset&lt;100001&gt; S=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x==<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            S[x]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=M; i++)</span><br><span class="line">            <span class="keyword">if</span>(S[i]) nums.<span class="built_in">push_back</span>(i);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>(), sz=<span class="number">0</span>;</span><br><span class="line">        <span class="function">UnionFind <span class="title">graph</span><span class="params">(M+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">build_commonFactor_path</span>(nums, M, graph);</span><br><span class="line">        <span class="type">int</span> x0=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!graph.<span class="built_in">connected</span>(x0, nums[i])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="eratosthenes-sieve">Eratosthenes' Sieve</h2>
<blockquote>
<p>TODO</p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/YZcheng_plus/article/details/129467828">埃氏筛法与欧拉筛（超级详解）-CSDN博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>math</tag>
        <tag>number-theory</tag>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2710 Remove Trailing Zeros From a String</title>
    <url>/2024/06/29/LeetCode2710/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/remove-trailing-zeros-from-a-string/">Remove Trailing Zeros From a String - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/remove-trailing-zeros-from-a-string/solutions/2287429/ku-han-shu-xie-fa-pythonjavacgo-by-endle-fjmr">库函数写法 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeTrailingZeros</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + <span class="number">1</span> + s.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27;0&#x27;</span>), s.<span class="built_in">end</span>()); <span class="comment">// 原地操作</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2713 Maximum Strictly Increasing Cells in a Matrix</title>
    <url>/2024/06/19/LeetCode2713/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/">Maximum Strictly Increasing Cells in a Matrix - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/solutions/2286920/dong-tai-gui-hua-you-hua-pythonjavacgo-b-axv0">动态规划+优化 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxIncreasingCells</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>(), n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        map&lt;<span class="type">int</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                g[mat[i][j]].<span class="built_in">emplace_back</span>(i, j); <span class="comment">// 相同元素放在同一组，统计位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row_max</span><span class="params">(m)</span>, <span class="title">col_max</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, pos] : g) &#123;</span><br><span class="line">            <span class="comment">// 先把所有 f 值都算出来，再更新 row_max 和 col_max</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; fs;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [i, j] : pos) &#123;</span><br><span class="line">                fs.<span class="built_in">push_back</span>(<span class="built_in">max</span>(row_max[i], col_max[j]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; pos.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; [i, j] = pos[k];</span><br><span class="line">                row_max[i] = <span class="built_in">max</span>(row_max[i], fs[k]); <span class="comment">// 更新第 i 行的最大 f 值</span></span><br><span class="line">                col_max[j] = <span class="built_in">max</span>(col_max[j], fs[k]); <span class="comment">// 更新第 j 列的最大 f 值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ranges::<span class="built_in">max</span>(row_max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mnlog(mn))</p>
<p>Space: O(mn)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>dynamic-programming</tag>
        <tag>hash-table</tag>
        <tag>ordered-set</tag>
        <tag>matrix</tag>
        <tag>sorting</tag>
        <tag>binary-search</tag>
        <tag>memoization</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2734 Lexicographically Smallest String After Substring Operation</title>
    <url>/2024/06/27/LeetCode2734/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/lexicographically-smallest-string-after-substring-operation/">Lexicographically Smallest String After Substring Operation - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/lexicographically-smallest-string-after-substring-operation/solutions/2304936/tan-xin-pythonjavacgo-by-endlesscheng-gm1d">贪心 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt; <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (; i &lt; n &amp;&amp; s[i] &gt; <span class="string">&#x27;a&#x27;</span>; i++) &#123;</span><br><span class="line">                    s[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">back</span>() = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2732 Find a Good Subset of the Matrix</title>
    <url>/2024/06/25/LeetCode2732/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-a-good-subset-of-the-matrix/">Find a Good Subset of the Matrix - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/find-a-good-subset-of-the-matrix/solutions/2305490/xiang-xi-fen-xi-wei-shi-yao-zhi-duo-kao-mbl6a">严格证明+三种计算方法 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">goodSubsetofBinaryMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mask_to_idx</span><span class="params">(<span class="number">1</span> &lt;&lt; n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> u = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                mask |= grid[i][j] &lt;&lt; j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mask == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mask_to_idx[mask] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 之前判断过，无需重复判断</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> c = u ^ mask; <span class="comment">// mask 的补集</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y = c; y; y = (y - <span class="number">1</span>) &amp; c) &#123;</span><br><span class="line">                <span class="type">int</span> j = mask_to_idx[y];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="built_in">min</span>(i, j), <span class="built_in">max</span>(i, j)&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mask_to_idx[mask] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mn + 3^n)</p>
<p>Space: O(2^n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>hash-table</tag>
        <tag>matrix</tag>
        <tag>bit-manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 274 H-Index</title>
    <url>/2024/02/01/LeetCode274/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/h-index/description/">H-Index - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>先排序预处理，再遍历寻找第一个 citations 大于或等于 n - i 的元素下标，若没找到即 i == n ，此时的 n - i 为 0 ，表明 citations 数组经过排序后的最后一个元素为 0 ，即 h-index 为 0 ; 若找到，则表明后面 n - i 个元素的引用数都大于或等于 n - i ，即 h-index 为 n - i .</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(citations.<span class="built_in">begin</span>(), citations.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = citations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; citations[i] &lt; n - i) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(logn)</p>
<blockquote>
<p>排序的空间复杂度</p>
</blockquote>
<h2 id="notes">Notes</h2>
<h3 id="counting-sort-approach">Counting sort approach</h3>
<blockquote>
<p>根据上述解法我们发现，最终的时间复杂度与排序算法的时间复杂度有关，所以我们可以使用计数排序算法，新建并维护一个数组 <span class="math inline">\(\textit{counter}\)</span> 用来记录当前引用次数的论文有几篇。</p>
<p>根据定义，我们可以发现 <span class="math inline">\(\text{H}\)</span> 指数不可能大于总的论文发表数，所以对于引用次数超过论文发表数的情况，我们可以将其按照总的论文发表数来计算即可。这样我们可以限制参与排序的数的大小为 <span class="math inline">\([0,n]\)</span>（其中 n 为总的论文发表数），使得计数排序的时间复杂度降低到 O(n) 。</p>
<p>最后我们可以从后向前遍历数组 <span class="math inline">\(\textit{counter}\)</span>，对于每个 <span class="math inline">\(0 \le i \le n\)</span>，在数组 <span class="math inline">\(\textit{counter}\)</span> 中得到大于或等于当前引用次数 <span class="math inline">\(i\)</span> 的总论文数。当我们找到一个 <span class="math inline">\(\text{H}\)</span> 指数时跳出循环，并返回结果。</p>
<p>作者：力扣官方题解 链接：https://leetcode.cn/problems/h-index/solutions/869042/h-zhi-shu-by-leetcode-solution-fnhl/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = citations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>; <span class="comment">// the number of papers cited more than i times, i is the index</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// the number of papers cited i times, i is the index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (citations[i] &gt;= n) &#123;</span><br><span class="line">                counter[n]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counter[citations[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tot += counter[i];</span><br><span class="line">            <span class="keyword">if</span> (tot &gt;= i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h3 id="binary-search-approach">Binary search approach</h3>
<blockquote>
<p>我们需要找到一个值 h，它是满足「有 h 篇论文的引用次数至少为 h」的最大值。小于等于 h 的所有值 x 都满足这个性质，而大于 h 的值都不满足这个性质。同时因为我们可以用较短时间（扫描一遍数组的时间复杂度为 O(n)，其中 n 为数组 <span class="math inline">\(\textit{citations}\)</span> 的长度）来判断 x 是否满足这个性质，所以这个问题可以用二分搜索来解决。</p>
<p>设查找范围的初始左边界 left 为 0，初始右边界 right 为 n。每次在查找范围内取中点 mid，同时扫描整个数组，判断是否至少有 mid 个数大于 mid。如果有，说明要寻找的 h 在搜索区间的右边，反之则在左边。</p>
<p>作者：力扣官方题解 链接：https://leetcode.cn/problems/h-index/solutions/869042/h-zhi-shu-by-leetcode-solution-fnhl/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = citations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// +1 防止死循环</span></span><br><span class="line">            mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; citations.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (citations[i] &gt;= mid) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= mid) &#123;</span><br><span class="line">                <span class="comment">// 要找的答案在 [mid,right] 区间内</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 要找的答案在 [0,mid) 区间内</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>sorting</tag>
        <tag>binary-search</tag>
        <tag>counting-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2742 Painting the Walls</title>
    <url>/2024/06/28/LeetCode2742/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.cn/problems/painting-the-walls/">Painting the Walls - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/painting-the-walls/solutions/2312808/xuan-huo-bu-xuan-de-dian-xing-si-lu-by-e-ulcd">两种方法：状态优化 / 转换成 0-1 背包 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">paintWalls</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cost, vector&lt;<span class="type">int</span>&gt; &amp;time)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, INT_MAX / <span class="number">2</span>)</span></span>; <span class="comment">// 防止加法溢出</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = cost[i], t = time[i] + <span class="number">1</span>; <span class="comment">// 注意这里加一了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j; j--) &#123;</span><br><span class="line">                f[j] = <span class="built_in">min</span>(f[j], f[<span class="built_in">max</span>(j - t, <span class="number">0</span>)] + c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^2)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2741 Special Permutations</title>
    <url>/2024/06/26/LeetCode2741/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/special-permutations/">Special Permutations - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/special-permutations/solutions/2312798/zhuang-ya-dp-by-endlesscheng-4jkr">状压 DP：排列型 ② 相邻相关 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">specialPerm</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), u = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">memo</span>(u, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n, <span class="number">-1</span>)); <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> s, <span class="type">int</span> i) -&gt; <span class="type">long</span> <span class="type">long</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 找到一个特别排列</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span>&amp; res = memo[s][i]; <span class="comment">// 注意这里是引用</span></span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((s &gt;&gt; j &amp; <span class="number">1</span>) &amp;&amp; (nums[i] % nums[j] == <span class="number">0</span> || nums[j] % nums[i] == <span class="number">0</span>)) &#123;</span><br><span class="line">                    res += <span class="built_in">dfs</span>(dfs, s ^ (<span class="number">1</span> &lt;&lt; j), j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(dfs, u ^ (<span class="number">1</span> &lt;&lt; i), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % <span class="number">1&#x27;000&#x27;000&#x27;007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: <span class="math inline">\(\text{O}(n^22^n)\)</span></p>
<p>Space: <span class="math inline">\(\text{O}(n2^n)\)</span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>dynamic-programming</tag>
        <tag>bit-manipulation</tag>
        <tag>bitmask</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2779 Maximum Beauty of an Array After Applying Operation</title>
    <url>/2024/06/15/LeetCode2779/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/">Maximum Beauty of an Array After Applying Operation - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/solutions/2345805/pai-xu-shuang-zhi-zhen-by-endlesscheng-hbqx">转换：排序+滑动窗口 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumBeauty</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(nums);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[right] - nums[left] &gt; k * <span class="number">2</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>sliding-window</tag>
        <tag>sorting</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2748 Number of Beautiful Pairs</title>
    <url>/2024/06/20/LeetCode2748/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/number-of-beautiful-pairs/">Number of Beautiful Pairs - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/number-of-beautiful-pairs/solutions/2319695/o10n-fei-bao-li-zuo-fa-by-endlesscheng-36eb">非暴力做法 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countBeautifulPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, cnt[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt; <span class="number">10</span>; y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[y] &amp;&amp; <span class="built_in">gcd</span>(y, x % <span class="number">10</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans += cnt[y];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (x &gt;= <span class="number">10</span>) &#123; </span><br><span class="line">                x /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[x]++; <span class="comment">// 统计最高位的出现次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n(k + logU))</p>
<p>Space: O(k)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>hash-table</tag>
        <tag>math</tag>
        <tag>counting</tag>
        <tag>number-theory</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2786 Visit Array Positions to Maximize Score</title>
    <url>/2024/06/14/LeetCode2786/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.cn/problems/visit-array-positions-to-maximize-score/">Visit Array Positions to Maximize Score - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/visit-array-positions-to-maximize-score/solutions/2810386/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-jhvr">一步步思考 DP：从记忆化搜索到递推到空间优化 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;array&lt;<span class="type">long</span> <span class="type">long</span>, 2&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> v = nums[i];</span><br><span class="line">            <span class="type">int</span> r = v % <span class="number">2</span>;</span><br><span class="line">            f[i][r ^ <span class="number">1</span>] = f[i + <span class="number">1</span>][r ^ <span class="number">1</span>];</span><br><span class="line">            f[i][r] = <span class="built_in">max</span>(f[i + <span class="number">1</span>][r], f[i + <span class="number">1</span>][r ^ <span class="number">1</span>] - x) + v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][nums[<span class="number">0</span>] % <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2789 Largest Element in an Array after Merge Operations</title>
    <url>/2024/03/14/LeetCode2789/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/largest-element-in-an-array-after-merge-operations/">Largest Element in an Array after Merge Operations - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>贪心策略，应从后往前操作合并数字，使后面的数字尽可能大于前面的数字.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxArrayValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// long long res = *(nums.end() - 1);</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = nums.<span class="built_in">back</span>();</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            res = (nums[i] &lt;= res) ? nums[i] + res : nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2806 Account Balance After Rounded Purchase</title>
    <url>/2024/06/12/LeetCode2806/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/account-balance-after-rounded-purchase/">Account Balance After Rounded Purchase - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>计算除数和余数即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">accountBalanceAfterPurchase</span><span class="params">(<span class="type">int</span> purchaseAmount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = purchaseAmount / <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> b = purchaseAmount % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span> - a * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span> - (a + <span class="number">1</span>) * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(1)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2813 Maximum Elegance of a K-Length Subsequence</title>
    <url>/2024/06/13/LeetCode2813/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.cn/problems/maximum-elegance-of-a-k-length-subsequence/">Maximum Elegance of a K-Length Subsequence - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/maximum-elegance-of-a-k-length-subsequence/solutions/2375128/fan-hui-tan-xin-pythonjavacgo-by-endless-v2w1">反悔贪心 - 灵茶山艾府</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">findMaximumElegance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; items, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把利润从大到小排序</span></span><br><span class="line">        ranges::<span class="built_in">sort</span>(items, [](<span class="type">const</span> <span class="keyword">auto</span> &amp;a, <span class="type">const</span> <span class="keyword">auto</span> &amp;b) &#123; <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]; &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>, total_profit = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; duplicate; <span class="comment">// 重复类别的利润</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; items.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> profit = items[i][<span class="number">0</span>], category = items[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">                total_profit += profit; <span class="comment">// 累加前 k 个项目的利润</span></span><br><span class="line">                <span class="keyword">if</span> (!vis.<span class="built_in">insert</span>(category).second) &#123; <span class="comment">// 重复类别</span></span><br><span class="line">                    duplicate.<span class="built_in">push</span>(profit);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!duplicate.<span class="built_in">empty</span>() &amp;&amp; vis.<span class="built_in">insert</span>(category).second) &#123; <span class="comment">// 之前没有的类别</span></span><br><span class="line">                total_profit += profit - duplicate.<span class="built_in">top</span>(); <span class="comment">// 选一个重复类别中的最小利润替换</span></span><br><span class="line">                duplicate.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="comment">// else：比前面的利润小，而且类别还重复了，选它只会让 total_profit 变小，vis.size() 不变，优雅度不会变大</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, total_profit + (<span class="type">long</span> <span class="type">long</span>) vis.<span class="built_in">size</span>() * (<span class="type">long</span> <span class="type">long</span>) vis.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>hash-table</tag>
        <tag>stack</tag>
        <tag>greedy</tag>
        <tag>heap/priority-queue</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 283 Move Zeroes</title>
    <url>/2024/01/19/LeetCode283/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/move-zeroes/description/">Move Zeroes - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>使用 j 作为数组的新下标，遍历数组更新以 j 为下标的新数组.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for (int num : nums) &#123;</span></span><br><span class="line">        <span class="comment">//     if (num != 0) &#123;</span></span><br><span class="line">        <span class="comment">//         nums[j++] = num;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; len) &#123;</span><br><span class="line">            nums[j++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>这里的 for-each 比 for 慢了一点.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>two-pointers</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-75</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2810 Faulty Keyboard</title>
    <url>/2024/04/01/LeetCode2810/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/faulty-keyboard/">Faulty Keyboard - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>模拟. 我直接用标准库里的 <code>reverse()</code> 函数了x</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">finalString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;i&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="dequeue-approach">Dequeue approach</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/faulty-keyboard/solutions/2375152/shuang-duan-dui-lie-on-zuo-fa-by-endless-5pe1">双端队列 O(n) 做法 - 灵茶山艾府</a></p>
<p>把反转看成是往字符串的头部添加字符</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">finalString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">char</span>&gt; q;</span><br><span class="line">        <span class="type">bool</span> tail = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;i&#x27;</span>) tail = !tail; <span class="comment">// 修改添加方向</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tail) q.<span class="built_in">push_back</span>(c); <span class="comment">// 加尾部</span></span><br><span class="line">            <span class="keyword">else</span> q.<span class="built_in">push_front</span>(c); <span class="comment">// 加头部</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail ? <span class="built_in">string</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>()) : <span class="built_in">string</span>(q.<span class="built_in">rbegin</span>(), q.<span class="built_in">rend</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2834 Find the Minimum Possible Sum of a Beautiful Array</title>
    <url>/2024/03/08/LeetCode2834/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-the-minimum-possible-sum-of-a-beautiful-array/">Find the Minimum Possible Sum of a Beautiful Array - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>贪心策略，又因为数据多，要同时考虑时间和空间. 时间方面直接用等差数列求和将 O(n) 降为 O(1) ，而空间要用 <code>long long</code> 储存数据.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumPossibleSum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> m = target &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span> <span class="type">long</span>) (<span class="number">1</span> + n) * n / <span class="number">2</span> % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> ((<span class="number">1</span> + m) * m / <span class="number">2</span> + (target + target + (n - m) - <span class="number">1</span>) * (n - m) / <span class="number">2</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(1)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>math</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2864 Maximum Odd Binary Number</title>
    <url>/2024/03/13/LeetCode2864/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-odd-binary-number/description/">Maximum Odd Binary Number - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>遍历 s ，统计 <code>1</code> 的个数，按顺序输出 <code>0</code> 和 <code>1</code> 即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">maximumOddBinaryNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            res += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - count; ++i) &#123;</span><br><span class="line">            res += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="another-approach">Another approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">maximumOddBinaryNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> one_count = <span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(one_count - <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>) + <span class="built_in">string</span>(n - one_count, <span class="string">&#x27;0&#x27;</span>) + <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">maximumOddBinaryNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">         <span class="function">string <span class="title">ans</span><span class="params">(s.size(), <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                ans[index++] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[--index] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ans[s.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>math</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 287 Find the Duplicate Number</title>
    <url>/2024/03/24/LeetCode287/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-the-duplicate-number/">Find the Duplicate Number - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/find-the-duplicate-number/solutions/58841/287xun-zhao-zhong-fu-shu-by-kirsche">287.寻找重复数 - Kirsche</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p2 = slow;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = nums[p1];</span><br><span class="line">            p2 = nums[p2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<blockquote>
<p><a href="https://blog.csdn.net/zwwhsxq/article/details/125707465">判断链表是否有环 及 寻找环的入口 - zwwhsxq</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/find-the-duplicate-number/solutions/261119/xun-zhao-zhong-fu-shu-by-leetcode-solution">寻找重复数 - 力扣官方题解</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>two-pointers</tag>
        <tag>binary-search</tag>
        <tag>bit-manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2908 Minimum Sum of Mountain Triplets I</title>
    <url>/2024/03/29/LeetCode2908/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-sum-of-mountain-triplets-i/">Minimum Sum of Mountain Triplets I - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>枚举遍历山峰，当然，要在维护各元素的前缀最小值和后缀最小值之后.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMin</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMin</span><span class="params">(n)</span></span>;</span><br><span class="line">        leftMin[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        rightMin[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            leftMin[i] = <span class="built_in">min</span>(leftMin[i - <span class="number">1</span>], nums[i]);</span><br><span class="line">            rightMin[n - <span class="number">1</span> - i] = <span class="built_in">min</span>(rightMin[n - i], nums[n - <span class="number">1</span> - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; leftMin[i] &amp;&amp; nums[i] &gt; rightMin[i]) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, nums[i] + leftMin[i] + rightMin[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/solutions/2493551/on-zuo-fa-mei-ju-numsjqian-hou-zhui-fen-xweo4">O(n) 前后缀分解，附题单 - 灵茶山艾府</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>prefix-sum</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2917 Find the K-or of an Array</title>
    <url>/2024/03/06/LeetCode2917/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-the-k-or-of-an-array/">Find the K-or of an Array - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>模拟即可，但是要注意位运算.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKOr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bitCount</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                bitCount[count++] += nums[i] &amp; <span class="number">1</span>;</span><br><span class="line">                nums[i] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitCount[i] &gt;= k) &#123;</span><br><span class="line">                <span class="comment">// res += pow(2, i);</span></span><br><span class="line">                res |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<p>按位遍历，可以优化 <code>vector&lt;int&gt;</code> 的空间.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKOr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((num &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= k) &#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>bit-manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2923 Find Champion I</title>
    <url>/2024/04/12/LeetCode2923/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-champion-i/">Find Champion I - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>递推找赢者，类似于打擂台（？</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findChampion</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][ans]) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2924 Find Champion II</title>
    <url>/2024/04/13/LeetCode2924/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-champion-ii/">Find Champion II - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/find-champion-ii/solutions/2513144/bu-zai-edgesi1-zhong-de-wei-yi-bian-hao-44ur6">不在 edges[i][1] 中的唯一编号 - 灵茶山艾府</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findChampion</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">is_weak</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            is_weak[e[<span class="number">1</span>]] = <span class="literal">true</span>; <span class="comment">// 不是冠军</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_weak[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 冠军只能有一个</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(m + n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 293 Flip Game</title>
    <url>/2024/02/02/LeetCode293/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/flip-game/description/">Flip Game - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>模拟遍历. 判断当前位置和下一个位置的字符是否都等于 "+"，如果是则变成 "-"，加入到结果中，再恢复原状继续向下遍历.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generatePossibleNextMoves</span><span class="params">(string currentState)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (currentState.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        string tmp = currentState;</span><br><span class="line">        <span class="keyword">for</span> (string::iterator it = tmp.<span class="built_in">begin</span>(); it != tmp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it == <span class="string">&#x27;+&#x27;</span> &amp;&amp; *(it + <span class="number">1</span>) == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                *it = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">                *(it + <span class="number">1</span>) = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp = currentState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="emplace_back-vs.-push_back"><code>emplace_back</code> vs. <code>push_back</code></h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/610294692">一文轻松搞懂emplace_back与push_back - 知乎 (zhihu.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2952 Minimum Number of Coins to be Added</title>
    <url>/2024/03/30/LeetCode2952/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-number-of-coins-to-be-added/">Minimum Number of Coins to be Added - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/solutions/2551707/yong-gui-na-fa-si-kao-pythonjavacgo-by-e-8etj">用归纳法思考 - 灵茶山艾府</a></p>
</blockquote>
<p>贪心区间合并</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumAddedCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(coins.<span class="built_in">begin</span>(), coins.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">1</span>; <span class="comment">// [0, s - 1] is available</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s &lt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; coins.<span class="built_in">size</span>() &amp;&amp; coins[i] &lt;= s) &#123;</span><br><span class="line">                s += coins[i++]; <span class="comment">// merge [0, s - 1] &amp; [coins[i], s - 1 + coins[i]]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s *= <span class="number">2</span>; <span class="comment">// have to add a coin valued &#x27;s&#x27;</span></span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn + log(target))</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>greedy</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2958 Length of Longest Subarray With at Most K Frequency</title>
    <url>/2024/03/28/LeetCode2958/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/length-of-longest-subarray-with-at-most-k-frequency/">Length of Longest Subarray With at Most K Frequency - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>嗨呀终于有一道不用直接看题解了x（其实是因为跟昨天差不多xd</p>
<p>定义滑动窗口左右指针，固定右指针滑动左指针以寻找满足条件的窗口，再逐步向右移动右指针循环往复.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubarrayLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            ++freq[nums[r]];</span><br><span class="line">            <span class="keyword">while</span> (freq[nums[r]] &gt; k) &#123;</span><br><span class="line">                --freq[nums[l++]];</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, r - l + <span class="number">1</span>);</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>sliding-window</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2962 Count Subarrays Where Max Element Appears at Least K Times</title>
    <url>/2024/03/29/LeetCode2962/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/count-subarrays-where-max-element-appears-at-least-k-times/">Count Subarrays Where Max Element Appears at Least K Times - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>滑动窗口. 固定右边界，滑动左边界找到满足条件的最小窗口，该最小窗口任意向左扩展到数组边界的窗口都满足条件. 接着不断右移右边界，循环往复.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxE = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; maxE) &#123;</span><br><span class="line">                maxE = nums[j];</span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[j] == maxE) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count &gt;= k &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == maxE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    --count;</span><br><span class="line">                &#125;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= k) &#123;</span><br><span class="line">                res += i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="more-elegant-approach">More elegant approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mx = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt_mx = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            cnt_mx += x == mx;</span><br><span class="line">            <span class="keyword">while</span> (cnt_mx == k) &#123;</span><br><span class="line">                cnt_mx -= nums[left++] == mx;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<blockquote>
<p><a href="https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/solutions/2560940/hua-dong-chuang-kou-fu-ti-dan-pythonjava-xvwg">滑动窗口（附题单！） - 灵茶山艾府</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2966 Divide Array Into Arrays With Max Difference</title>
    <url>/2024/02/01/LeetCode2966/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/divide-array-into-arrays-with-max-difference/description/">Divide Array Into Arrays With Max Difference - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>排序完将 nums 分成 n 组，每组 3 个元素. 再遍历各组，判断是否满足两两元素之差不大于 k .</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">divideArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> min = nums[i * <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (nums[i * <span class="number">3</span> + <span class="number">2</span>] - min &gt; k) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(nums[i * <span class="number">3</span>]);</span><br><span class="line">            arr.<span class="built_in">push_back</span>(nums[i * <span class="number">3</span> + <span class="number">1</span>]);</span><br><span class="line">            arr.<span class="built_in">push_back</span>(nums[i * <span class="number">3</span> + <span class="number">2</span>]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(arr);</span><br><span class="line">            arr.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="another-approach">Another approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">divideArray</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - nums[i - <span class="number">2</span>] &gt; k) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;nums[i - <span class="number">2</span>], nums[i - <span class="number">1</span>], nums[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
<h3 id="greedy-thinking">Greedy thinking</h3>
<blockquote>
<p>考虑最小的数分到哪一组。为了让选出来的三个数差值尽量小，也为了让剩下的 <span class="math inline">\((n−3)\)</span> 个数中，最小的数尽量大（这里可以直观理解一下，最小的数越大，它和同一组内最大的数差距就越小），因此我们每次应该把最小的三个数分成一组。</p>
<p>因此把数组排序，之后连续三个数分一组并检查即可。复杂度 <span class="math inline">\(\mathcal{O}(n\log n)\)</span>，主要是排序的复杂度。</p>
<p>作者：TsReaper 链接：https://leetcode.cn/problems/divide-array-into-arrays-with-max-difference/solutions/2569370/tan-xin-by-tsreaper-99pc/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>greedy</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2971 Find Polygon With the Largest Perimeter</title>
    <url>/2024/02/15/LeetCode2971/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-polygon-with-the-largest-perimeter/description/">Find Polygon With the Largest Perimeter - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<ol type="1">
<li>Sort the array.</li>
<li>Use greedy algorithm. If we select an edge as the longest side, it is always better to pick up all the edges with length no longer than this longest edge.</li>
</ol>
<p><strong>Hint</strong></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">largestPerimeter</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> preSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; preSum) &#123;</span><br><span class="line">                res = nums[i] + preSum;</span><br><span class="line">            &#125;</span><br><span class="line">            preSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(nlogn)</p>
<h2 id="notes">Notes</h2>
<h4 id="backward-iteration">Backward Iteration</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">largestPerimeter</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">2</span>; --i) &#123;</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> sum + nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(nlogn)</p>
<blockquote>
<p><code>sort()</code> 's space complexity</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>greedy</tag>
        <tag>sorting</tag>
        <tag>prefix-sum</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3005 Count Elements With Maximum Frequency</title>
    <url>/2024/03/08/LeetCode3005/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/count-elements-with-maximum-frequency/">Count Elements With Maximum Frequency - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>用数组维护每个数的 frequency ，再遍历数组维护最大的 frequency 及其数量，返回其乘积即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFrequencyElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">frequency</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : nums) &#123;</span><br><span class="line">            ++frequency[num];</span><br><span class="line">            <span class="keyword">if</span> (frequency[num] &gt; max) &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                max = frequency[num];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (frequency[num] == max) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count * max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>hash-table</tag>
        <tag>counting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3021 Alice and Bob Playing Flower Game</title>
    <url>/2024/01/29/LeetCode3021/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/alice-and-bob-playing-flower-game/description/">Alice and Bob Playing Flower Game - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一道数学题. 首先， Alice 想赢，x + y 必须为奇数. 而对于 <code>n * m</code> 的矩阵，和为奇数对的个数为<code>(n * m) / 2</code>，偶数对的个数为 <code>(n * m) - (n * m) / 2</code> ，画图很直观.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">flowerGame</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="type">long</span> <span class="type">long</span>)m * (<span class="type">long</span> <span class="type">long</span>)n) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(1)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 303 Range Sum Query - Immutable</title>
    <url>/2024/03/18/LeetCode303/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/range-sum-query-immutable/">Range Sum Query - Immutable - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>这种提供查询接口的类一般都要做个备忘录，用空间换时间. 这题记录各元素的前缀和，查询时返回两元素的前缀和之差即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; prefixSum;</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        prefixSum.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            prefixSum.<span class="built_in">push_back</span>(prefixSum[i] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefixSum[right + <span class="number">1</span>] - prefixSum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Time:</p>
<ul>
<li>NumArray(): O(n)</li>
<li>sumRange(): O(1)</li>
</ul>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>design</tag>
        <tag>prefix-sum</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3063 Linked List Frequency</title>
    <url>/2024/03/09/LeetCode3063/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/linked-list-frequency/">Linked List Frequency - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>用一个 hash-table 记录各个数值的 frequency ，再遍历 hash-table 构造 linked-list ，可以用前插法.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">frequenciesOfElements</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; frequencyMap;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            ++frequencyMap[p-&gt;val];</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [_, v] : frequencyMap) &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(v, res-&gt;next);</span><br><span class="line">            res-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Premium</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>hash-table</tag>
        <tag>linked-list</tag>
        <tag>couting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 299 Bulls and Cows</title>
    <url>/2024/03/10/LeetCode299/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/bulls-and-cows/">Bulls and Cows - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>hash map . 遍历模拟即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getHint</span><span class="params">(string secret, string guess)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="type">int</span> n = secret.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> bulls = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (secret[i] == guess[i]) &#123;</span><br><span class="line">                ++bulls;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (count[secret[i]]++ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++cows;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count[guess[i]]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++cows;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(bulls) + <span class="string">&quot;A&quot;</span> + <span class="built_in">to_string</span>(cows) + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>hash-table</tag>
        <tag>couting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3065 Minimum Operations to Exceed Threshold Value I</title>
    <url>/2024/03/04/LeetCode3065/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-operations-to-exceed-threshold-value-i/description">Minimum Operations to Exceed Threshold Value I - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接遍历 <code>nums</code> 统计小于 <code>k</code> 的元素个数. 也可以先排序后统计.</p>
<h2 id="sorting-codes">Sorting codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; k) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(nlogn)</p>
<blockquote>
<p>均来自 <code>sort()</code></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>sorting，enumeration</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3062 Winner of the Linked List Game</title>
    <url>/2024/03/09/LeetCode3062/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/winner-of-the-linked-list-game/">Winner of the Linked List Game - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接遍历链表模拟统计即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">gameResult</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> oddPoints = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> evenPoints = <span class="number">0</span>;</span><br><span class="line">        ListNode* evenNode = head;</span><br><span class="line">        ListNode* oddNode;</span><br><span class="line">        <span class="keyword">while</span> (evenNode) &#123;</span><br><span class="line">            oddNode = evenNode-&gt;next;</span><br><span class="line">            <span class="type">int</span> evenVal = evenNode-&gt;val;</span><br><span class="line">            <span class="type">int</span> oddVal = oddNode-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (evenVal &gt; oddVal) &#123;</span><br><span class="line">                ++evenPoints;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++oddPoints;</span><br><span class="line">            &#125;</span><br><span class="line">            evenNode = oddNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (evenPoints &gt; oddPoints) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Even&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (evenPoints &lt; oddPoints) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Odd&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Tie&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Premium</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 310 Minimum Height Trees</title>
    <url>/2024/03/17/LeetCode310/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-height-trees/">Minimum Height Trees - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-height-trees/solutions/1395249/zui-xiao-gao-du-shu-by-leetcode-solution-6v6f">最小高度树（BFS/DFS/拓扑排序） - 力扣官方题解</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<blockquote>
<p>拓扑排序</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(n)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; edge : edges)&#123;</span><br><span class="line">            adj[edge[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            adj[edge[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line">            degree[edge[<span class="number">0</span>]]++;</span><br><span class="line">            degree[edge[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degree[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> remainNodes = n;</span><br><span class="line">        <span class="keyword">while</span> (remainNodes &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sz = qu.<span class="built_in">size</span>();</span><br><span class="line">            remainNodes -= sz;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="type">int</span> curr = qu.<span class="built_in">front</span>();</span><br><span class="line">                qu.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; v : adj[curr]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (--degree[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                        qu.<span class="built_in">emplace</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(qu.<span class="built_in">front</span>());</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>graph</tag>
        <tag>topological-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 3066 Minimum Operations to Exceed Threshold Value II</title>
    <url>/2024/03/04/LeetCode3066/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-operations-to-exceed-threshold-value-ii/description">Minimum Operations to Exceed Threshold Value II - LeetCOde</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>小根堆直接模拟. 但这题的 <code>int</code> 可能存不下数据，需要稍微处理一下，可以使用 <code>long long</code> ，也可以将超过 <code>k</code> 大小的数直接记为 <code>k</code> .</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; h &#123;std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), nums&#125;;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (h.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; h.<span class="built_in">top</span>() &lt; k) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="type">int</span> x = h.<span class="built_in">top</span>();</span><br><span class="line">            h.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> y = h.<span class="built_in">top</span>();</span><br><span class="line">            h.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// process the data</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">min</span>(x, y) &lt; k / <span class="number">2</span>) &#123;</span><br><span class="line">                h.<span class="built_in">push</span>(<span class="built_in">min</span>(x, y) * <span class="number">2</span> + <span class="built_in">max</span>(x, y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                h.<span class="built_in">push</span>(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
<blockquote>
<p><code>make_heap</code> ‘s Time Complexity: O(n)</p>
<p><code>push</code> &amp; <code>pop</code> ’s Time COmplexity: O(logn)</p>
</blockquote>
<h2 id="notes">Notes</h2>
<h3 id="another-approach">Another approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue &lt;<span class="type">long</span> <span class="type">long</span>, vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;, greater&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; pq;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) pq.<span class="built_in">push</span>(x);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">top</span>() &lt; k) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> a1 = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> a2 = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            pq.<span class="built_in">push</span>(a1 * <span class="number">2</span> + a2);</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>heap/priority-queue</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 328 Odd Even Linked List</title>
    <url>/2024/02/22/LeetCode328/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/odd-even-linked-list/description/">Odd Even Linked List - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>链表指针操作，可以简单画个示意图模拟遍历一遍.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next || !head-&gt;next-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* evenHead = head-&gt;next;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">        ListNode* p = evenHead-&gt;next;</span><br><span class="line">        ListNode* oddCur = head;</span><br><span class="line">        ListNode* evenCur = evenHead;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// odd</span></span><br><span class="line">                oddCur-&gt;next = p;</span><br><span class="line">                oddCur = oddCur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// even</span></span><br><span class="line">                evenCur-&gt;next = p;</span><br><span class="line">                evenCur = evenCur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        oddCur-&gt;next = evenHead;</span><br><span class="line">        evenCur-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// necessary</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>Linked-List</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>two-pointers</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 322 Coin Change</title>
    <url>/2024/03/24/LeetCode322/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/coin-change/">Coin Change - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/coin-change/solutions/6568/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke">动态规划套路详解 - labuladong</a></p>
<p><a href="https://leetcode.cn/problems/coin-change/solutions/2119065/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-21m5">【视频】教你一步步思考动态规划！附题单！ - 灵茶山艾府</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : coins)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = x; c &lt;= amount; ++c)</span><br><span class="line">                f[c] = <span class="built_in">min</span>(f[c], f[c - x] + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans = f[amount];</span><br><span class="line">        <span class="keyword">return</span> ans &lt; <span class="number">0x3f3f3f3f</span> ? ans : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n*amount)</p>
<p>Space: O(amount)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>breadth-first-search</tag>
        <tag>dynamic-programming</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 331 Verify Preorder Serialization of a Binary Tree</title>
    <url>/2024/03/31/LeetCode331/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/">Verify Preorder Serialization of a Binary Tree - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/solutions/651132/pai-an-jiao-jue-de-liang-chong-jie-fa-zh-66nt">拍案叫绝的两种解法：「栈」和「入度出度」 - 负雪明烛</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSerialization</span><span class="params">(string preorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (preorder[i] == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (preorder[i] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                stk.<span class="built_in">top</span>() -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">top</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; preorder[i] != <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">top</span>() -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">top</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>binary-tree</tag>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 330 Patching Array</title>
    <url>/2024/06/16/LeetCode330/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.cn/problems/patching-array/">Patching Array - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/patching-array/solutions/2551840/yong-gui-na-fa-zheng-ming-pythonjavacgo-mvyu1">排序 + 贪心 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPatches</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] &lt;= s) &#123;</span><br><span class="line">                s += nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s *= <span class="number">2</span>;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: (m + logn)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 334 Increasing Triplet Subsequence</title>
    <url>/2024/01/18/LeetCode334/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/increasing-triplet-subsequence/description/">Increasing Triplet Subsequence - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>学的题解. 尽量保证前两个元素小，遍历 vector 找满足条件的第三个值.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">increasingTriplet</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> c1 = INT_MAX, c2 = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= c1) &#123;</span><br><span class="line">                c1 = x;           <span class="comment">// a candidate for 1st element</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt;= c2) &#123; <span class="comment">// x &gt; c1, x might be either c2 or c3</span></span><br><span class="line">                c2 = x;           <span class="comment">// x is better than c2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;              <span class="comment">// c1 &lt; c2 already and x &gt; c2</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>array/string</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>LeetCode-75</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 345 Reverse Vowels of a String</title>
    <url>/2024/01/17/LeetCode345/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/">Reverse Vowels of a String - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>遍历一遍字符串，将元音字母对应的下标另存到一个 vector 中，再反转该 vector 更新到原字符串中.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseVowels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; indexOfVowels;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">                indexOfVowels.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> vowels = indexOfVowels.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = vowels - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[indexOfVowels[i++]], s[indexOfVowels[j--]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>array/string</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>LeetCode-75</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 349 Intersection of Two Arrays</title>
    <url>/2024/03/10/LeetCode349/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/intersection-of-two-arrays/">Intersection of Two Arrays - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>使用内置数据结构 hash-set ，遍历即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; resSet;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set1</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.<span class="built_in">find</span>(num) != set1.<span class="built_in">end</span>())&#123;</span><br><span class="line">                resSet.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(resSet.<span class="built_in">begin</span>(), resSet.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>two-pointers</tag>
        <tag>hash-table</tag>
        <tag>sorting</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 380 Insert Delete GetRandom O(1)</title>
    <url>/2024/01/16/LeetCode380/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/description/">Insert Delete GetRandom O(1) - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>哈希表的增删查操作时间复杂度均为 O(1) ，借助 unordered_map 即可.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(val) == map.<span class="built_in">end</span>()) &#123; <span class="comment">// not found</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">search</span>(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(val);</span><br><span class="line">            map[val] = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">search</span>(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// swap the object with v.back()</span></span><br><span class="line">            v[map[val]] = v.<span class="built_in">back</span>();</span><br><span class="line">            v.<span class="built_in">pop_back</span>();</span><br><span class="line">            map[v[map[val]]] = map[val];</span><br><span class="line">            map.<span class="built_in">erase</span>(val);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v[<span class="built_in">rand</span>() % v.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// key: val of set, val: index of val in set</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet* obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;insert(val);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Time: O(1)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="unordered_map"><code>unordered_map</code></h3>
<p><a href="https://en.cppreference.com/w/cpp/container/unordered_map">std::unordered_map - cppreference.com</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 387 First Unique Character in a String</title>
    <url>/2024/02/05/LeetCode387/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/first-unique-character-in-a-string/description/">First Unique Character in a String - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>遍历 s 维护一个 key 为字符， value 为其出现次数的 hash map ，再遍历 s 寻找 hash map value 为 1 的下标. 此外，还可以使用 hash map 存储索引：第一次遇到某字符则记录其下标，否则将其 value 更改为 -1.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ++count[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="queue-approach">Queue approach</h3>
<blockquote>
<p>我们也可以借助队列找到第一个不重复的字符。队列具有「先进先出」的性质，因此很适合用来找出第一个满足某个条件的元素。</p>
<p>具体地，我们使用与方法二相同的哈希映射，并且使用一个额外的队列，按照顺序存储每一个字符以及它们第一次出现的位置。当我们对字符串进行遍历时，设当前遍历到的字符为 c，如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个二元组放入队尾，否则我们就需要检查队列中的元素是否都满足「只出现一次」的要求，即我们不断地根据哈希映射中存储的值（是否为 -1）选择弹出队首的元素，直到队首元素「真的」只出现了一次或者队列为空。</p>
<p>在遍历完成后，如果队列为空，说明没有不重复的字符，返回 -1，否则队首的元素即为第一个不重复的字符以及其索引的二元组。</p>
<p>小贴士</p>
<p>在维护队列时，我们使用了「延迟删除」这一技巧。也就是说，即使队列中有一些字符出现了超过一次，但它只要不位于队首，那么就不会对答案造成影响，我们也就可以不用去删除它。只有当它前面的所有字符被移出队列，它成为队首时，我们才需要将它移除。</p>
<p>作者：力扣官方题解 链接：https://leetcode.cn/problems/first-unique-character-in-a-string/solutions/531740/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; position;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!position.<span class="built_in">count</span>(s[i])) &#123;</span><br><span class="line">                position[s[i]] = i;</span><br><span class="line">                q.<span class="built_in">emplace</span>(s[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; position[q.<span class="built_in">front</span>().first] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>() ? <span class="number">-1</span> : q.<span class="built_in">front</span>().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>hash-table</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 392 Is Subsequence</title>
    <url>/2024/01/22/LeetCode392/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/is-subsequence/description/">Is Subsequence - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>双指针，一个指针指向 s ，一个指针用来遍历 t .</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sLen = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> tLen = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// the pointer to a element of s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tLen; i++) &#123; <span class="comment">// the pointer to a element of t</span></span><br><span class="line">            <span class="keyword">if</span> (t[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == sLen) &#123; <span class="comment">// All elements in s appear in order in t</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>two-pointers</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-75</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 39 Combination Sum</title>
    <url>/2024/04/20/LeetCode39/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/combination-sum/">Combination Sum - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/combination-sum/solutions/406516/zu-he-zong-he-by-leetcode-solution">力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; combine, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(combine);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接跳过</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, ans, combine, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            combine.<span class="built_in">emplace_back</span>(candidates[idx]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; combine;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, ans, combine, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>时间复杂度：<span class="math inline">\(O(S)\)</span> ，其中 <span class="math inline">\(S\)</span> 为所有可行解的长度之和。从分析给出的搜索树我们可以看出时间复杂度取决于搜索树所有叶子节点的深度之和，即所有可行解的长度之和。在这题中，我们很难给出一个比较紧的上界，我们知道 <span class="math inline">\(O(n \times 2^n)\)</span> 是一个比较松的上界，即在这份代码中，<span class="math inline">\(n\)</span> 个位置每次考虑选或者不选，如果符合条件，就加入答案的时间代价。但是实际运行的时候，因为不可能所有的解都满足条件，递归的时候我们还会用 <span class="math inline">\(\textit{target} - \textit{candidates}[\textit{idx}] \ge 0\)</span> 进行剪枝，所以实际运行情况是远远小于这个上界的。</li>
<li>空间复杂度：<span class="math inline">\(O(\textit{target})\)</span> 。除答案数组外，空间复杂度取决于递归的栈深度，在最差情况下需要递归 <span class="math inline">\(O(\textit{target})\)</span> 层。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 394 Decode String</title>
    <url>/2024/02/17/LeetCode394/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/decode-string/description/">Decode String - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>递归. 将括号作为一个整体进行解析.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">analysis</span><span class="params">(string s, <span class="type">int</span>&amp; index)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[index] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[index] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            count = <span class="number">10</span> * count + s[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[index] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            tmp = <span class="built_in">analysis</span>(s, ++index);</span><br><span class="line">            <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[index] == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res += s[index];</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">analysis</span>(s, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(S)</p>
<p>Space: O(s)</p>
<blockquote>
<p>记解码后得出的字符串长度为 S，原字符串长度为 s</p>
<p>除了遍历一次原字符串 <span class="math inline">\(s\)</span>，我们还需要将解码后的字符串中的每个字符都拼接进答案中，故渐进时间复杂度为 <span class="math inline">\(O(S+|s|)\)</span> ，即 O(S) .</p>
<p>若不考虑答案所占用的空间，那么就只剩递归使用栈空间的大小，这里栈空间的使用和递归树的深度成正比，最坏情况下为 <span class="math inline">\(O(|s|)\)</span> ，故渐进空间复杂度为 <span class="math inline">\(O(|s|)\)</span> .</p>
<p>作者：力扣官方题解 链接：https://leetcode.cn/problems/decode-string/solutions/264391/zi-fu-chuan-jie-ma-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="notes">Notes</h2>
<h3 id="stack-approach">Stack approach</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/decode-string/solutions/6274/ti-jie-czhan-by-youlookdeliciousc">Decode String - LeetCode - YouLookDeliciousC</a></p>
</blockquote>
<p>使用栈模拟.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        stack &lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        stack &lt;string&gt; strs;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>) ||(s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                res = res + s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;[&#x27;</span>) <span class="comment">//将‘[’前的数字压入nums栈内， 字母字符串压入strs栈内</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums.<span class="built_in">push</span>(num);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                strs.<span class="built_in">push</span>(res); </span><br><span class="line">                res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//遇到‘]’时，操作与之相配的‘[’之间的字符，使用分配律</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> times = nums.<span class="built_in">top</span>();</span><br><span class="line">                nums.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; times; ++ j)</span><br><span class="line">                    strs.<span class="built_in">top</span>() += res;</span><br><span class="line">                res = strs.<span class="built_in">top</span>(); <span class="comment">//之后若还是字母，就会直接加到res之后，因为它们是同一级的运算</span></span><br><span class="line">                                  <span class="comment">//若是左括号，res会被压入strs栈，作为上一层的运算</span></span><br><span class="line">                strs.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(S)</p>
<p>Space: O(S)</p>
<blockquote>
<p>除了遍历一次原字符串，我们还需要将解码后的字符串中的每个字符都入栈，并最终拼接进答案中，故渐进时间同递归方式.</p>
<p>这里用栈维护 TOKEN，栈的总大小最终与 S 相同，故渐进空间复杂度为 <span class="math inline">\(O(S)\)</span></p>
<p>作者：力扣官方题解 链接：https://leetcode.cn/problems/decode-string/solutions/264391/zi-fu-chuan-jie-ma-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>stack</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 402 Remove K Digits</title>
    <url>/2024/04/11/LeetCode402/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/remove-k-digits/">Remove K Digits - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/remove-k-digits/solutions/484940/yi-diao-kwei-shu-zi-by-leetcode-solution">力扣官方题解</a></p>
</blockquote>
<p>贪心 + 单调栈.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeKdigits</span><span class="params">(string num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        string stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch : num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( k &gt; <span class="number">0</span> &amp;&amp; !stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">back</span>() &gt; ch )</span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() &amp;&amp; ch == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">0</span> &amp;&amp; !stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>() ? <span class="string">&quot;0&quot;</span> : stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="similar-problem">Similar problem</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/remove-k-digits/solutions/1/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5">一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～ - lucifer</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>stack</tag>
        <tag>greedy</tag>
        <tag>monotonic-stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 41 First Missing Positive</title>
    <url>/2024/03/26/LeetCode41/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/first-missing-positive/">First Missing Positive - LeetCode</a></p>
</blockquote>
<p>没思路直接看题解噜</p>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/first-missing-positive/solutions/7703/tong-pai-xu-python-dai-ma-by-liweiwei1419">原地哈希（哈希函数为：f(nums[i]) = nums[i] - 1） - liweiwei1419</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span> || nums[i] &gt; n || nums[i] == nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> index = nums[i] - <span class="number">1</span>;</span><br><span class="line">                nums[i] = nums[index];</span><br><span class="line">                nums[index] = index + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 404 Sum of Left Leaves</title>
    <url>/2024/04/14/LeetCode404/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/sum-of-left-leaves/">Sum of Left Leaves - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接 DFS 遍历.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLeafNode</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !node-&gt;left &amp;&amp; !node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            ans += <span class="built_in">isLeafNode</span>(node-&gt;left) ? node-&gt;left-&gt;val : <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right &amp;&amp; !<span class="built_in">isLeafNode</span>(node-&gt;right)) &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? <span class="built_in">dfs</span>(root) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>binary-tree</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 42 Trapping Rain Water</title>
    <url>/2024/04/12/LeetCode42/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/trapping-rain-water/">Trapping Rain Water - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.com/problems/trapping-rain-water/solutions/185678/trapping-rain-water-by-ikaruga">【接雨水】单调递减栈，简洁代码，动图模拟 - Ikaruga</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; height[st.<span class="built_in">top</span>()] &lt; height[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cur = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> l = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="type">int</span> r = i;</span><br><span class="line">            <span class="type">int</span> h = <span class="built_in">min</span>(height[r], height[l]) - height[cur];</span><br><span class="line">            ans += (r - l - <span class="number">1</span>) * h;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="another-approach">Another approach</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc">动态规划/单调栈/双指针 - 力扣官方题解</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>dynamic-programming</tag>
        <tag>two-pointers</tag>
        <tag>monotonic-stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 442 Find All Duplicates in an Array</title>
    <url>/2024/03/25/LeetCode442/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/">Find All Duplicates in an Array - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/solutions/1473718/shu-zu-zhong-zhong-fu-de-shu-ju-by-leetc-782l">数组中重复的数据 - 力扣官方题解</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (nums[x - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[x - <span class="number">1</span>] = -nums[x - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 443 String Compression</title>
    <url>/2024/01/19/LeetCode443/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/string-compression/description/">String Compression - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>简单的遍历字符串，使用一个 pre 标记前一个字符用于判断接下来的行为. 注意要将 count 转换为字符串再插入到 chars 中.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compress</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; chars)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = chars.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == pre) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">                    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> a = count % <span class="number">10</span>;</span><br><span class="line">                        count = count / <span class="number">10</span>;</span><br><span class="line">                        s.<span class="built_in">push</span>(a);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        chars[i++] = s.<span class="built_in">top</span>() + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        s.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                chars[i++] = c;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                pre = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> a = count % <span class="number">10</span>;</span><br><span class="line">                count = count / <span class="number">10</span>;</span><br><span class="line">                s.<span class="built_in">push</span>(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                chars[i++] = s.<span class="built_in">top</span>() + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<h4 id="to_string"><code>to_string()</code></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compress</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; chars)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; inter;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; chars.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">           <span class="comment">// Count consecutive characters</span></span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; chars.<span class="built_in">size</span>() &amp;&amp; chars[i] == chars[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Append the character and its count to inter</span></span><br><span class="line">            inter.<span class="built_in">push_back</span>(chars[i]);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                string count_str = <span class="built_in">to_string</span>(count);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> c : count_str) &#123;</span><br><span class="line">                    inter.<span class="built_in">push_back</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Copy elements from the inter vector back to chars</span></span><br><span class="line">        chars = inter;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> chars.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>array/string</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>LeetCode-75</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 452 Minimum Number of Arrows to Burst Balloons</title>
    <url>/2024/03/18/LeetCode452/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/">Minimum Number of Arrows to Burst Balloons - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solutions/494515/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2">用最少数量的箭引爆气球 - 力扣官方题解</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; u, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> pos = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; balloon: points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (balloon[<span class="number">0</span>] &gt; pos) &#123;</span><br><span class="line">                pos = balloon[<span class="number">1</span>];</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(logn)</p>
<h2 id="notes">Notes</h2>
<h3 id="longest-increasing-subsequence">Longest increasing subsequence</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solutions/297889/chuan-shang-yi-fu-wo-jiu-bu-ren-shi-ni-liao-lai-3">穿上衣服我就不认识你了？来聊聊最长上升子序列 - lucifer</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>greedy</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 451 Sort Characters By Frequency</title>
    <url>/2024/02/07/LeetCode451/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/sort-characters-by-frequency/description/">Sort Characters By Frequency - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>记录各字符的频次，依据其重写 <code>sort</code> 函数的 <code>Compare</code> 参数.</p>
<h2 id="codes">Codes</h2>
<blockquote>
<p>最慢的方法:)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">            ++m[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), [&amp;](<span class="type">char</span> &amp;a, <span class="type">char</span> &amp;b) &#123;</span><br><span class="line">            <span class="keyword">return</span> m[a] &gt; m[b] || (m[a] == m[b] &amp;&amp; a &lt; b); </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(knlogn)</p>
<p>Space: O(nlogn)</p>
<blockquote>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/sort">std::sort - cppreference.com</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/lambda">Lambda expressions (since C++11) - cppreference.com</a></p>
<p>其中， <code>comp</code> 参数使用了 lambda 表达式，其捕获列表使用了 <code>&amp;</code> 引用传递方式。而值捕获也可以，但是此时 lambda 里面的 m 类型为 <code>const unordered_map&lt;char, int&gt;</code> 类型，函数体里对 m 进行访问不能使用 <code>[]</code> ，必须使用 <code>at()</code> 才行（因为只有 <code>at()</code> 可以返回常量引用. ）</p>
<p>值捕获示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[m](<span class="type">char</span> &amp;a, <span class="type">char</span> &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> m.<span class="built_in">at</span>(a) &gt; m.<span class="built_in">at</span>(b) || (m.<span class="built_in">at</span>(a) == m.<span class="built_in">at</span>(b) &amp;&amp; a &lt; b); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="notes">Notes</h2>
<h3 id="bucket-sort-approach">Bucket sort approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">char</span>&amp; c : s)&#123;</span><br><span class="line">            ++map[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">bucket</span><span class="params">(n + <span class="number">1</span>, <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [c, freq] : map) &#123;</span><br><span class="line">            bucket[freq].<span class="built_in">append</span>(freq, c);</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!bucket[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                ans.<span class="built_in">append</span>(bucket[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<blockquote>
<p>对于 <code>unordered_map</code> 遍历这事，上文中提到了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [c, freq] : map) &#123;</span><br><span class="line">    bucket[freq].<span class="built_in">append</span>(freq, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Structured binding</strong>的方式.</p>
</blockquote>
<h4 id="structured-binding-c17">Structured binding (C++17)</h4>
<p><a href="https://en.cppreference.com/w/cpp/language/structured_binding">Structured binding declaration (since C++17) - cppreference.com</a></p>
<p><a href="https://www.jianshu.com/p/e6f9bfaaf150">C++17 结构化绑定(Structured Bindings)初探 - 简书 (jianshu.com)</a></p>
<blockquote>
<p>示例：</p>
<p><strong>值传递</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : map) &#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>引用传递</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [k, v] : map) &#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，如果只想使用键,值可以用 <code>_</code> 代替</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [k, _] : map) &#123;</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，如果只用值，键可以用 <code>_</code> 代替</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, v] : map) &#123;</span><br><span class="line">    cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>————————————————</p>
<p>原文链接：https://blog.csdn.net/qq_21539375/article/details/122003559</p>
</blockquote>
<h3 id="priority-queueheap-approach">Priority queue(heap) approach</h3>
<p><a href="https://en.cppreference.com/w/cpp/container/priority_queue">std::priority_queue - cppreference.com</a></p>
<p><code>priority_queue</code> 默认使用 <code>std::less</code> 来比较（即 <code>&lt;</code> 运算符）<strong>默认构造大根堆</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">            ++m[c];</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;[first, second] : m) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;second, first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">append</span>(t.first, t.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
<blockquote>
<p><a href="https://en.cppreference.com/w/cpp/utility/pair/operator_cmp">operator==,!=,&lt;,&lt;=,&gt;,&gt;=,&lt;=&gt;(std::pair) - cppreference.com</a></p>
<p><a href="https://en.cppreference.com/w/cpp/utility/pair"><code>std::pair</code></a> 对 <code>&lt;</code> 运算符的重载：</p>
<p>按字典序，首先比较 <code>p1</code> ，只有 <code>p1</code> 相等时再比较 <code>p2</code> （until C++20）</p>
</blockquote>
<h4 id="faster-priority-queueheap-approach">Faster priority queue(heap) approach</h4>
<p><strong>而其中 hash map 可以使用 array 代替以提高速度</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">frequencySort</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> hashSize = <span class="number">128</span>;</span><br><span class="line">        <span class="type">int</span> hash[hashSize];</span><br><span class="line">        <span class="built_in">memset</span>(hash, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * hashSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; c : s) &#123;</span><br><span class="line">            ++hash[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt; maxHeap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hashSize; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[i]) &#123;</span><br><span class="line">                maxHeap.<span class="built_in">push</span>(&#123;hash[i], i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!maxHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = maxHeap.<span class="built_in">top</span>();</span><br><span class="line">            maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">            res += <span class="built_in">string</span>(t.first, t.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
<blockquote>
<p>其中 <code>string(t.first, t.second)</code> 是如下的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">basic_string</span>( size_type count, CharT ch,</span><br><span class="line">              <span class="type">const</span> Allocator&amp; alloc = <span class="built_in">Allocator</span>() );</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>此外，还可以使用 lambda 表达式定义一个大根堆 maxHeap</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&gt;, function&lt;<span class="type">bool</span>(pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&amp;, pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;&amp;)&gt;&gt; </span><br><span class="line"> <span class="built_in">maxHeap</span>([](pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; &amp;a, pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; &amp;b) &#123;</span><br><span class="line">     <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="the-expression-compa-b">The expression comp(a, b)</h3>
<p><a href="https://en.cppreference.com/w/cpp/named_req/Compare">C++ named requirements: Compare - cppreference.com</a></p>
<p><code>comp</code> 函数用来比较两个元素 <code>a</code> 和 <code>b</code> ，通过 <code>bool</code> 型的返回值来确定 <code>a</code> 和 <code>b</code> 在<strong>严格弱序</strong>中的相对位置，如果是 <code>true</code> ，那么 <code>a</code> 在严格弱序序列中就在 <code>b</code> 之前，否则在 <code>b</code> 之后。</p>
<blockquote>
<p>严格弱序： <code>&lt;</code> 而非 <code>&lt;=</code></p>
</blockquote>
<p>因此，在 <code>sort</code> 函数中，如果 <code>comp(a, b)</code> 为 <code>true</code> ，那么 <code>sort</code> 函数就会将 <code>a</code> 放在 <code>b</code> 的前面，否则 <code>a</code> 就放在 <code>b</code> 的后面</p>
<p><a href="https://blog.csdn.net/qq_28114615/article/details/86495567">sort函数、priority_queue中比较函数的写法_priority_queue cmp比较的写法-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/Sansipi/article/details/127858218">C++ priority_queue如何自定义比较函数？和sort里面自定义比较函数有何区别？_queue sort c++-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/tp_0moyi0/article/details/123296966">C++ priority_queue 与 lambda的结合使用_priority_queue和lambda-CSDN博客</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>hash-table</tag>
        <tag>heap/priority-queue</tag>
        <tag>sorting</tag>
        <tag>counting</tag>
        <tag>bucket-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 463 Island Perimeter</title>
    <url>/2024/04/18/LeetCode463/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/island-perimeter/">Island Perimeter - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/island-perimeter/solutions/151724/tu-jie-jian-ji-er-qiao-miao-de-dfs-fang-fa-java-by">图解：在 DFS 遍历过程中求周长 - nettee</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j) + <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>, j) + <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>) + <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mn)</p>
<p>Space: O(mn)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 49 Group Anagrams</title>
    <url>/2024/02/06/LeetCode49/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/group-anagrams/description/">Group Anagrams - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>首先维护一个 strs 中 str 里各字符出现的次数的二维数组 count ，再遍历一遍 strs 将 count 结果相同的 str 整理到一起，再返回该结果.</p>
<h2 id="my-brute-force-codes">My brute force Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="type">int</span> n = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// count the number of character in str</span></span><br><span class="line">        <span class="type">int</span> count[n][<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">memset</span>(count, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n * <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : strs[i]) &#123;</span><br><span class="line">                ++count[i][c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> tag[n]; <span class="comment">// tag the str, if str is visited then pass it</span></span><br><span class="line">        <span class="built_in">memset</span>(tag, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;string&gt; tmp;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tag[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; <span class="number">26</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count[i][k] != count[j][k]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="number">26</span>) &#123;</span><br><span class="line">                    tag[j] = <span class="number">1</span>;</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(strs[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(kn^2)</p>
<p>Space: O(k * n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<p>上述代码中的双循环可以使用一个 hash map 辅助单循环的方式取代. 而 hash map 的 key 可以是 str 的排序后值，也可以是 str 的 count 缩写（如： str: <code>aab</code> 的缩写为 <code>a2b1</code> ）， value 则为 str 对应的 Anagram 数组. 甚至可以用 str 各字符对应的质数之积作为 hash map 的 key.</p>
<h4 id="product-of-prime-numbers-approach">product of prime numbers approach</h4>
<blockquote>
<p><a href="https://leetcode.cn/problems/group-anagrams/solutions/333059/c-map-stringvectorstring-z-by-zrita/">49. 字母异位词分组 - 力扣（LeetCode）</a></p>
<p><strong>算术基本定理</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_map &lt;<span class="type">double</span>,vector&lt;string&gt;&gt; m;</span><br><span class="line">        <span class="type">double</span> a[<span class="number">26</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(string&amp; s : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> t = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : s)</span><br><span class="line">                t *= a[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            m[t].<span class="built_in">push_back</span>(s);          <span class="comment">//  t 为单词对应的质数乘积， m[t] 则为该单词的异位词构成的 vector </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n : m)                <span class="comment">//  n 为键和值组成的 pair </span></span><br><span class="line">            res.<span class="built_in">push_back</span>(n.second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(kn)</p>
<p>Space: O(kn)</p>
<h4 id="sorting-approach">Sorting approach</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; output;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; outputMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            string sCopy &#123;s&#125;;</span><br><span class="line">            ranges::<span class="built_in">sort</span>(sCopy);</span><br><span class="line">            outputMap[sCopy].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, x] : outputMap)</span><br><span class="line">            output.<span class="built_in">push_back</span>(<span class="built_in">move</span>(x));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(knlogn)</p>
<p>Space: O(kn)</p>
<h4 id="counting-approach-1">counting approach 1</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getSignature</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            count[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stringstream ss;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                ss &lt;&lt; (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + i) &lt;&lt; count[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; groups;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string&amp; s : strs) &#123;</span><br><span class="line">            groups[<span class="built_in">getSignature</span>(s)].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; entry : groups) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(entry.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(kn)</p>
<p>Space: O(kn)</p>
<h4 id="counting-approach-2">counting approach 2</h4>
<blockquote>
<p><a href="https://leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/">49. 字母异位词分组 - 力扣（LeetCode）</a></p>
</blockquote>
<p>直接使用数组作为 hash map 的 key .</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="comment">// 自定义对 array&lt;int, 26&gt; 类型的哈希函数</span></span><br><span class="line">        <span class="keyword">auto</span> arrayHash = [fn = hash&lt;<span class="type">int</span>&gt;&#123;&#125;] (<span class="type">const</span> array&lt;<span class="type">int</span>, <span class="number">26</span>&gt;&amp; arr) -&gt; <span class="type">size_t</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">accumulate</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">0u</span>, [&amp;](<span class="type">size_t</span> acc, <span class="type">int</span> num) &#123;</span><br><span class="line">                <span class="built_in">return</span> (acc &lt;&lt; <span class="number">1</span>) ^ <span class="built_in">fn</span>(num);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;array&lt;<span class="type">int</span>, 26&gt;, vector&lt;string&gt;, <span class="keyword">decltype</span>(arrayHash)&gt; <span class="built_in">mp</span>(<span class="number">0</span>, arrayHash);</span><br><span class="line">        <span class="keyword">for</span> (string&amp; str: strs) &#123;</span><br><span class="line">            array&lt;<span class="type">int</span>, 26&gt; counts&#123;&#125;;</span><br><span class="line">            <span class="type">int</span> length = str.<span class="built_in">length</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">                counts[str[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[counts].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(kn)</p>
<p>Space: O(kn)</p>
<blockquote>
<ol type="1">
<li><p><code>decltype()</code> 指的是之前声明的变量类型，如 <code>decltye(x)</code> 返回 <code>x</code> 之前声明的变量类型。</p></li>
<li><p><code>array</code> 相比于 <code>vector</code> , <code>array</code> 是定长数组, <code>vector</code> 是可变长度的数组。</p></li>
<li><p><code>arrayHash</code> 匿名函数，嵌套了一个匿名函数 <code>[fn = hash&lt;int&gt;&#123;&#125;]</code> 是初始化捕获列表，也就是说定义了一个 <code>auto fn = hash&lt;int&gt;&#123;&#125;</code> ；供后续使用 默认是使用 <code>hash&lt;T&gt;</code> 来实现的，但是 hash 没有办法去实现一个 array 的哈希，因此需要手动去构造一个哈希函数。本次构造哈希函数，是基于已有的 hash 去实现的，哈希碰撞概率几乎为 0 。 <code>arrayHash</code> 接受一个 <code>array&lt;int, 26&gt;</code> 类型的数组作为参数，并返回一个 <code>size_t</code> 类型的哈希值，这是因为 cpp 文档中规定 <code>hash&lt;T&gt;</code> 的 Hash 值必须是无符号整型 <code>size_t</code> 。</p></li>
<li><p><code>accumulate</code> <a href="https://en.cppreference.com/w/cpp/algorithm/accumulate">std::accumulate - cppreference.com</a></p></li>
</ol>
<p>在这个哈希算法中，每个元素通过 <code>fn(num)</code> 调用哈希函数对象来获取其哈希值，然后将之前累次运算结果左移一位 <code>(acc &lt;&lt; 1)</code> 相当于乘 2 后与 array 中本次要操作的数 num 的哈希值进行异或操作 (^) 得到新的哈希值。最终，累次运算结果结果将作为这个数组的哈希值返回。</p>
<p>你现在可能有一个问题了，为什么要搞这么复杂的哈希函数，直接累加不就完了，还用在里面再嵌套一个匿名函数吗，我说这当然是有必要的。你可以自己想想这样哈希函数的哈希碰撞问题，你所设想的这样一个哈希函数是否会导致两个单词不是易位次但是会得到相同的哈希值？如果是这样，那么你的哈希函数显然就是不合适的。<strong>事实证明不断扩大结果集有助于降低哈希冲突的概率，但这却并不表明我们可以完全避免哈希冲突</strong>.</p>
<p>作者：<a href="https://leetcode.cn/u/lai-bin-yu-tm/">徕滨鱼™🐟</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>hash-table</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 502 IPO</title>
    <url>/2024/06/15/LeetCode502/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/ipo/">IPO - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/ipo/solutions/985099/gong-shui-san-xie-noxiang-xin-ke-xue-xi-fk1ra">详解优先队列实现贪心算法 - 宫水三叶</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> w, vector&lt;<span class="type">int</span>&gt;&amp; profits, vector&lt;<span class="type">int</span>&gt;&amp; capital)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = profits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        vector&lt;pii&gt; arr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(&#123;capital[i], profits[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr &lt; n &amp;&amp; arr[curr].first &lt;= w) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(arr[curr].second);</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                w += pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O((n + K) logn)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>greedy</tag>
        <tag>heap/priority-queue</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 513 Find Bottom Left Tree Value</title>
    <url>/2024/02/28/LeetCode513/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/">Find Bottom Left Tree Value - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>找出二叉树中最低层最左的节点. 可以使用层次遍历（BFS），维护每一层的最右节点值 <code>rightMost</code> ，并由最右节点在队列中的下一节点为下一层的最左节点，获得 <code>leftMost</code> 并维护.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> leftMost = root-&gt;val;</span><br><span class="line">        <span class="type">int</span> rightMost = root-&gt;val;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* p = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val == rightMost) &#123;</span><br><span class="line">                rightMost = (!q.<span class="built_in">empty</span>() ? q.<span class="built_in">back</span>()-&gt;val : rightMost);</span><br><span class="line">                leftMost = (!q.<span class="built_in">empty</span>() ? q.<span class="built_in">front</span>()-&gt;val : leftMost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftMost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(width)</p>
<h2 id="better-bfs-approach">Better BFS approach</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> s = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    val = s-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(s-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(s-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(width)</p>
<h2 id="preorderdfs-approach">Preorder(DFS) approach</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        <span class="built_in">recursion</span>(root, <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans[ans.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(TreeNode *root,<span class="type">int</span> level,vector&lt;<span class="type">int</span>&gt;&amp;ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>() == level) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">recursion</span>(root-&gt;left, level + <span class="number">1</span>, ans);</span><br><span class="line">        <span class="built_in">recursion</span>(root-&gt;right, level + <span class="number">1</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(height)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 503 Next Greater Element II</title>
    <url>/2024/06/24/LeetCode503/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/next-greater-element-ii/">Next Greater Element II - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/next-greater-element-ii/solutions/638004/cong-po-su-jie-fa-de-jiao-du-qu-li-jie-d-trht">为啥使用「单调栈」呀？从「朴素解法」的角度去理解「单调栈」 - 宫水三叶</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vNextGreater</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vTobedeal;</span><br><span class="line">        vTobedeal.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> iIndex = vTobedeal.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(vTobedeal.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[vTobedeal[iIndex]])</span><br><span class="line">            &#123;</span><br><span class="line">                vNextGreater[vTobedeal[iIndex]] = nums[i];</span><br><span class="line">                vTobedeal.<span class="built_in">resize</span>(iIndex);</span><br><span class="line">                iIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            vTobedeal.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, iLimit = vTobedeal[<span class="number">0</span>]; i &lt;= iLimit; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> iIndex = vTobedeal.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; nums[vTobedeal[iIndex]])</span><br><span class="line">            &#123;</span><br><span class="line">                vNextGreater[vTobedeal[iIndex]] = nums[i];</span><br><span class="line">                vTobedeal.<span class="built_in">resize</span>(iIndex);</span><br><span class="line">                iIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vNextGreater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>monotonic-stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 518 Coin Change II</title>
    <url>/2024/03/25/LeetCode518/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/coin-change-ii/">Coin Change II - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/coin-change-ii/solutions/821592/gong-shui-san-xie-xiang-jie-wan-quan-bei-6hxv">【宫水三叶】详解完全背包问题（附背包问题攻略） - 宫水三叶</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> val = coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = val; j &lt;= amount; ++j) &#123;</span><br><span class="line">                f[j] += f[j - val];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n * amount)</p>
<p>Space: O(amount)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 520 Detect Capital</title>
    <url>/2024/06/23/LeetCode520/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/detect-capital/">Detect Capital - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/detect-capital/solutions/2819089/jian-ji-xie-fa-pythonjavaccgojsrust-by-e-1ms0">简洁写法 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">detectCapitalUse</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = ranges::<span class="built_in">count_if</span>(word, [](<span class="type">char</span> c) &#123; <span class="keyword">return</span> <span class="built_in">isupper</span>(c); &#125;);</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span> || cnt == word.<span class="built_in">length</span>() || cnt == <span class="number">1</span> &amp;&amp; <span class="built_in">isupper</span>(word[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 521 Longest Uncommon Subsequence I</title>
    <url>/2024/06/16/LeetCode521/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.cn/problems/longest-uncommon-subsequence-i/">Longest Uncommon Subsequence I - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/longest-uncommon-subsequence-i/solutions/2812183/fen-lei-tao-lun-nao-jin-ji-zhuan-wan-pyt-671e">分类讨论/脑筋急转弯 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLUSlength</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a == b ? <span class="number">-1</span> : <span class="built_in">max</span>(a.<span class="built_in">length</span>(), b.<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n + m)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 522 Longest Uncommon Subsequence II</title>
    <url>/2024/06/17/LeetCode522/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/longest-uncommon-subsequence-ii/">Longest Uncommon Subsequence II - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/longest-uncommon-subsequence-ii/solutions/1627846/by-ac_oier-vuez">经典 LCS 运用题 - 宫水三叶</a></p>
<p><a href="https://leetcode.cn/link/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU4NDE3MTEyMA%3D%3D%26mid%3D2247492097%26idx%3D1%26sn%3Df51f29d86df809d8ac43a40a1369b3d6">【面试高频题】难度 1.5/5，LCS 模板题 - 宫水三叶</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : b) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; a.<span class="built_in">size</span>() &amp;&amp; c == a[k]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k == a.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLUSlength</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">bool</span> is_sub = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; strs.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j &amp;&amp; <span class="built_in">check</span>(strs[i], strs[j])) &#123;</span><br><span class="line">                    is_sub = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!is_sub) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, <span class="built_in">int</span>(strs[i].<span class="built_in">size</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n<sup>2m</sup>2)</p>
<p>Space: O(m^2)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>two-pointers</tag>
        <tag>hash-table</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 525 Contiguous Array</title>
    <url>/2024/03/16/LeetCode525/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/contiguous-array/">Contiguous Array - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/contiguous-array/solutions/809920/gong-shui-san-xie-qian-zhui-he-ha-xi-bia-q400">【宫水三叶】前缀和 + 哈希表</a></p>
<p>在预处理前缀和时，将 <code>nums[i]</code> 为 <code>0</code> 的值当做 <code>-1</code> 处理.</p>
<p>将问题转化为：如何求最长一段区间和为 <code>0</code> 的子数组. 我们可以使用 hash-table 记录某个前缀和出现的最小下标，将紧接着出现的前缀和出现的最小下标减去该值即可得到一段区间和为 <code>0</code> 的子数组长度.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; Map;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            sum += nums[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">auto</span> p = Map.<span class="built_in">find</span>(sum);</span><br><span class="line">            <span class="keyword">if</span>(p != Map.<span class="built_in">end</span>()) ans = <span class="built_in">max</span>(ans, i - p-&gt;second);</span><br><span class="line">            <span class="keyword">else</span> Map[sum] = i;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>hash-table</tag>
        <tag>prefix-sum</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 543 Diameter of Binary Tree</title>
    <url>/2024/02/27/LeetCode543/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/diameter-of-binary-tree/description/">Diameter of Binary Tree - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>递归求子树深度相加，同时维护一个最值. 可以看看这个题解的生动心路历程:)</p>
<blockquote>
<p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/solutions/37205/hot-100-9er-cha-shu-de-zhi-jing-python3-di-gui-ye-">【HOT 100】9.二叉树的直径 Python3 递归也需要看清题意 - sammy</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDiameter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> lDepth = <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">            <span class="type">int</span> rDepth = <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">            maxDiameter = <span class="built_in">max</span>(maxDiameter, lDepth + rDepth);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(lDepth, rDepth) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">preOrder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(h)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>depth-first-search</tag>
        <tag>binary-tree</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 55 Jump Game</title>
    <url>/2024/01/14/LeetCode55/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/jump-game/description/">Jump Game - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一开始想的是抽象成图 dfs ，实现起来超时了。应该用贪心或者 dp .</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> reach = <span class="number">0</span>; i &lt; len &amp;&amp; i &lt;= reach; ++i) &#123;</span><br><span class="line">            reach = <span class="built_in">max</span>(i + nums[i], reach);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="another-approach">Another approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">front</span>() &gt;= s<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">front</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> range = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+nums.<span class="built_in">at</span>(i) &gt; range) range = i+nums.<span class="built_in">at</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(range &gt;= s<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(range == i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>top-interview-150</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>top-interview-150</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 57 Insert Interval</title>
    <url>/2024/03/17/LeetCode57/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/insert-interval/">Insert Interval - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>模拟.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> newStart = newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> newEnd = newInterval[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="number">0</span>] &lt; newInterval[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                newStart = intervals[i][<span class="number">0</span>];</span><br><span class="line">                newEnd = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>], newEnd);</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">            newEnd = intervals[i][<span class="number">1</span>];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;newStart, newEnd&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="number">0</span>] &gt; newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="type">int</span> n=intervals.<span class="built_in">size</span>(),i=<span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; intervals[i][<span class="number">1</span>]&lt;newInterval[<span class="number">0</span>])&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; newInterval[<span class="number">1</span>]&gt;=intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">            newInterval[<span class="number">0</span>]=<span class="built_in">min</span>(newInterval[<span class="number">0</span>],intervals[i][<span class="number">0</span>]);</span><br><span class="line">            newInterval[<span class="number">1</span>]=<span class="built_in">max</span>(newInterval[<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>graph</tag>
        <tag>topological-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 576 Out of Boundary Paths</title>
    <url>/2024/01/26/LeetCode576/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/out-of-boundary-paths/description/">Out of Boundary Paths - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>dp. 刚开始递推式写不出来，用的递归，但是没做备忘录就 TLE 了，当时优化想了很久，还是看了题解 :) dp 做一个记录移动了 k 次到达的点 (i, j) 出界的路径数的数组，可以用三维数组，也可以用新旧二维 dp 代替三位数组.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> MOD = <span class="number">1&#x27;000&#x27;000&#x27;007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> maxMove, <span class="type">int</span> startRow, <span class="type">int</span> startColumn)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; directions = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span> ,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> outCounts = <span class="number">0</span>; <span class="comment">// the counts of found paths</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        dp[startRow][startColumn] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= maxMove; k++) &#123;</span><br><span class="line">            <span class="comment">// k represents the number of move</span></span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">newDp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)); <span class="comment">// the dp after k moves</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="type">int</span> count = dp[i][j];</span><br><span class="line">                    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">// accessible node</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; direction : directions) &#123; <span class="comment">// start from node[i][j] in all directions</span></span><br><span class="line">                            <span class="type">int</span> newI = i + direction[<span class="number">0</span>];</span><br><span class="line">                            <span class="type">int</span> newJ = j + direction[<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (newI &gt;= <span class="number">0</span> &amp;&amp; newI &lt; m &amp;&amp; newJ &gt;= <span class="number">0</span> &amp;&amp; newJ &lt; n) &#123; <span class="comment">// the new node withn bounds</span></span><br><span class="line">                                newDp[newI][newJ] = (count + newDp[newI][newJ]) % MOD; <span class="comment">// count == dp[i][j], node[i][j] move to node[newI][newJ], then update newDp</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                outCounts = (outCounts + count) % MOD;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = newDp; <span class="comment">// the dp after k moves, the newDp should be the dp after (k + 1) moves</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outCounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(maxMove * m * n)</p>
<p>Space: O(m * n)</p>
<h2 id="notes">Notes</h2>
<h3 id="a-recursive-approach">a recursive approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">rec</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> mov, <span class="type">long</span> <span class="type">long</span> dp[][<span class="number">51</span>][<span class="number">51</span>])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// (x, y) -&gt; position, mov -&gt; number of times it could be moved</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= m || y &gt;= n) &#123;</span><br><span class="line">            <span class="comment">// node out of bounds, the count of paths + 1</span></span><br><span class="line">        	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mov == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// node within bounds</span></span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[x][y][mov] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// memo function</span></span><br><span class="line">        	<span class="keyword">return</span> dp[x][y][mov];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[x][y][mov] = (<span class="built_in">rec</span>(x + <span class="number">1</span>, y, m, n, mov - <span class="number">1</span>, dp) % mod + <span class="built_in">rec</span>(x - <span class="number">1</span>, y, m, n, mov - <span class="number">1</span>, dp) % mod + <span class="built_in">rec</span>(x, y + <span class="number">1</span>, m, n, mov - <span class="number">1</span>, dp) % mod + <span class="built_in">rec</span>(x, y - <span class="number">1</span>, m, n, mov - <span class="number">1</span>, dp) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> maxMove, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> dp[m][<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= maxMove; k++)&#123;</span><br><span class="line">                    dp[i][j][k] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rec</span>(r, c, m, n, maxMove, dp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(maxMove * m * n)</p>
<p>Space: O(maxMove * m * n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 58 Length of Last Word</title>
    <url>/2024/04/01/LeetCode58/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/length-of-last-word/">Length of Last Word - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一眼 split 的实现x</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span> (iss &gt;&gt; res);</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>其实这道题只要最后一个 word 的长度，只用反向遍历完一个 word 的长度即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h3 id="split"><code>split</code></h3>
<blockquote>
<p><a href="https://xrose7.github.io/2024/03/11/LeetCode2129/">LeetCode 2129 Capitalize the Title</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 605 Can Place Flowers</title>
    <url>/2024/01/16/LeetCode605/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/can-place-flowers/description/">Can Place Flowers - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>遍历数组，计算各段连续的 0 的个数，根据该个数计算该段可种植的花束. 注意开头和结尾非 1 的情况.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; flowerbed, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> place : flowerbed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (place == <span class="number">0</span>) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">                count += num / <span class="number">2</span>;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) &#123; <span class="comment">// if the last element of flowerbed is not 1</span></span><br><span class="line">            count += num / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>array/string</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>LeetCode-75</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 633 Sum of Square Numbers</title>
    <url>/2024/06/17/LeetCode633/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/sum-of-square-numbers/">Sum of Square Numbers - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/sum-of-square-numbers/solutions/747079/ping-fang-shu-zhi-he-by-leetcode-solutio-8ydl">平方数之和 - 力扣官方题解</a></p>
<p>双指针/费马平方和定理</p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool judgeSquareSum(int c) &#123;</span><br><span class="line">        for (long a = 0; a * a &lt;= c; a++) &#123;</span><br><span class="line">            double b = sqrt(c - a * a);</span><br><span class="line">            if (b == (int)b) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: <span class="math inline">\(O\left(\sqrt{c}\right)\)</span></p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>two-pointers</tag>
        <tag>math</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 623 Add One Row to Tree</title>
    <url>/2024/04/16/LeetCode623/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/add-one-row-to-tree/">Add One Row to Tree - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/add-one-row-to-tree/solutions/1720824/zai-er-cha-shu-zhong-zeng-jia-yi-xing-by-xcaf">力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">addOneRow</span><span class="params">(TreeNode* root, <span class="type">int</span> val, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val, root, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">2</span>) &#123;</span><br><span class="line">            root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val, root-&gt;left, <span class="literal">nullptr</span>);</span><br><span class="line">            root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val, <span class="literal">nullptr</span>, root-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">addOneRow</span>(root-&gt;left, val, depth - <span class="number">1</span>);</span><br><span class="line">            root-&gt;right = <span class="built_in">addOneRow</span>(root-&gt;right, val, depth - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>binary-tree</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 621 Task Scheduler</title>
    <url>/2024/03/19/LeetCode621/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/task-scheduler/">Task Scheduler - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.com/problems/task-scheduler/editorial/">task-scheduler - Editorial</a></p>
<p><a href="https://leetcode.cn/problems/task-scheduler/solutions/196302/tong-zi-by-popopop">【任务调度器】C++ 桶子_配图理解 - popopop</a></p>
<p>求 the maximum frequency 和 the number of tasks with that frequency 并不需要排序，直接遍历寻找 O(n) 即可.</p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leastInterval</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; tasks, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counts</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; task : tasks) &#123;</span><br><span class="line">            ++counts[task - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>; <span class="comment">// the maximum frequency</span></span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>; <span class="comment">// the number of tasks with that frequency</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; count : counts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &lt; count) &#123;</span><br><span class="line">                m = count;</span><br><span class="line">                x = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count == m) &#123;</span><br><span class="line">                ++x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num1 = tasks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> num2 = (m - <span class="number">1</span>) * (n + <span class="number">1</span>) + x;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="max-heap-approach">Max heap approach</h3>
<blockquote>
<p><a href="https://leetcode.com/problems/task-scheduler/editorial/">task-scheduler - Editorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>hash-table</tag>
        <tag>greedy</tag>
        <tag>heap/priority-queue</tag>
        <tag>sorting</tag>
        <tag>counting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 629 K Inverse Pairs Array</title>
    <url>/2024/01/27/LeetCode629/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/k-inverse-pairs-array/description/">K Inverse Pairs Array - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>在自己做了 4h 后，最后还是 TLE 了，学习题解.</p>
<p>模拟寻找递推式思路草稿.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1][0] = 1</span><br><span class="line"></span><br><span class="line">// (increment = 0 to 2)</span><br><span class="line">1(0): 12(0 + 0) 21(0 + 1)</span><br><span class="line"></span><br><span class="line">[2][0] = 1 = [1][0]</span><br><span class="line">[2][1] = 1 = [1][0] // 1 = 1 + 0, (1 + 1 == 2 == 2!)</span><br><span class="line">[2][2] = 0 // len = 2</span><br><span class="line"></span><br><span class="line">// (increment = 0 to 3)</span><br><span class="line">12(0): 123(0 + 0) 132(0 + 1) 312(0 + 2)</span><br><span class="line">21(1): 213(1 + 0) 231(1 + 1) 321(1 + 2)</span><br><span class="line"></span><br><span class="line">[3][0] = 1 = [2][0]</span><br><span class="line">[3][1] = 2 = [2][0] + [2][1]</span><br><span class="line">[3][2] = 2 = [2][0] + [2][1]</span><br><span class="line">[3][3] = 1 =          [2][1] //3 = 2 + 1, (1 + 2 + 2 + 1 == 6 == 3!)</span><br><span class="line">[3][4] = 0 // len = 4</span><br><span class="line"></span><br><span class="line">// (increment = 0 to 4)</span><br><span class="line">123(0): 1234(0 + 0) 1243(0 + 1) 1423(0 + 2) 4123(0 + 3)</span><br><span class="line">132(1): 1324(1 + 0) 1342(1 + 1) 1432(1 + 2) 4132(1 + 3)</span><br><span class="line">312(2): 3124(2 + 0) 3142(2 + 1) 3412(2 + 2) 4312(2 + 3)</span><br><span class="line">213(1): 2134(1 + 0) 2143(1 + 1) 2413(1 + 2) 4213(1 + 3)</span><br><span class="line">231(2): 2314(2 + 0) 2341(2 + 1) 2431(2 + 2) 4231(2 + 3)</span><br><span class="line">321(3): 3214(3 + 0) 3241(3 + 1) 3421(3 + 2) 4321(3 + 3)</span><br><span class="line"></span><br><span class="line">[4][0] = 1 = [3][0]</span><br><span class="line">[4][1] = 3 = [3][0] + [3][1]</span><br><span class="line">[4][2] = 5 = [3][0] + [3][1] + [3][2]</span><br><span class="line">[4][3] = 6 = [3][0] + [3][1] + [3][2] + [3][3]</span><br><span class="line">[4][4] = 5 =          [3][1] + [3][2] + [3][3]</span><br><span class="line">[4][5] = 3 =                   [3][2] + [3][3]</span><br><span class="line">[4][6] = 1 =                            [3][3] // 6 = 3 + 3, (1 + 3 + 5 + 6 + 5 + 3 + 1 == 24 == 4!)</span><br><span class="line">[4][7] = 0 // len = 7</span><br><span class="line"></span><br><span class="line">[5][0] =  1 = [4][0]</span><br><span class="line">[5][1] =  4 = [4][0] + [4][1]</span><br><span class="line">[5][2] =  9 = [4][0] + [4][1] + [4][2]</span><br><span class="line">[5][3] = 15 = [4][0] + [4][1] + [4][2] + [4][3]</span><br><span class="line">[5][4] = 20 = [4][0] + [4][1] + [4][2] + [4][3] + [4][4]</span><br><span class="line">[5][5] = 22 =          [4][1] + [4][2] + [4][3] + [4][4] + [4][5]</span><br><span class="line">[5][6] = 20 =                   [4][2] + [4][3] + [4][4] + [4][5] + [4][6]</span><br><span class="line">[5][7] = 15 =                            [4][3] + [4][4] + [4][5] + [4][6]</span><br><span class="line">[5][8] =  9 =                                     [4][4] + [4][5] + [4][6]</span><br><span class="line">[5][9] =  4 =                                              [4][5] + [4][6]</span><br><span class="line">[5][10] = 1 =                                                       [4][6] // 10 = 4 + 6, (120 == 5!)</span><br><span class="line">[5][11] = 0 // len = 11</span><br></pre></td></tr></table></figure>
<p>有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[n][k] = [n - 1][max(0, (k - (n - 1)))] + ... + [n - 1][min((len - 1), k)]; //len is (n - 1)&#x27;s length</span><br></pre></td></tr></table></figure>
<p>在暂时不考虑下标越界的情况下，有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[n][k] = dp[n - 1][k] + dp[n - 1][k - 1] + ... + dp[n - 1][k + 1 - n + 1] + dp[n - 1][k - n + 1]</span><br><span class="line">dp[n][k+1] = dp[n - 1][k + 1] + dp[n - 1][k] + dp[n - 1][k - 1] + ... + dp[n - 1][k + 1 - n + 1]</span><br></pre></td></tr></table></figure>
<p>相减得</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[n][k + 1] = dp[n][k] + dp[n - 1][k + 1] - dp[n - 1][k + 1 - n]</span><br></pre></td></tr></table></figure>
<p>而由于 dp 初始化为 0 , 故 min((len - 1), k) 并无必要，往后越界也只是 +0 . 而 max(0, (k - (n - 1))) 则需要判断.</p>
<p>由此可写出代码实现.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">1000</span> + <span class="number">1</span>][<span class="number">1000</span> + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1000&#x27;000&#x27;007</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kInversePairs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">min</span>(k, i * (i - <span class="number">1</span>) / <span class="number">2</span>); j++) &#123;</span><br><span class="line">            	<span class="comment">// (i * (i - 1) / 2 + 1) is the number of non-zero elements in the int[i] array</span></span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i) &#123;</span><br><span class="line">                	<span class="comment">// Avoid subscripts less than 0</span></span><br><span class="line">                    dp[i][j] -= dp[i - <span class="number">1</span>][j - i];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = (dp[i][j] + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n*k)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 645 Set Mismatch</title>
    <url>/2024/01/22/LeetCode645/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/set-mismatch/description/">Set Mismatch - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>由于数据范围是 1 - n ，直接做一个长度为 n + 1 的 count 数组，遍历 nums . 数字每出现一次，对应的 count ++，若加到 2 ，记下. 再遍历一遍 count 数组，为 0 则记下.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> repeat = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> miss = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            count[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span> (count[nums[i]] == <span class="number">2</span>) &#123;</span><br><span class="line">                repeat = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                miss = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(repeat);</span><br><span class="line">        res.<span class="built_in">push_back</span>(miss);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<p>遍历 nums ，计数方式为直接在 nums 修改数值做下标对应的 nums 的值的正负号，若出现一次，改为负号，若遍历到的数值做下标对应的值为负，说明该数值重复出现. 再遍历一遍 nums ，若某下标对应的值为正，说明该数值消失.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> duplicate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> num : nums)</span><br><span class="line">      <span class="keyword">if</span> (nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>] &lt; <span class="number">0</span>)</span><br><span class="line">        duplicate = <span class="built_in">abs</span>(num);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;duplicate, i + <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<blockquote>
<p>时间也比我的快. 应该是不等关系的判断要比相等关系的判断快.</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 643 Maximum Average Subarray I</title>
    <url>/2024/01/26/LeetCode643/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximum-average-subarray-i/description/">Maximum Average Subarray I - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>滑动窗口. 该题窗口大小为 k , 使用 i 和 j 作为边界指针，遍历 nums 记录连续 k 个元素和的最大值，最后再计算均值.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMaxAverage</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt;= k - <span class="number">1</span>; m++) &#123;</span><br><span class="line">            count += nums[m];</span><br><span class="line">        &#125;</span><br><span class="line">        max = count;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">            count -= nums[i++];</span><br><span class="line">            count += nums[++j];</span><br><span class="line">            <span class="keyword">if</span> (count &gt; max) &#123;</span><br><span class="line">                max = count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)max / k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>sliding-window</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-75</tag>
        <tag>sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 649 Dota2 Senate</title>
    <url>/2024/02/20/LeetCode649/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/dota2-senate/description/">Dota2 Senate - LeetCode</a></p>
</blockquote>
<h3 id="thinkings">Thinkings</h3>
<p>直接看官方题解吧:)</p>
<blockquote>
<p><a href="https://leetcode.cn/problems/dota2-senate/solutions/517088/dota2-can-yi-yuan-by-leetcode-solution-jb7l">Dota2 参议院 - 力扣官方题解</a></p>
</blockquote>
<blockquote>
<p>附：</p>
<p>题解中提到：“<strong>为什么固定增加 <span class="math inline">\(n\)</span> ，而不是增加与当前剩余议员数量相关的一个数？</strong>”</p>
<p>我们来尝试解决一下这个问题.</p>
<p>看这么一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RDD</span><br><span class="line"></span><br><span class="line">第一轮次：</span><br><span class="line">queue_radiant: R(1)</span><br><span class="line">queue_dire   : D(2) D(3)</span><br><span class="line">假设第一轮次的范围是 [1, 3]</span><br><span class="line"></span><br><span class="line">在 R 行动完之后， D(2) 被禁止，剩余的议员数为 2 ，我们要保证 R(1) 进入第二轮次，且保持议员行动的先后顺序，那么就不能让 让 R(1) 增加 2 ，即便 D(2) 议员可被排除. </span><br><span class="line"></span><br><span class="line">原因是第一轮次的议员并未全部结束，若增加与当前剩余议员数量相等或小于的数，则 R 本应属于下一轮次的行动会乱入到这一轮次中. </span><br><span class="line"></span><br><span class="line">为了方便地维护轮次以及行动的先后顺序，我们采用固定增加 n 的方式. </span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">predictPartyVictory</span><span class="params">(string senate)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = senate.<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; radiant;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; dire;</span><br><span class="line">        <span class="comment">// these two queues maintenance senate&#x27;s action rounds and order of priority</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (senate[i] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                radiant.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dire.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// In order to simply maintain the round, we use [(k - 1) * n, k * n] as a round</span></span><br><span class="line">        <span class="comment">// Then use the rules to simulate</span></span><br><span class="line">        <span class="keyword">while</span> (!radiant.<span class="built_in">empty</span>() &amp;&amp; !dire.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (radiant.<span class="built_in">front</span>() &lt; dire.<span class="built_in">front</span>()) &#123;</span><br><span class="line">                radiant.<span class="built_in">push</span>(radiant.<span class="built_in">front</span>() + n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dire.<span class="built_in">push</span>(dire.<span class="built_in">front</span>() + n);</span><br><span class="line">            &#125;</span><br><span class="line">            radiant.<span class="built_in">pop</span>();</span><br><span class="line">            dire.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> radiant.<span class="built_in">empty</span>() ? <span class="string">&quot;Dire&quot;</span> : <span class="string">&quot;Radiant&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>queue</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>greedy</tag>
        <tag>queue</tag>
        <tag>simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 678 Valid Parenthesis String</title>
    <url>/2024/04/07/LeetCode678/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/valid-parenthesis-string/">Valid Parenthesis String - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/valid-parenthesis-string/solutions/992601/gong-shui-san-xie-yi-ti-shuang-jie-dong-801rq">【宫水三叶】一题双解 :「动态规划」&amp;「模拟」（附括号问题目录） - 宫水三叶</a></p>
</blockquote>
<h3 id="greedy-approach">Greedy approach</h3>
<p><strong>贪心</strong>维护未匹配的左括号的最小值与最大值是最容易理解的:(</p>
<ul>
<li><p>如果遇到左括号，则将最小值和最大值分别加 1</p></li>
<li><p>如果遇到右括号，则将最小值和最大值分别减 1</p></li>
<li><p>如果遇到星号，则将最小值减 1 ，将最大值加 1</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++minCount;</span><br><span class="line">                ++maxCount;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                --minCount;</span><br><span class="line">                --maxCount;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --minCount;</span><br><span class="line">                ++maxCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                minCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minCount == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h3 id="dynamic-programming-approach">Dynamic programming approach</h3>
<p>能做但是不佳（不过我也想不出来x</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= i) f[i][j] = f[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) f[i][j] |= f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= i) f[i][j] |= f[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^2)</p>
<p>Space: O(n^2)</p>
<h3 id="stack-simulation-approach">Stack simulation approach</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/valid-parenthesis-string/solutions/993241/wei-rao-li-lun-ken-ding-shi-zhan-ya-by-w-op09">【微扰理论】肯定是栈呀🤔 - 微扰理论</a></p>
</blockquote>
<p>用两个栈分别维护可匹配的左括号和星号，左括号优先被匹配（有点贪心？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; star;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; left;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                star.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!left.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    left.<span class="built_in">pop</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!star.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    star.<span class="built_in">pop</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!left.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> posL = left.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (star.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> posS = star.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (posS &gt; posL) &#123;</span><br><span class="line">                star.<span class="built_in">pop</span>();</span><br><span class="line">                left.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>dynamic-programming</tag>
        <tag>stack</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 705 Design HashSet</title>
    <url>/2024/04/14/LeetCode705/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/design-hashset/">Design HashSet - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/design-hashset/solutions/652778/she-ji-ha-xi-ji-he-by-leetcode-solution-xp4t">力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; data;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyHashSet</span>(): <span class="built_in">data</span>(base) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].<span class="built_in">begin</span>(); it != data[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].<span class="built_in">push_back</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].<span class="built_in">begin</span>(); it != data[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                data[h].<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].<span class="built_in">begin</span>(); it != data[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n / b)</p>
<p>Space: O(n + b)</p>
<blockquote>
<p><strong>b</strong> is the size of linked-list</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>hash-table</tag>
        <tag>linked-list</tag>
        <tag>design</tag>
        <tag>hash-function</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 70 Climbing Stairs</title>
    <url>/2024/01/18/LeetCode70/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/climbing-stairs/description/">Climbing Stairs - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一个一个地算组合数：）</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> combination1[<span class="number">45</span>][<span class="number">45</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">combination</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n - m) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">combination</span>(n - m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (combination1[m][n] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> combination1[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    combination1[m][n] = <span class="built_in">combination</span>(m, n - <span class="number">1</span>) + <span class="built_in">combination</span>(m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> combination1[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = n / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        res += <span class="built_in">combination</span>(i, n - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: ?</p>
<p>Space: O(n^2)</p>
<h2 id="notes">Notes</h2>
<h3 id="组合数">组合数</h3>
<p><a href="https://blog.csdn.net/qq_54773252/article/details/122747725">几种常见的求组合数方法_组合计算公式-CSDN博客</a></p>
<h3 id="dp-fibonacci">DP &amp; Fibonacci</h3>
<blockquote>
<p>if we know the number ways to get to the points <code>[n-1]</code> and <code>[n-2]</code> respectively, denoted as <code>n1</code> and <code>n2</code> , then the total ways to get to the point <code>[n]</code> is <code>n1 + n2</code>. Because from the <code>[n-1]</code> point, we can take one single step to reach <code>[n]</code>. And from the <code>[n-2]</code> point, we could take two steps to get there.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base cases</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> one_step_before = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> two_steps_before = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> all_ways = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; i++)&#123;</span><br><span class="line">    	all_ways = one_step_before + two_steps_before;</span><br><span class="line">    	two_steps_before = one_step_before;</span><br><span class="line">        one_step_before = all_ways;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> all_ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 735 Asteroid Collision</title>
    <url>/2024/02/06/LeetCode735/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/asteroid-collision/description/">Asteroid Collision - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接栈模拟. 注意只有 + - 的情况才发生碰撞.</p>
<h2 id="codes">Codes</h2>
<p>直接使用 vector 模拟 stack :)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">asteroidCollision</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; asteroids)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; aster : asteroids) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aster &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                s.<span class="built_in">push_back</span>(aster);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">back</span>() &gt; <span class="number">0</span> &amp;&amp; s.<span class="built_in">back</span>() &lt; -aster) &#123;</span><br><span class="line">                    s.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || s.<span class="built_in">back</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    s.<span class="built_in">push_back</span>(aster);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">back</span>() == -aster) &#123;</span><br><span class="line">                    s.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<blockquote>
<p>Space: O(1) 返回值不计入空间复杂度</p>
</blockquote>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>stack</tag>
        <tag>simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 706 Design HashMap</title>
    <url>/2024/04/15/LeetCode706/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/design-hashmap/">Design HashMap - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/design-hashmap/solutions/654139/she-ji-ha-xi-ying-she-by-leetcode-soluti-klu9">力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; data;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyHashMap</span>(): <span class="built_in">data</span>(base) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be non-negative. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].<span class="built_in">begin</span>(); it != data[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                (*it).second = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].<span class="built_in">begin</span>(); it != data[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> (*it).second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].<span class="built_in">begin</span>(); it != data[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                data[h].<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n / b)</p>
<p>Space: O(n + b)</p>
<blockquote>
<p><strong>b</strong> is the size of linked-list</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>hash-table</tag>
        <tag>linked-list</tag>
        <tag>design</tag>
        <tag>hash-function</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 713 Subarray Product Less Than K</title>
    <url>/2024/03/27/LeetCode713/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/subarray-product-less-than-k/">Subarray Product Less Than K - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一开始没想到滑动窗口··</p>
<p>注意到以 <code>nums[i]</code> 为右边界的乘积小于 K 的子串数量其实就等于以 <code>nums[i]</code> 为右边界的乘积小于 K 的最长子串的 <code>right - left + 1</code> 结果.</p>
<p>接着就固定右边界，向右滑动左边界找出该右边界满足条件的最长子串。找到后，右边界向右移动一格，再循环往复.</p>
<blockquote>
<p><a href="https://leetcode.cn/problems/subarray-product-less-than-k/solutions/1959538/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-jebq">【视频】下标总算错？请看这！ - 灵茶山艾府</a></p>
</blockquote>
<p>（其实我一开始写的是固定左边界，滑动右边界的··但是这样写右边界要来来回回的，写起来不优雅:) ）</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> prod = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">            prod *= nums[right];</span><br><span class="line">            <span class="keyword">while</span> (prod &gt;= k) <span class="comment">// 不满足要求</span></span><br><span class="line">                prod /= nums[left++];</span><br><span class="line">            ans += right - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<blockquote>
<p>其中 n 是数组 nums 的长度，右指针遍历一遍数组，左指针紧随其后最多遍历一遍数组，即 O(2n)</p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/subarray-product-less-than-k/solutions/1320871/jian-dan-yi-dong-xiang-xi-zhu-jie-shuang-jvy3">713.官方思路秒懂○注释详细○双指针滑窗 【附通用滑窗模板】 - 腌菜读作梦想</a></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 75 Sort Colors</title>
    <url>/2024/06/12/LeetCode75/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/sort-colors/">Sort Colors - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>快速排序子过程 partition</p>
<h2 id="codes">Codes</h2>
<p>[0, i) 区间内全为 0</p>
<p>[i, j) 区间内全为 1</p>
<p>[k, len) 区间内全为 2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> k = size;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k--;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>two-pointers</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 724 Find Pivot Index</title>
    <url>/2024/01/30/LeetCode724/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-pivot-index/description/">Find Pivot Index - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>Prefix sum. 维护两个前缀和数组 leftSum 和 rightSum. 遍历 nums 计算出各位置的 leftSum 和 rightSum，最后再遍历一遍下标，返回 leftSum 和 rightSum 相同时的下标.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftSum</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSum</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        leftSum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        rightSum[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            leftSum[i] = leftSum[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">            rightSum[n - i - <span class="number">1</span>] = rightSum[n - i] + nums[n - i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftSum[i] == rightSum[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>prefix-sum</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-75</tag>
        <tag>prefix-sum</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 739 Daily Temperatures</title>
    <url>/2024/01/31/LeetCode739/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/daily-temperatures/description/">Daily Temperatures - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>一开始直接暴力二重循环， TLE 了. 偷看了 topic 原来是单调栈:) 相似题——<a href="https://xrose7.github.io/2024/01/20/LeetCode907/">LeetCode 907 Sum of Subarray Minimums | XRose's blog (xrose7.github.io)</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// find the first index which is greater in current element&#x27;s right</span></span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[s.<span class="built_in">top</span>()] &lt;= temperatures[i]) &#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = s.<span class="built_in">empty</span>() ? <span class="number">0</span> : (s.<span class="built_in">top</span>() - i);</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>monotonic-stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 76 Minimum Window Substring</title>
    <url>/2024/02/04/LeetCode76/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-window-substring/description/">Minimum Window Substring - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>主要是滑动窗口. 首先可以做一个 hash map 记录 t 中的字符及其对应的个数，再在 s 上构造滑动窗口，先扩张右边界 r 直到覆盖 hash map 中所有出现的字符，再收缩左边界 l 直到获取最小满足条件的最小窗口大小.</p>
<p>而在滑动窗口的过程中，还要对 [l, r] 区间内的字符进行计数. 可以在之前的 hash map 上进行，遇到一个字符则计数 -1 . 而若该字符的 hash map 值仍旧 &gt;= 0 ，则说明该字符在 t 中能找到对应，此时窗口中包含 t 中字符的个数 len++. 当扩张右边界到达完全覆盖 t 时，此时的 len 刚好等于 t 的长度. 收缩左边界，计数 -1，若该字符的 hash map 值 &gt; 0 ，则说明原来的左边界是 t 中的字符，现在收缩后 len--.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// same with hash-map&lt;char, int&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">            ++count[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>; <span class="comment">// left boundary</span></span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>; <span class="comment">// right boundary</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>; <span class="comment">// The number of characters in the window that correspond to characters in t</span></span><br><span class="line">        <span class="type">int</span> minLength = s.<span class="built_in">size</span>(); <span class="comment">// min size of the window</span></span><br><span class="line">        <span class="type">int</span> startIndex = <span class="number">0</span>; <span class="comment">// start index of the window</span></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; s.<span class="built_in">length</span>()) &#123; <span class="comment">// expand</span></span><br><span class="line">            <span class="keyword">if</span> (--count[s[r++]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ++len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (len == t.<span class="built_in">length</span>()) &#123; <span class="comment">// shrink</span></span><br><span class="line">                <span class="keyword">if</span> (r - l &lt;= minLength) &#123;</span><br><span class="line">                    minLength = r - l;</span><br><span class="line">                    startIndex = l;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++count[s[l++]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (flag ? s.<span class="built_in">substr</span>(startIndex, minLength) : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(m)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>sliding-window</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 79 Word Search</title>
    <url>/2024/04/03/LeetCode79/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/word-search/">Word Search - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/word-search/solutions/2361646/79-dan-ci-sou-suo-hui-su-qing-xi-tu-jie-5yui2">回溯，清晰图解 - Krahets</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        rows = board.<span class="built_in">size</span>();</span><br><span class="line">        cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= rows || i &lt; <span class="number">0</span> || j &gt;= cols || j &lt; <span class="number">0</span> || board[i][j] != word[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="type">bool</span> res = <span class="built_in">dfs</span>(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) || </span><br><span class="line">                      <span class="built_in">dfs</span>(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i , j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="notes">Notes</h2>
<h3 id="search-pruning">search pruning</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trick：如果word末尾的连续字符少，先从末尾搜索起来，这样会减少无效搜索的次数，比如AAAAAAB前部分的搜索会集中在board中的A块，不如先搜索B块，因为只需要一个</span></span><br><span class="line">        <span class="type">int</span> front_seq = <span class="number">1</span>, back_seq = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (front_seq &lt; word.<span class="built_in">size</span>() &amp;&amp; word[front_seq] == word[front_seq<span class="number">-1</span>])  front_seq++;</span><br><span class="line">        <span class="keyword">while</span> (back_seq &lt; word.<span class="built_in">size</span>() &amp;&amp; word[word.<span class="built_in">size</span>()-back_seq] == word[word.<span class="built_in">size</span>()-back_seq<span class="number">-1</span>])  back_seq++;</span><br><span class="line">        <span class="keyword">if</span> (front_seq &gt; back_seq) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>matrix</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 791 Custom Sort String</title>
    <url>/2024/03/11/LeetCode791/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/custom-sort-string/">Custom Sort String - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>自定义比较函数排序.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">customSortString</span><span class="params">(string order, string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; orderMap;</span><br><span class="line">        <span class="type">int</span> n = order.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            orderMap[order[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), [&amp;](<span class="type">char</span> a, <span class="type">char</span> b) &#123;</span><br><span class="line">            <span class="keyword">return</span> orderMap[a] &lt; orderMap[b];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mlogm + k)</p>
<p>Space: O(k)</p>
<blockquote>
<p><code>m</code> is the length of <code>s</code></p>
<p><code>k</code> is a constant value: 26</p>
<p><code>sort()</code> 's space complexity is O(mlogm)</p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/custom-sort-string/solutions/1963410/zi-ding-yi-zi-fu-chuan-pai-xu-by-leetcod-1qvf">自定义字符串排序 - 力扣官方题解</a></p>
</blockquote>
<h3 id="better-custom-sort">Better custom sort</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">customSortString</span><span class="params">(string order, string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; order.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            val[order[i] - <span class="string">&#x27;a&#x27;</span>] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), [&amp;](<span class="type">char</span> c0, <span class="type">char</span> c1) &#123;</span><br><span class="line">            <span class="keyword">return</span> val[c0 - <span class="string">&#x27;a&#x27;</span>] &lt; val[c1 - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mlogm + k)</p>
<p>Space: O(k)</p>
<blockquote>
<p><code>m</code> is the length of <code>s</code></p>
<p><code>k</code> is a constant value: 26</p>
<p><code>sort()</code> 's space complexity is O(mlogm)</p>
</blockquote>
<h3 id="counting-sort">Counting sort</h3>
<blockquote>
<p>由于字符集的大小为 <code>26</code> ，我们也可以考虑使用计数排序代替普通的排序方法.</p>
<p>我们首先遍历字符串 <code>s</code> ，使用数组或哈希表统计每个字符出现的次数. 随后遍历字符串 <code>order</code> 中的每个字符 <code>c</code> ，如果其在 <code>s</code> 中出现了 <code>k</code> 次，就在答案的末尾添加 <code>k</code> 个 <code>c</code> ，并将数组或哈希表中对应的次数置为 <code>0</code> . 最后我们遍历一次哈希表，对于所有次数 <code>k</code> 非 <code>0</code> 的键值对 <code>(c, k)</code> ，在答案的末尾添加 <code>k</code> 个 <code>c</code> 即可.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">customSortString</span><span class="params">(string order, string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">freq</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            ++freq[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : order) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq[ch - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans += <span class="built_in">string</span>(freq[ch - <span class="string">&#x27;a&#x27;</span>], ch);</span><br><span class="line">                freq[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans += <span class="built_in">string</span>(freq[i], i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n + k)</p>
<p>Space: O(k)</p>
<blockquote>
<p><code>m</code> is the length of <code>s</code></p>
<p><code>k</code> is a constant value: 26</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>hash-table</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 787 Cheapest Flights Within K Stops</title>
    <url>/2024/02/23/LeetCode787/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/description/">Cheapest Flights Within K Stops - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>学吧</p>
<h2 id="dynamic-programming-approach">Dynamic programming approach</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/cheapest-flights-within-k-stops/solutions/954402/k-zhan-zhong-zhuan-nei-zui-bian-yi-de-ha-abzi">K 站中转内最便宜的航班 - 力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">10000</span> * <span class="number">101</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n, INF)</span></span>;</span><br><span class="line">        f[src] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= k + <span class="number">1</span>; ++t) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">g</span><span class="params">(n, INF)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; flight : flights) &#123;</span><br><span class="line">                <span class="type">int</span> j = flight[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> i = flight[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> cost = flight[<span class="number">2</span>];</span><br><span class="line">                g[i] = <span class="built_in">min</span>(g[i], f[j] + cost);</span><br><span class="line">            &#125;</span><br><span class="line">            f = <span class="built_in">move</span>(g);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, f[dst]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ans == INF ? <span class="number">-1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O((m + n) * k)</p>
<p>Space: O(n)</p>
<h2 id="dijkstra-approach">Dijkstra approach</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/cheapest-flights-within-k-stops/solutions/874532/dijkstraji-bai-100yong-hu-jie-jue-guan-f-hpmn">Dijkstra击败100%用户 解决官方解超时问题 - Lawliet</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Build the graph</span></span><br><span class="line">        <span class="type">int</span> mat[][] = <span class="keyword">new</span> <span class="type">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> flight[] : flights) &#123;</span><br><span class="line">            mat[flight[<span class="number">0</span>]][flight[<span class="number">1</span>]] = flight[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// min heap: &#123;(vertex, cost, stops), ...&#125;</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((e1, e2) -&gt; e1[<span class="number">1</span>] - e2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// costs[i]: min cost from src to vertex i</span></span><br><span class="line">        <span class="comment">// stops[i]: number of stops of the corresponding cheapest cost for vertex i</span></span><br><span class="line">        <span class="type">int</span> costs[] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">        <span class="type">int</span> stops[] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">        Arrays.<span class="built_in">fill</span>(costs, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dijkstra Algorithm within k</span></span><br><span class="line">        minHeap.<span class="built_in">offer</span>(<span class="keyword">new</span> <span class="type">int</span>[] &#123;src, <span class="number">0</span>, k&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!minHeap.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> elem[] = minHeap.<span class="built_in">poll</span>();</span><br><span class="line">            <span class="type">int</span> vertex = elem[<span class="number">0</span>], cost = elem[<span class="number">1</span>], stop = elem[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (vertex == dst) &#123;</span><br><span class="line">                <span class="keyword">return</span> cost;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[vertex][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> costI = costs[i], costVI = mat[vertex][i];</span><br><span class="line">                    <span class="keyword">if</span> (cost + costVI &lt; costI) &#123;</span><br><span class="line">                        minHeap.<span class="built_in">offer</span>(<span class="keyword">new</span> <span class="type">int</span>[] &#123;i, costVI + cost, stop - <span class="number">1</span>&#125;);</span><br><span class="line">                        costs[i] = costVI + cost;</span><br><span class="line">                        stops[i] = stop - <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stops[i] &lt; stop - <span class="number">1</span>) &#123;</span><br><span class="line">                        minHeap.<span class="built_in">offer</span>(<span class="keyword">new</span> <span class="type">int</span>[] &#123;i, costVI + cost, stop - <span class="number">1</span>&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^2 * logn)</p>
<p>Space: O(n^2 * logn)</p>
<h2 id="bellman-ford-approach">Bellman Ford approach</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/cheapest-flights-within-k-stops/solutions/955290/gong-shui-san-xie-xiang-jie-bellman-ford-dc94">【宫水三叶】运用 Bellman Ford 求解有限制的最短路问题 - 宫水三叶</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> INF = <span class="number">10000</span> * <span class="number">101</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(N, INF)</span></span>;</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> limit = <span class="number">0</span>; limit &lt; k + <span class="number">1</span>; ++limit) &#123;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(dist)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> f : flights) &#123;</span><br><span class="line">				<span class="type">int</span> x = f[<span class="number">0</span>];</span><br><span class="line">				<span class="type">int</span> y = f[<span class="number">1</span>];</span><br><span class="line">				<span class="type">int</span> w = f[<span class="number">2</span>];</span><br><span class="line">				dist[y] = <span class="built_in">min</span>(dist[y], clone[x] + w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dist[dst] &gt; INF / <span class="number">2</span> ? <span class="number">-1</span> : dist[dst];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time: O((n + m) * k)</p>
<p>Space: O(n)</p>
<h2 id="heap-approach">Heap approach</h2>
<blockquote>
<p>TODO</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
        <tag>dynamic-programming</tag>
        <tag>heap/priority-queue</tag>
        <tag>graph</tag>
        <tag>shortest-path</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 80 Remove Duplicates from Sorted Array II</title>
    <url>/2024/01/11/LeetCode80/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/">Remove Duplicates from Sorted Array II - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>也是简单的重构数组</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[k - <span class="number">2</span>]) &#123;</span><br><span class="line">                nums[k] = nums[i];</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach">Better approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; <span class="number">2</span> || n &gt; nums[k - <span class="number">2</span>]) &#123;</span><br><span class="line">                nums[k++] = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注： <code>&gt;</code> 比 <code>!=</code> 快了 4ms ，而这种 for 循环比传统形式更快，其中 <code>int</code> 比 <code>auto</code> 快.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>top-interview-150</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>top-interview-150</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 826 Apply Discount to Prices</title>
    <url>/2024/06/18/LeetCode826/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/most-profit-assigning-work/">Most Profit Assigning Work - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/most-profit-assigning-work/solutions/2780326/pai-xu-shuang-zhi-zhen-pythonjavacgojsru-gthg">排序+双指针 - 灵茶山艾府</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfitAssignment</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; difficulty, vector&lt;<span class="type">int</span>&gt;&amp; profit, vector&lt;<span class="type">int</span>&gt;&amp; worker)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = difficulty.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">jobs</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            jobs[i] = &#123;difficulty[i], profit[i]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(jobs);</span><br><span class="line">        ranges::<span class="built_in">sort</span>(worker);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, j = <span class="number">0</span>, max_profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w : worker) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; jobs[j].first &lt;= w) &#123;</span><br><span class="line">                max_profit = <span class="built_in">max</span>(max_profit, jobs[j++].second);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += max_profit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn + mlogm)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>two-pointers</tag>
        <tag>greedy</tag>
        <tag>sorting</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 872 Leaf-Similar Trees</title>
    <url>/2024/01/09/LeetCode872/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/leaf-similar-trees/description/">Leaf-Similar Trees - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p><strong>二叉树无论先中后序遍历，所得叶子节点次序不变</strong>.</p>
<h2 id="codes">Codes</h2>
<p>我采用了非递归的中序遍历方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">leafSimilar</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; leaf1;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; leaf2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// InOrder Traverse</span></span><br><span class="line">        std::stack&lt;TreeNode*&gt; stack1;</span><br><span class="line">        TreeNode* p1 = root1;</span><br><span class="line">        <span class="keyword">while</span> (p1 || !stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">                stack1.<span class="built_in">push</span>(p1);</span><br><span class="line">                p1 = p1-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p1 = stack1.<span class="built_in">top</span>();</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (!p1-&gt;right) &#123;</span><br><span class="line">                    leaf1.<span class="built_in">push_back</span>(p1-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                p1 = p1-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::stack&lt;TreeNode*&gt; stack2;</span><br><span class="line">        TreeNode* p2 = root2;</span><br><span class="line">        <span class="keyword">while</span> (p2 || !stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(p2);</span><br><span class="line">                p2 = p2-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p2 = stack2.<span class="built_in">top</span>();</span><br><span class="line">                stack2.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (!p2-&gt;right) &#123;</span><br><span class="line">                    leaf2.<span class="built_in">push_back</span>(p2-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                p2 = p2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leaf1 == leaf2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Time</strong>: O(n)</p>
<p><strong>Space</strong>: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="vector"><code>vector</code></h3>
<p><a href="https://en.cppreference.com/w/cpp/container/vector">std::vector - cppreference.com</a></p>
<h3 id="stack"><code>stack</code></h3>
<p><a href="https://en.cppreference.com/w/cpp/container/stack">std::stack - cppreference.com</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 85 Maximal Rectangle</title>
    <url>/2024/04/13/LeetCode85/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/maximal-rectangle/">Maximal Rectangle - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/maximal-rectangle/solutions/535672/zui-da-ju-xing-by-leetcode-solution-bjlu">优化暴力/单调栈 - 力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">left</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    left[i][j] = (j == <span class="number">0</span> ? <span class="number">0</span>: left[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 对于每一列，使用基于柱状图的方法</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">up</span><span class="params">(m, <span class="number">0</span>)</span>, <span class="title">down</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; left[stk.<span class="built_in">top</span>()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                up[i] = stk.<span class="built_in">empty</span>() ? <span class="number">-1</span> : stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            stk = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; left[stk.<span class="built_in">top</span>()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                down[i] = stk.<span class="built_in">empty</span>() ? m : stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="type">int</span> height = down[i] - up[i] - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> area = height * left[i][j];</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(mn)</p>
<p>Space: O(mn)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>dynamic-programming</tag>
        <tag>matrix</tag>
        <tag>monotonic-stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 894 All Possible Full Binary Trees</title>
    <url>/2024/04/02/LeetCode894/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/all-possible-full-binary-trees/">All Possible Full Binary Trees - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<h3 id="dynamic-programming-approach">Dynamic programming approach</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/all-possible-full-binary-trees/solutions/2719981/dong-tai-gui-hua-pythonjavacgojsrust-by-u3waz">动态规划 - 灵茶山艾府</a></p>
<p><span class="math inline">\(f[i]\)</span> 为有 <span class="math inline">\(i\)</span> 个<strong>叶节点</strong>的所有真二叉树的列表. 左子树的所有真二叉树列表为 <span class="math inline">\(f[j]\)</span> ，右子树的所有真二叉树列表为 <span class="math inline">\(f[i-j]\)</span></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;TreeNode*&gt; f[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> init = [] &#123;</span><br><span class="line">    f[<span class="number">1</span>] = &#123;<span class="keyword">new</span> <span class="built_in">TreeNode</span>()&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">11</span>; i++) &#123; <span class="comment">// 计算 f[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123; <span class="comment">// 枚举左子树叶子数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> left : f[j]) &#123; <span class="comment">// 枚举左子树</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> right : f[i - j]) &#123; <span class="comment">// 枚举右子树</span></span><br><span class="line">                    f[i].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>, left, right));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">allPossibleFBT</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f[n % <span class="number">2</span> ? (n + <span class="number">1</span>) / <span class="number">2</span> : <span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>时间复杂度：预处理 <span class="math inline">\(\mathcal{O}\left(\dfrac{4^N}{N^{3/2}}\right)\)</span> ，其中 <span class="math inline">\(N=10\)</span> 。根据<strong>卡特兰数</strong>，有 <span class="math inline">\(n\)</span> 个<strong>叶子</strong>的真二叉树的个数为 <span class="math inline">\(C_{n-1} = \dfrac{(2n-2)!}{n!(n-1)!}\)</span> 。其前 <span class="math inline">\(N\)</span> 项之和为 <span class="math inline">\(\mathcal{O}\left(\dfrac{4^N}{N^{3/2}}\right)\)</span></li>
<li>空间复杂度：预处理 <span class="math inline">\(\mathcal{O}\left(\dfrac{4^N}{N^{3/2}}\right)\)</span> ，即 <span class="math inline">\(f\)</span> 数组中的节点个数</li>
</ul>
</blockquote>
<h3 id="divide-and-conquer-approach">Divide and conquer approach</h3>
<blockquote>
<p><a href="https://leetcode.cn/problems/all-possible-full-binary-trees/solutions/2713780/suo-you-ke-neng-de-zhen-er-cha-shu-by-le-1uku">所有可能的真二叉树 - 力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">allPossibleFBT</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; fullBinaryTrees;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fullBinaryTrees;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            fullBinaryTrees = &#123;<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>)&#125;;</span><br><span class="line">            <span class="keyword">return</span> fullBinaryTrees;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            vector&lt;TreeNode*&gt; leftSubtrees = <span class="built_in">allPossibleFBT</span>(i);</span><br><span class="line">            vector&lt;TreeNode*&gt; rightSubtrees = <span class="built_in">allPossibleFBT</span>(n - <span class="number">1</span> - i);</span><br><span class="line">            <span class="keyword">for</span> (TreeNode* leftSubtree : leftSubtrees) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode* rightSubtree : rightSubtrees) &#123;</span><br><span class="line">                    TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>, leftSubtree, rightSubtree);</span><br><span class="line">                    fullBinaryTrees.<span class="built_in">emplace_back</span>(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fullBinaryTrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>binary-tree</tag>
        <tag>tree</tag>
        <tag>dynamic-programming</tag>
        <tag>recursion</tag>
        <tag>memoization</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 88 Merge Sorted Array</title>
    <url>/2024/01/09/LeetCode88/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/merge-sorted-array/description/">Merge Sorted Array - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>直接就是一个蛮力直接插入：）</p>
<h2 id="codes">Codes</h2>
<h3 id="brute-force">Brute force</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m + j &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt;= nums2[j]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = m + j; k &gt; i; --k) &#123;</span><br><span class="line">                    nums1[k] = nums1[k - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                nums1[i] = nums2[j];</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == m + j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = m + j; k &lt; m + n; ++k, ++j) &#123;</span><br><span class="line">                nums1[k] = nums2[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="complexity">Complexity</h3>
<p><strong>Time</strong>: O(mn)</p>
<p><strong>Space</strong>: O(1)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-approach-using-stl">Better Approach: Using STL</h3>
<ol type="1">
<li><p>Traverse through nums2 and append its elements to the end of nums1 starting from index m.</p></li>
<li><p>Sort the entire nums1 array using sort() function.</p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, i = m; j&lt;n; j++)&#123;</span><br><span class="line">            nums1[i] = nums2[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Time</strong>: O((m+n)log(m+n))</p>
<p><strong>Space</strong>: O(1)</p>
<h3 id="better-approach-two-pointer">Better Approach: Two pointer</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> k = m + n - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Time</strong>: O(m+n)</p>
<p><strong>Space</strong>: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>top-interview-150</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>top-interview-150</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 907 Sum of Subarray Minimums</title>
    <url>/2024/01/20/LeetCode907/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/sum-of-subarray-minimums/description/">Sum of Subarray Minimums - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>暴力解法 O(n^2) TLE了：遍历 vector 做一个 <code>vector&lt;int&gt; tempArray</code> ，tempArray 记录以当前元素为末尾元素的各子数组中的最小值，同时更新 sum 值. 学习题解.</p>
<h2 id="tle-codes">TLE Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tempArray;</span><br><span class="line">        <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += arr[<span class="number">0</span>];</span><br><span class="line">            tempArray.<span class="built_in">push_back</span>(arr[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="type">int</span> tempLen = tempArray.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; tempLen; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[i] &lt; tempArray[j]) &#123;</span><br><span class="line">                        tempArray[j] = arr[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    sum = (sum + tempArray[j]) % (<span class="number">1000000007</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                tempArray.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">                sum = (sum + arr[i]) % (<span class="number">1000000007</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^2)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/solutions/1/xiao-bai-lang-dong-hua-xiang-jie-bao-zhe-489q/">907. 子数组的最小值之和 - 【超小白】动画详解保证教会你这道题 - 力扣（LeetCode）</a></p>
<blockquote>
<p>假设辐射范围的左边界为 <span class="math inline">\(left\)</span> ，右边界为 <span class="math inline">\(right\)</span> ，元素E的下标为 <span class="math inline">\(i\)</span> ，那么子数组的左边界应该在 <span class="math inline">\([left,i]\)</span> 中选取，子数组的右边界应该在 <span class="math inline">\([i,right]\)</span> 中选取。因此子数组个数为 <span class="math inline">\((i - left + 1) * (right - i + 1)\)</span> ，也就是说元素 <span class="math inline">\(A[i]\)</span> 对答案的总贡献值为 <span class="math inline">\(A[i]*(i - left + 1) * (right - i + 1)\)</span> 。</p>
<p>只要计算出每个元素的贡献值，然后求和就好了。从上面可以看出求贡献值的话，i和A[i]已知，而关键在于确定辐射范围（也就是求左边界left和右边界right）。</p>
<p>因此只要我们向左👈找到第一个比 <span class="math inline">\(A[i]\)</span> 小的数 <span class="math inline">\(A[left]\)</span> 以及向右👉找到第一个比E小的数 <span class="math inline">\(A[right]\)</span> ，就可以确定E的辐射范围为 <span class="math inline">\(A[left+1:right]\)</span> 。这就叫做<strong>下一个更小/更大的数问题</strong>。解决这类问题的通用解法即为<strong>单调栈</strong>。</p>
<p>作者：超小白 链接：https://leetcode.cn/problems/sum-of-subarray-minimums/solutions/1/xiao-bai-lang-dong-hua-xiang-jie-bao-zhe-489q/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// find left</span></span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; arr[s.<span class="built_in">top</span>()] &gt; arr[i]) &#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        	s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// find right</span></span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; arr[s.<span class="built_in">top</span>()] &gt;= arr[i]) &#123;</span><br><span class="line">            	s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = s.<span class="built_in">empty</span>() ? n : s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	ans = (ans + (<span class="type">long</span> <span class="type">long</span>)(i - left[i]) * (right[i] - i) * arr[i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<blockquote>
<p><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/solutions/1929461/zi-shu-zu-de-zui-xiao-zhi-zhi-he-by-leet-bp3k/">907. 子数组的最小值之和 - 力扣（LeetCode）</a></p>
<p>官方题解还提供了 DP 的方法.</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>monotonic-stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 924 Minimize Malware Spread</title>
    <url>/2024/04/16/LeetCode924/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimize-malware-spread/">Minimize Malware Spread - LeetCode</a></p>
</blockquote>
<h1 id="notes">Notes</h1>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimize-malware-spread/solutions/2741790/zhi-bao-han-yi-ge-bei-gan-ran-jie-dian-d-ym39">只包含一个被感染节点的最大连通块 - 灵茶山艾府</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMalwareSpread</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="type">int</span>&gt;&amp; initial)</span> </span>&#123;</span><br><span class="line">        <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(initial.begin(), initial.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(graph.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>, max_size = <span class="number">0</span>, node_id, size;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            vis[x] = <span class="literal">true</span>;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="comment">// 按照状态机更新 node_id</span></span><br><span class="line">            <span class="keyword">if</span> (node_id != <span class="number">-2</span> &amp;&amp; st.<span class="built_in">contains</span>(x)) &#123;</span><br><span class="line">                node_id = node_id == <span class="number">-1</span> ? x : <span class="number">-2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; graph[x].<span class="built_in">size</span>(); y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[x][y] &amp;&amp; !vis[y]) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : initial) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[x]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node_id = <span class="number">-1</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (node_id &gt;= <span class="number">0</span> &amp;&amp; (size &gt; max_size || size == max_size &amp;&amp; node_id &lt; ans)) &#123;</span><br><span class="line">                ans = node_id;</span><br><span class="line">                max_size = size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &lt; <span class="number">0</span> ? ranges::<span class="built_in">min</span>(initial) : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^2)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>hash-table</tag>
        <tag>graph</tag>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 930 Binary Subarrays With Sum</title>
    <url>/2024/03/14/LeetCode930/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/binary-subarrays-with-sum/">Binary Subarrays With Sum - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p>假设原数组的前缀和数组为 <span class="math inline">\(\textit{sum}\)</span> ，且子数组 <span class="math inline">\((i,j]\)</span> 的区间和为 <span class="math inline">\(\textit{goal}\)</span> ，那么 <span class="math inline">\(\textit{sum}[j]-\textit{sum}[i]=\textit{goal}\)</span> 。因此我们可以枚举 <span class="math inline">\(j\)</span> ，每次查询满足该等式的 <span class="math inline">\(i\)</span> 的数量.</p>
<p><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/solutions/864087/he-xiang-tong-de-er-yuan-zi-shu-zu-by-le-5caf">和相同的二元子数组 - 力扣官方题解</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> prefixSum = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            ++count[prefixSum];</span><br><span class="line">            prefixSum += num;</span><br><span class="line">            res += count[prefixSum - goal];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="better-sliding-window-approach">Better sliding-window approach</h3>
<blockquote>
<p>注意到前缀和数组的非递减性质，</p>
<p>我们令滑动窗口右边界为 <span class="math inline">\(\textit{right}\)</span> ，使用两个左边界 <span class="math inline">\(\textit{left}_1\)</span> 和 <span class="math inline">\(\textit{left}_2\)</span> 表示左区间 <span class="math inline">\([\textit{left}_1,\textit{left}_2)\)</span> ，此时有 <span class="math inline">\(\textit{left}_2-\textit{left}_1\)</span> 个区间满足条件.</p>
<p><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/solutions/864087/he-xiang-tong-de-er-yuan-zi-shu-zu-by-le-5caf">和相同的二元子数组 - 力扣官方题解</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            sum1 += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (left1 &lt;= right &amp;&amp; sum1 &gt; goal) &#123;</span><br><span class="line">                sum1 -= nums[left1];</span><br><span class="line">                ++left1;</span><br><span class="line">            &#125;</span><br><span class="line">            sum2 += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (left2 &lt;= right &amp;&amp; sum2 &gt;= goal) &#123;</span><br><span class="line">                sum2 -= nums[left2];</span><br><span class="line">                ++left2;</span><br><span class="line">            &#125;</span><br><span class="line">            res += left2 - left1;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>sliding-window</tag>
        <tag>hash-table</tag>
        <tag>prefix-sum</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 928 Minimize Malware Spread II</title>
    <url>/2024/04/17/LeetCode928/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimize-malware-spread-ii/">Minimize Malware Spread II - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/minimize-malware-spread-ii/solutions/2743395/ni-xiang-si-wei-pythonjavaccgojsrust-by-jinc3">逆向思维 - 灵茶山艾府</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMalwareSpread</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="type">int</span>&gt;&amp; initial)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(initial.begin(), initial.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(graph.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> node_id, size;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            vis[x] = <span class="literal">true</span>;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; graph[x].<span class="built_in">size</span>(); y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (st.<span class="built_in">contains</span>(y)) &#123;</span><br><span class="line">                    <span class="comment">// 按照 924 题的状态机更新 node_id</span></span><br><span class="line">                    <span class="comment">// 注意避免重复统计，例如上图中的 0 有两条不同路径可以遇到 1</span></span><br><span class="line">                    <span class="keyword">if</span> (node_id != <span class="number">-2</span> &amp;&amp; node_id != y) &#123;</span><br><span class="line">                        node_id = node_id == <span class="number">-1</span> ? y : <span class="number">-2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || st.<span class="built_in">contains</span>(i)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node_id = <span class="number">-1</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (node_id &gt;= <span class="number">0</span>) &#123; <span class="comment">// 只找到一个在 initial 中的节点</span></span><br><span class="line">                <span class="comment">// 删除节点 node_id 可以让 size 个点不被感染</span></span><br><span class="line">                cnt[node_id] += size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min_node_id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [node_id, c] : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; max_cnt || c == max_cnt &amp;&amp; node_id &lt; min_node_id) &#123;</span><br><span class="line">                max_cnt = c;</span><br><span class="line">                min_node_id = node_id;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt.<span class="built_in">empty</span>() ? ranges::<span class="built_in">min</span>(initial) : min_node_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^2)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>hash-table</tag>
        <tag>graph</tag>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 931 Minimum Falling Path Sum</title>
    <url>/2024/01/19/LeetCode931/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-falling-path-sum/description/">Minimum Falling Path Sum - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>dp . 从底向上更新元素到底部的最短路径长度矩阵.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFallingPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> minFallingPathLen[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    minFallingPathLen[i][j] = matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        minFallingPathLen[i][j] = matrix[i][j] + <span class="built_in">min</span>(minFallingPathLen[i + <span class="number">1</span>][j], minFallingPathLen[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                        minFallingPathLen[i][j] = matrix[i][j] + <span class="built_in">min</span>(minFallingPathLen[i + <span class="number">1</span>][j], minFallingPathLen[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        minFallingPathLen[i][j] = matrix[i][j] + <span class="built_in">min</span>(minFallingPathLen[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="built_in">min</span>(minFallingPathLen[i + <span class="number">1</span>][j], minFallingPathLen[i + <span class="number">1</span>][j - <span class="number">1</span>]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> min = minFallingPathLen[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minFallingPathLen[<span class="number">0</span>][i] &lt; min) &#123;</span><br><span class="line">                min = minFallingPathLen[<span class="number">0</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^2)</p>
<p>Space: O(n^2)</p>
<h2 id="notes">Notes</h2>
<h3 id="another-approach">Another approach</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFallingPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;       </span><br><span class="line">        <span class="type">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j]=matrix[<span class="number">0</span>][j];    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> ld=<span class="number">1e9</span>,rd=<span class="number">1e9</span>;</span><br><span class="line">                <span class="type">int</span> up=matrix[i][j] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                    ld=matrix[i][j] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m)</span><br><span class="line">                    rd=matrix[i][j] + dp[i<span class="number">-1</span>][j+<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(up,<span class="built_in">min</span>(ld,rd));   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mini=dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            mini=<span class="built_in">min</span>(mini,dp[n<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mini; </span><br><span class="line">    &#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n^2)</p>
<p>Space: O(n^2)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 948 Bag of Tokens</title>
    <url>/2024/03/04/LeetCode948/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/bag-of-tokens/description">Bag of Tokens - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>贪心策略. 排序后双指针遍历贪心.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bagOfTokensScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; tokens, <span class="type">int</span> power)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(tokens.<span class="built_in">begin</span>(), tokens.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = tokens.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (power &gt;= tokens[l]) &#123;</span><br><span class="line">                power -= tokens[l++];</span><br><span class="line">                ++score;</span><br><span class="line">                res = <span class="built_in">max</span>(res, score);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                power += tokens[r--];</span><br><span class="line">                --score;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(nlogn)</p>
<blockquote>
<p>均来自 <code>sort()</code></p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>two-pointers</tag>
        <tag>greedy</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 933 Number of Recent Calls</title>
    <url>/2024/02/19/LeetCode933/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/number-of-recent-calls/description/">Number of Recent Calls - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>用栈维护 ping 的时间.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">RecentCounter</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ping</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">front</span>() &lt; t - <span class="number">3000</span>) &#123;</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(t);</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RecentCounter* obj = new RecentCounter();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;ping(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<h3 id="faster-approach">Faster approach</h3>
<p><code>q.empty()</code> 判空其实可以省略.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class RecentCounter &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    RecentCounter() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int ping(int t) &#123;</span><br><span class="line">    	q.push(t);</span><br><span class="line">        while (t - q.front() &gt; 3000) &#123;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your RecentCounter object will be instantiated and called as such:</span><br><span class="line"> * RecentCounter* obj = new RecentCounter();</span><br><span class="line"> * int param_1 = obj-&gt;ping(t);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<blockquote>
<p>queue 比 deque 要快</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-75</category>
        <category>queue</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>design</tag>
        <tag>queue</tag>
        <tag>data-stream</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 950 Reveal Cards In Increasing Order</title>
    <url>/2024/04/10/LeetCode950/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/">Reveal Cards In Increasing Order - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/reveal-cards-in-increasing-order/solutions/2347452/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-nu48">【宫水三叶】简单模拟题 - 宫水三叶</a></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">deckRevealedIncreasing</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = deck.<span class="built_in">size</span>(), idx = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : deck) d.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            map[d.<span class="built_in">front</span>()] = idx++;</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span> (!d.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                d.<span class="built_in">push_back</span>(d.<span class="built_in">front</span>());</span><br><span class="line">                d.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp = deck;</span><br><span class="line">        <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans[i] = temp[map[deck[i]]];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>queue</tag>
        <tag>sorting</tag>
        <tag>simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 945 Minimum Increment to Make Array Unique</title>
    <url>/2024/06/14/LeetCode945/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.cn/problems/minimum-increment-to-make-array-unique/">Minimum Increment to Make Array Unique - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p>看看思路，题目数据现在已经升级</p>
<p><a href="https://leetcode.cn/problems/minimum-increment-to-make-array-unique/solutions/163214/ji-shu-onxian-xing-tan-ce-fa-onpai-xu-onlogn-yi-ya">计数O(N)/线性探测法+路径压缩O(N)/排序O(NlogN), 一眼就明白 - Sweetiee</a></p>
<p>Ac的计数排序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minIncrementForUnique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Maximum possible value in the array</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MAX_VAL = <span class="number">100000</span>;</span><br><span class="line">        <span class="comment">// Array to count the frequency of each number in nums</span></span><br><span class="line">        <span class="type">int</span> freq[MAX_VAL + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// Variables to keep track of the maximum value in nums and the result</span></span><br><span class="line">        <span class="type">int</span> maxNum = <span class="number">0</span>, increments = <span class="number">0</span>, nextAvailable = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// Count the frequency of each number in nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            freq[num]++;</span><br><span class="line">            maxNum = <span class="built_in">max</span>(num, maxNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Iterate over each possible number up to the maximum number in nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">0</span>; num &lt;= maxNum; num++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq[num] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Calculate the required increment and the frequency of the current number</span></span><br><span class="line">                <span class="type">int</span> diff = <span class="built_in">max</span>(<span class="number">0</span>, nextAvailable + <span class="number">1</span> - num);</span><br><span class="line">                <span class="type">int</span> count = freq[num];</span><br><span class="line">                <span class="comment">// Calculate the total increments required to make all instances of the current number unique</span></span><br><span class="line">                increments += diff * count + (count * (count - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// Update the next available number to place the incremented values</span></span><br><span class="line">                nextAvailable = <span class="built_in">max</span>(nextAvailable + <span class="number">1</span>, num) + count - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> increments;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
</blockquote>
<h2 id="codes">Codes</h2>
<p>题目想让我们得到一个可以严格递增的数组，于是将数组进行排序，依次循环计算即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minIncrementForUnique</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(nums);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                ans+=nums[i<span class="number">-1</span>]-nums[i]+<span class="number">1</span>;</span><br><span class="line">                nums[i] +=nums[i<span class="number">-1</span>]-nums[i]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(nlogn)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>greedy</tag>
        <tag>sorting</tag>
        <tag>counting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 977 Squares of a Sorted Array</title>
    <url>/2024/03/02/LeetCode977/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/squares-of-a-sorted-array/description/">Squares of a Sorted Array - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>本题数据的特殊性，可以设置一个首指针和尾指针，以此对比得出最大的平方数.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = n - <span class="number">1</span>; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(nums[i]) &lt; <span class="built_in">abs</span>(nums[j])) &#123;</span><br><span class="line">                res[k] = nums[j] * nums[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res[k] = nums[i] * nums[i];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>当然也可以直接排序.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>two-pointers</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 988 Minimize Malware Spread II</title>
    <url>/2024/04/17/LeetCode988/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/">Smallest String Starting From Leaf - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf/solutions/815689/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-10sk">一篇文章解决所有二叉树路径问题（问题分析+分类模板+题目剖析） - 星晴pro</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s += <span class="string">&#x27;a&#x27;</span> + root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">            path.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, s);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">smallestFromLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">sort</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> path[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>todo</tag>
        <tag>depth-first-search</tag>
        <tag>binary-tree</tag>
        <tag>tree</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 992 Subarrays with K Different Integers</title>
    <url>/2024/03/30/LeetCode992/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/subarrays-with-k-different-integers/">Subarrays with K Different Integers - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<blockquote>
<p><a href="https://leetcode.cn/problems/subarrays-with-k-different-integers/solutions/598241/cong-zui-jian-dan-de-wen-ti-yi-bu-bu-tuo-7f4v">从最简单的问题一步步拓展，理解之后发现本题并不难 - 负雪明烛</a></p>
<p><strong>恰好由 K 个不同整数的子数组的个数 = 最多由 K 个不同整数的子数组的个数 - 最多由 K - 1 个不同整数的子数组的个数</strong></p>
</blockquote>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count1;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count2;</span><br><span class="line">        <span class="type">int</span> setSize1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> setSize2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count1[nums[j]] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++setSize1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count2[nums[j]] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++setSize2;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count1[nums[j]];</span><br><span class="line">            ++count2[nums[j]];</span><br><span class="line">            <span class="keyword">while</span> (setSize1 &gt; k) &#123;</span><br><span class="line">                --count1[nums[i1]];</span><br><span class="line">                <span class="keyword">if</span> (count1[nums[i1]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    --setSize1;</span><br><span class="line">                &#125;</span><br><span class="line">                ++i1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (setSize2 &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                --count2[nums[i2]];</span><br><span class="line">                <span class="keyword">if</span> (count2[nums[i2]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    --setSize2;</span><br><span class="line">                &#125;</span><br><span class="line">                ++i2;</span><br><span class="line">            &#125;</span><br><span class="line">            res += i2 - i1;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>sliding-window</tag>
        <tag>hash-table</tag>
        <tag>counting</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 995 Minimum Number of K Consecutive Bit Flips</title>
    <url>/2024/06/24/LeetCode995/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/">Minimum Number of K Consecutive Bit Flips - LeetCode</a></p>
</blockquote>
<h2 id="notes">Notes</h2>
<p><a href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/solutions/607416/k-lian-xu-wei-de-zui-xiao-fan-zhuan-ci-s-bikk">K 连续位的最小翻转次数 - 力扣官方题解</a></p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minKBitFlips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, revCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k &amp;&amp; nums[i - k] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                revCnt ^= <span class="number">1</span>;</span><br><span class="line">                nums[i - k] -= <span class="number">2</span>; <span class="comment">// 复原数组元素，若允许修改数组 nums，则可以省略</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == revCnt) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + k &gt; n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++ans;</span><br><span class="line">                revCnt ^= <span class="number">1</span>;</span><br><span class="line">                nums[i] += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>todo</tag>
        <tag>sliding-window</tag>
        <tag>queue</tag>
        <tag>prefix-sum</tag>
        <tag>bit-manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 997 Find the Town Judge</title>
    <url>/2024/02/22/LeetCode997/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/find-the-town-judge/description/">Find the Town Judge - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>图模型的入度出度统计. 从空间优化的角度出发，可以只用一个数组维护各节点的净入度.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findJudge</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (trust.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : trust) &#123;</span><br><span class="line">            --count[p[<span class="number">0</span>]];</span><br><span class="line">            ++count[p[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="notes">Notes</h2>
<p>无.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>array/string</tag>
        <tag>hash-table</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 876 Middle of the Linked List</title>
    <url>/2024/03/07/LeetCode876/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode.com/problems/middle-of-the-linked-list/">Middle of the Linked List - LeetCode</a></p>
</blockquote>
<h2 id="thinkings">Thinkings</h2>
<p>快慢指针.</p>
<h2 id="codes">Codes</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Time: O(n)</p>
<p>Space: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>two-pointers</tag>
        <tag>linked-list</tag>
        <tag>fast-slow-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer Note——basic</title>
    <url>/2024/01/09/cpp-basic/</url>
    <content><![CDATA[<blockquote>
<p>C++ Primer 5th edition 1st part</p>
</blockquote>
<h2 id="基本内置类型">基本内置类型</h2>
<p>包括算术类型和 void 类型</p>
<h3 id="arithmetic-type">Arithmetic type</h3>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>bool</td>
<td></td>
<td>undefined</td>
</tr>
<tr class="even">
<td>char</td>
<td></td>
<td>8 bit</td>
</tr>
<tr class="odd">
<td>wchar_t</td>
<td>宽字符</td>
<td>16 bit</td>
</tr>
<tr class="even">
<td>char16_t</td>
<td>Unicode</td>
<td>16 bit</td>
</tr>
<tr class="odd">
<td>char32_t</td>
<td>Unicode</td>
<td>32 bit</td>
</tr>
<tr class="even">
<td>short</td>
<td></td>
<td>16 bit</td>
</tr>
<tr class="odd">
<td>int</td>
<td></td>
<td>16 bit</td>
</tr>
<tr class="even">
<td>long</td>
<td></td>
<td>32 bit</td>
</tr>
<tr class="odd">
<td>long long</td>
<td></td>
<td>64 bit</td>
</tr>
<tr class="even">
<td>float</td>
<td></td>
<td>6 位有效数字</td>
</tr>
<tr class="odd">
<td>double</td>
<td></td>
<td>10 位有效数字</td>
</tr>
<tr class="even">
<td>long double</td>
<td>扩展精度浮点数</td>
<td>10 位有效数字</td>
</tr>
</tbody>
</table>
<blockquote>
<p>bool 的取值为 <code>true</code> 或 <code>false</code></p>
</blockquote>
<h3 id="literal">literal</h3>
<p>每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型.</p>
<h4 id="int-和-float-字面值">int 和 float 字面值</h4>
<p>整型字面值可以写作十进制数、八进制数或十六进制数的形式.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>   <span class="comment">// 十进制</span></span><br><span class="line"><span class="number">024</span>  <span class="comment">// 八进制</span></span><br><span class="line"><span class="number">0x14</span> <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>整型字面值的类型是能容纳其数值的尺寸最小者.</p>
<p>默认情况下，十进制字面值是带符号数，八进制和十六进制字面值都有可能.</p>
<p>但严格来说，十进制字面值不会是负数，那个负号并不在字面值之内，其作用仅是对字面值取负值.</p>
</blockquote>
<p>浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用 E 或 e 标识：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159</span></span><br><span class="line"><span class="number">3.14159E0</span></span><br><span class="line"><span class="number">0.</span></span><br><span class="line"><span class="number">0e0</span></span><br><span class="line"><span class="number">.001</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，浮点型字面值是 double</p>
</blockquote>
<h4 id="字符和字符串字面值">字符和字符串字面值</h4>
<p>由单引号括起来的一个字符称为 char 型字面值，双引号括起来的零个或多个字符则构成字符串型字面值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>           <span class="comment">// 字符字面值</span></span><br><span class="line"><span class="string">&quot;Hello World&quot;</span> <span class="comment">// 字符串字面值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>字符串字面值实际上是由<strong>常量字符构成的数组（array）</strong></p>
<p>编译器在每个<strong>字符串</strong>的结尾处添加一个空字符（ <code>'\0'</code> ）</p>
<p>字符串字面值较长时，可采用分开书写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;a really, really long string literal &quot;</span></span><br><span class="line">		<span class="string">&quot;that spans two lines&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 分行书写的字符串字面值</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="escape-sequence">escape sequence</h4>
<blockquote>
<p><a href="https://en.cppreference.com/w/cpp/language/escape">Escape sequences - cppreference.com</a></p>
</blockquote>
<h4 id="指定字面值的类型">指定字面值的类型</h4>
<p><strong>字符和字符串字面量</strong></p>
<table>
<thead>
<tr class="header">
<th>前缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>u</td>
<td>Unicode 16</td>
<td>char16_t</td>
</tr>
<tr class="even">
<td>U</td>
<td>Unicode 32</td>
<td>char32_t</td>
</tr>
<tr class="odd">
<td>L</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr class="even">
<td>u8</td>
<td>UTF-8（仅用于字符串字面常量）</td>
<td>char</td>
</tr>
</tbody>
</table>
<p><strong>整型字面值</strong></p>
<table>
<thead>
<tr class="header">
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>u or U</td>
<td>unsigned</td>
</tr>
<tr class="even">
<td>l or L</td>
<td>long</td>
</tr>
<tr class="odd">
<td>ll or LL</td>
<td>long long</td>
</tr>
</tbody>
</table>
<p><strong>浮点型字面值</strong></p>
<table>
<thead>
<tr class="header">
<th>后缀</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>f or F</td>
<td>float</td>
</tr>
<tr class="even">
<td>l or L</td>
<td>long double</td>
</tr>
</tbody>
</table>
<h4 id="布尔字面值和指针字面值">布尔字面值和指针字面值</h4>
<p>true 和 false 是 bool 的字面值</p>
<p>nullptr 是指针字面值（C++11 开始）</p>
<blockquote>
<p>于”指针”部分详细介绍</p>
</blockquote>
<h2 id="变量和对象">变量和对象</h2>
<blockquote>
<p><a href="https://en.cppreference.com/w/cpp/language/object">Object - cppreference.com</a></p>
</blockquote>
<h2 id="compound-type">Compound Type</h2>
<p>复合类型基于整型和浮点型创建，包括 <code>class</code> , <code>array</code> , <code>string</code> , <code>struct</code> , <code>union</code> , <code>pointer</code> , <code>enum</code> 等.</p>
<h3 id="lvalue-reference">(Lvalue) Reference</h3>
<blockquote>
<p>C++11 中新增了 rvalue reference ，这种引用主要用于内置类.</p>
<p>严格来说，当我们使用术语 “reference” 时，指的其实是 “lvalue reference”</p>
</blockquote>
<h3 id="pointer">pointer</h3>
<h4 id="void-pointer">void* pointer</h4>
<p>void* 是一种特殊的指针类型，可用于存放<strong>任意对象的地址</strong>.</p>
<blockquote>
<p>利用 void* 指针能做的事很有限：指针比较、作为函数的输入输出或者赋值</p>
</blockquote>
<h3 id="how-to-read-declarations">How to read Declarations</h3>
<blockquote>
<p>本质是运算符优先级与结合性</p>
</blockquote>
<p><a href="https://blog.parr.us/2014/12/29/how-to-read-c-declarations/">How To Read C Declarations (parr.us)</a></p>
<h2 id="const">const</h2>
<p>默认状态下， const 对象仅在文件内有效</p>
<blockquote>
<p>当以编译时初始化的方式定义一个 const 对象时（如下对 bufSize 的定义）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">512</span>;</span><br></pre></td></tr></table></figure>
<p>编译器将在编译过程中把用到该变量（如 bufSize ）的地方都替换成对应的值（如 512 ）</p>
<p>为此，默认情况下 const 对象被设定为仅在文件内有效.</p>
<p>要想在一个文件中定义一个 const variable 而在其他多个文件中声明并使用它，则需要在声明和定义时，都添加 extern 关键字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file.cc 定义并初始化了一个可其他文件访问的 const variable</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// file.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize; <span class="comment">// 声明 file.cc 中定义的 bufSize </span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="reference-to-const">reference to const</h3>
<blockquote>
<p>一般被简称为“<strong>常量引用</strong>”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> c1 = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = c1;</span><br><span class="line"></span><br><span class="line">ri = <span class="number">42</span>; <span class="comment">// error: r1 is a reference to const</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = c1; <span class="comment">// error: r2 cannot bind to a const object</span></span><br></pre></td></tr></table></figure>
<p>注： C++ 语言并不允许随意改变引用所绑定的对象.</p>
</blockquote>
<h4 id="temporary-and-initialization">temporary and initialization</h4>
<p>我们知道，引用的类型必与与其所引用对象的类型一致，但有两个例外.</p>
<p>第一种例外就是在初始化 a reference to const 时，允许用任意（结果能转换成引用类型的）表达式作为初始值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i; <span class="comment">// 正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>; <span class="comment">// 正确</span></span><br><span class="line">cosnt <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = r1 * <span class="number">2</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>r3 和 r4 实际上绑定的都是 temporary 对象. C++ 语言把类似通过 r4 修改 temporary 变量的行为定为非法.</p>
<p>因此，一个 reference to const 可以绑定一个非 const object</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i; <span class="comment">// r1 bind to i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i; <span class="comment">// r2 bind to i</span></span><br><span class="line">r1 = <span class="number">0</span>; <span class="comment">// the type of r1 is &#x27;reference to int&#x27;</span></span><br><span class="line">r2 = <span class="number">0</span>; <span class="comment">// error: the type of r2 is &#x27;reference to const int&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="pointer-and-const">pointer and const</h3>
<h4 id="pointer-to-const">pointer to const</h4>
<blockquote>
<p>与 reference to const 类似. 所谓指向常量的指针或引用，不过是自作多情，它们觉得自己指向了指针，所以自觉地不去改变所指对象的值.</p>
</blockquote>
<h4 id="const-pointer">const pointer</h4>
<p>指针是对象而引用不是，因此允许把指针本身定为 const . const pointer 必须初始化，其值（存放在指针中的地址）不能更改.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> errnumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb; <span class="comment">// curErr 将一直指向 errNumb ，curErr 是一个 const pointer </span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi; <span class="comment">// pip 是一个指向常量对象的常量指针（pointer to const）</span></span><br></pre></td></tr></table></figure>
<p>const pointer 并不意味着不能通过指针修改其所指对象的值. 如上就可以通过 curErr 去修改 errNumb 的值，而 pip 则不行.</p>
<h3 id="xxx-level-const">xxx-level const</h3>
<h4 id="top-level-const">top-level const</h4>
<p>表示对象本身是 const .</p>
<h4 id="low-level-const">low-level const</h4>
<p>表示指针或引用等符合类型所指的对象是 const .</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i; <span class="comment">// top-level const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>; <span class="comment">// top-level const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci; <span class="comment">// low-level const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *constp3 = p2; <span class="comment">// right one is a top-level const, left one is a low-level const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci; <span class="comment">// reference to const is a low-level const</span></span><br></pre></td></tr></table></figure>
<h3 id="constexpr-and-const-expression">constexpr and const expression</h3>
<h4 id="const-expression">const expression</h4>
<blockquote>
<p><a href="https://en.cppreference.com/w/cpp/language/constant_expression">Constant expressions - cppreference.com</a></p>
</blockquote>
<p><strong>值不会改变并且在编译过程就能得到计算结果的表达式</strong>. 字面值属于常量表达式，用常量表达式初始化的 const 对象也是常量表达式.</p>
<p>一个对象（或表达式）是不是常量表达式由其数据类型和初始值共同决定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>; <span class="comment">// max_files 是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">1</span>; <span class="comment">// limit 是常量表达式</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>; <span class="comment">// staff_size 不是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>(); <span class="comment">// sz 不是常量表达式</span></span><br></pre></td></tr></table></figure>
<h4 id="constexpr-variable">constexpr variable</h4>
<blockquote>
<p><a href="https://en.cppreference.com/w/cpp/language/constexpr">constexpr specifier (since C++11) - cppreference.com</a></p>
</blockquote>
<p>实际情况下，很难分辨一个初始值到底是不是常量表达式.</p>
<p>C++11 规定，允许将变量声明为 constexpr 类型以便由编译器来验证是否为常量表达式.</p>
<p>一般来说，若你认定变量为一个常量表达式，那就把它声明为 constexpr 类型. constexpr 会将其所定义的对象置为 top-level const.</p>
<blockquote>
<p>尽管不能使用普通函数作为 constexpr 变量的初始值，但新标准允许定义一种特殊的 constexpr 函数，这种函数应该足够简单以使编译时就可以得到结果，这样就能用 constexpr 函数初始化 constexpr 变量了.</p>
</blockquote>
<h4 id="literal-type">literal type</h4>
<p>由于常量表达式的值需要在编译时就得到计算结果，因此对声明 constexpr 时用到的类型必须有所限制. 这些类型一般比较简单，他们被称作”字面值类型“.</p>
<p>算术类型、引用和指针都属于 literal type ，此外枚举类型和字面值常量类也属于 literal type. 而 IO 库和 string 类型等则不属于 literal type.</p>
<blockquote>
<p>枚举类型和字面值常量类之后再提</p>
</blockquote>
<h2 id="处理类型">处理类型</h2>
<h3 id="type-alias">type alias</h3>
<p>传统的定义类型别名方法是使用关键字 typedef ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages; <span class="comment">// wages 是 double 的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base 是 double 的同义词， p 是 double* 的同义词</span></span><br></pre></td></tr></table></figure>
<p>其中 typedef double 是基本数据类型.</p>
<p>C++11 规定了一种新的方法，使用<strong>别名声明（alias declaration）</strong>来定义类型的别名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">// SI 是 Sales_item 的同义词</span></span><br></pre></td></tr></table></figure>
<p>类型别名和类型原名等价：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wages hourly, weekly; <span class="comment">// 等价于 double hourly, weekly;</span></span><br><span class="line">SI item; <span class="comment">// 等价于 Sales_item item</span></span><br></pre></td></tr></table></figure>
<h4 id="pointer-const-and-type-alias">pointer , const and type alias</h4>
<blockquote>
<p>TODO</p>
</blockquote>
<h3 id="auto-specifier">auto specifier</h3>
<blockquote>
<p>TODO</p>
</blockquote>
<h3 id="decltype-sepcifier">decltype sepcifier</h3>
<blockquote>
<p>TODO</p>
</blockquote>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
